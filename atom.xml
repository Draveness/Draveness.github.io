<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[DeltaX]]></title>
  <subtitle><![CDATA[我们来填坑吧]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://deltax.me/"/>
  <updated>2015-04-05T05:01:26.000Z</updated>
  <id>http://deltax.me/</id>
  
  <author>
    <name><![CDATA[Draven]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Prolog 基础 <1>]]></title>
    <link href="http://deltax.me/2015/04/05/Prolog-%E5%9F%BA%E7%A1%80-1/"/>
    <id>http://deltax.me/2015/04/05/Prolog-基础-1/</id>
    <published>2015-04-05T03:45:30.000Z</published>
    <updated>2015-04-05T05:01:26.000Z</updated>
    <content type="html"><![CDATA[<h2 id="为什么学习_Prolog?">为什么学习 Prolog?</h2><p><a href="http://zh.wikipedia.org/zh/Prolog" target="_blank" rel="external">Prolog</a> 是种逻辑式的编程语言. 我第一次见到这个名字的时候大约实在我学习 SICP 的过程中, 实现了一个简单的逻辑式语言的解释器. 之后我又在 CTMCP 一书中的 Relational Programming 和 Logical Programming 中多次见到 Prolog 的身影, 加上我本身对于各种编程语言非常地感兴趣, 所以我选择学习这门语言, 在这里记录一下我的学习的进度和经历, 也希望能为别人学习 Prolog 提供一下微不足道的帮助吧.</p>
<h2 id="书籍的选择">书籍的选择</h2><p>在选择学习一门新的编程语言之后, 第一件事情是上网查询一些资料因为 Prolog 的使用者极少, 所以资料也非常的难以查找, 我一开始想要使用的是 Prolog by Example, 但是因为很难找到所以就选择了 Learn Prolog Now.</p>
<h2 id="开发环境的搭建">开发环境的搭建</h2><p>怎样才能快速的搭建 Prolog 的开发环境呢, 如果你是用的 Mac. 在命令行中输入</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew cask <span class="keyword">install</span> swi-prolog</span><br></pre></td></tr></table></figure>
<p>如果没有装 brew 或者 cask, 可以在 google 上轻松找到这两个命令行工具的安装方法. 在这里我也就不在多说了.</p>
<p>我是用的编辑器是 Emacs, 使用的插件可以点<a href="http://bruda.ca/emacs/prolog_mode_for_emacs" target="_blank" rel="external">这里</a>. 安装好之后, 我们就可以开始 Prolog 之旅了.</p>
<h2 id="Prolog_基础">Prolog 基础</h2><p>Prolog 有三种非常基本结构:</p>
<ul>
<li>事实(facts)</li>
<li>规则(rules)</li>
<li>查询(queries)</li>
</ul>
<p>事实和规则被叫做 knowledge base 或者叫 database, Prolog 的编程其实就是写 knowledge base, 这些 knowledge base 就定义和保存了我们感兴趣的全部知识. 我们如何使用一个 Prolog 程序呢? 就是发起查询, 就是通过向 knowledge base 中存储的数据提出问题, 然后获取回答. 这与我们平时的使用 Objective-C Java 等命令式编程有着极大的不同.</p>
<h3 id="Facts">Facts</h3><p>首先我们先写下几个 Prolog 中的 facts, 需要打开一个文件, 后缀是 <code>.pl</code>.</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">programmer</span><span class="params">(linux)</span></span>.</span><br><span class="line"><span class="function"><span class="title">programmer</span><span class="params">(bill)</span></span>.</span><br><span class="line"><span class="function"><span class="title">designer</span><span class="params">(jonathan)</span></span>.</span><br></pre></td></tr></table></figure>
<p>这个文件 <code>facts.pl</code> 就是一些 facts 的集合, 注意, 在这里的每一个 fact 都是以 <code>.</code> 结尾的. 我们怎么使用呢, 在命令行中切换到 <code>facts.pl</code> 的目录下, 然后输入 <code>swipl</code>.</p>
<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Welcome <span class="keyword">to</span> SWI-Prolog (Multi-threaded, <span class="number">64</span> bits, Version <span class="number">6.6</span><span class="number">.6</span>)</span><br><span class="line">Copyright (c) <span class="number">1990</span>-<span class="number">2013</span> University <span class="keyword">of</span> Amsterdam, VU Amsterdam</span><br><span class="line">SWI-Prolog comes <span class="keyword">with</span> ABSOLUTELY NO WARRANTY. This <span class="keyword">is</span> free software,</span><br><span class="line"><span class="keyword">and</span> you are welcome <span class="keyword">to</span> redistribute it under certain conditions.</span><br><span class="line">Please visit http://www.swi-prolog.org <span class="keyword">for</span> details.</span><br><span class="line"></span><br><span class="line"><span class="keyword">For</span> help, <span class="keyword">use</span> ?- help(Topic). <span class="keyword">or</span> ?- apropos(Word).</span><br><span class="line"></span><br><span class="line">?-</span><br></pre></td></tr></table></figure>
<p>然后会出现这些信息, 使用 <code>consult(&#39;fact.pl&#39;).</code> 加载你的 Prolog 代码. 输入: programmer(linux).</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?- programmer(linux).</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>Prolog 会返回 <code>true</code>. 如果你输入: programmer(jonathan).</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?- programmer(jonathan).</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>它就会返回 <code>false</code>. 很简单吧.</p>
<p>当然 facts 也可以是向下面这样有多个参数</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">loves</span><span class="params">(i,u)</span></span>.</span><br><span class="line"><span class="function"><span class="title">loves</span><span class="params">(he,u)</span></span>.</span><br></pre></td></tr></table></figure>
<p>如果你输入一个不存在过程, 它就会告诉你 <code>Undefined procedure</code>.</p>
<h3 id="Rules">Rules</h3><p>接下来我们介绍一下什么是规则 rules, 规则我们理解起来非常的容易, 在 Prolog 中如何实现一些规则呢, 我们使用 <code>:-</code>.</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">sunny</span><span class="params">(today)</span></span>.</span><br><span class="line"><span class="function"><span class="title">happy</span><span class="params">(tom)</span></span>.</span><br><span class="line"><span class="function"><span class="title">football</span><span class="params">(tom)</span></span> :- <span class="function"><span class="title">sunny</span><span class="params">(today)</span></span>,<span class="function"><span class="title">happy</span><span class="params">(tom)</span></span>.</span><br></pre></td></tr></table></figure>
<p>接下来我们加载我们的代码, 询问 <code>football(tom)</code>. Prolog 会返回 <code>true</code>, 规则是什么呢, 规则的前半部分也就是 <code>football(tom)</code> 是规则的头部(head), 规则的后半部分 <code>sunny(today),happy(tom)</code> 是规则的目标(goals). 当规则的 goals 成立时, head 就会成立也就是:</p>
<p><strong>如果今天的天气很好, tom 也很开心, 那么他就会去踢足球.</strong></p>
<p>Prolog 使用 <code>,</code> 来表示 <strong>和</strong>, 使用 <code>;</code> 来表示 <strong>或</strong>. 所以在这里, 后面的两个条件都需要成立. 这样 Prolog 就能推出 <code>football(tom)</code>.</p>
<p>我们可以在 Rules 中添加变量增强我们的表达能力, 比如这样:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">father</span><span class="params">(tom,john)</span></span>.</span><br><span class="line"><span class="function"><span class="title">father</span><span class="params">(john,ive)</span></span>.</span><br><span class="line"><span class="function"><span class="title">grandfather</span><span class="params">(X,Z)</span></span>:-<span class="function"><span class="title">father</span><span class="params">(X,Y)</span></span>,<span class="function"><span class="title">father</span><span class="params">(Y,Z)</span></span>.</span><br></pre></td></tr></table></figure>
<p>我相信这对于我们是非常容易理解的, 在这里也不过多说明了.</p>
<h3 id="Queries">Queries</h3><p>什么是 queries, 其实我们在上边输入的 <code>football(tom).</code>, <code>programmer(jonathan).</code> 都是一种查询. 只是查询是否成立, 接下来我们就需要在查询中引入变量(variable)了.</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">programmer</span><span class="params">(linux)</span></span>.</span><br><span class="line"><span class="function"><span class="title">programmer</span><span class="params">(bill)</span></span>.</span><br><span class="line"><span class="function"><span class="title">designer</span><span class="params">(jonathan)</span></span>.</span><br></pre></td></tr></table></figure>
<p>还是这一段代码, 我们可以通过询问 Prolog:</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?- programmer(<span class="variable">X</span>).</span><br></pre></td></tr></table></figure>
<p>然后就会出现</p>
<figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">X </span>=<span class="string"> linux</span></span><br></pre></td></tr></table></figure>
<p>Prolog 每次只会出现最先符合条件的结果, 若果你想看其他的结果, 可以输入 <code>;</code> 也就是或, 来查看是否有其他的输入, 我们输入 <code>;</code> 之后, 会出现:</p>
<figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">X </span>=<span class="string"> bill</span></span><br></pre></td></tr></table></figure>
<p>再次输入之后, 就会返回 <code>false</code> 了, 因为没有符合条件的结果了.</p>
<h2 id="Prolog_语法">Prolog 语法</h2><p>介绍了 Prolog 中的基本元素之后, 我们想要知道, Prolog 中的基本元素到底是由什么来构建的呢, 现在来看一下 Prolog 中的基本语法.</p>
<p>Prolog 中的基本元素都是 term(<em>不知道该怎么翻译</em>)构建而来的. 而在 Prolog 中有 4 种不同的 term</p>
<ul>
<li>atom</li>
<li>number</li>
<li>variable</li>
<li>complex term</li>
</ul>
<h3 id="Atom">Atom</h3><p>符合下列条件之一的就是 Prolog 中的 atom:</p>
<ol>
<li>由大写字母, 小写字符, 数字和下划线组成的并且<strong>以小写字母开头</strong>的字符串, 例如: <code>john</code> <code>tom</code> <code>big_big</code> <code>a_bc</code>.</li>
<li>任意的包装在单引号 <code>&#39;</code> 中的字符床. 例如: <code>&#39;dsada&#39;</code> <code>*((&amp;@!MBAS))</code> <code>Fjdh_da</code>.</li>
<li>特殊的字符串, 比如 <code>:-</code> <code>;</code> <code>@=</code>.</li>
</ol>
<h3 id="Numbers">Numbers</h3><p>数字在 Prolog 中并不是非常的重要, 不过 Prolog 支持大多数的数字的表示和特殊的值.</p>
<h3 id="Variables">Variables</h3><p>变量是由由大写字母, 小写字符, 数字和下划线组成的并且<strong>以大写字母或者下划线开头</strong>的字符串, 比如 <code>X</code> <code>Variable</code> <code>_dsal</code>. </p>
<p>变量 <code>_</code> 在 Prolog 中非常的特殊被称为匿名变量.</p>
<h3 id="Complex_Terms">Complex Terms</h3><p>Complex terms 实际上就是一种结构, 而我们之前见到的</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">programmer</span><span class="params">(linux)</span></span>.</span><br><span class="line"><span class="function"><span class="title">programmer</span><span class="params">(bill)</span></span>.</span><br><span class="line"><span class="function"><span class="title">designer</span><span class="params">(jonathan)</span></span>.</span><br></pre></td></tr></table></figure>
<p>这些都是 complex terms, 而且我们也可以定义出更加复杂的结构</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">father</span>(<span class="function">father</span>(<span class="function">fahter</span>(john))).</span><br></pre></td></tr></table></figure>
<p>complex term 拥有的参数的数量叫做 arity, arity 在 complex term 中及其的重要, <code>progammer(linux)</code> 中的 <code>arity = 1</code>, <code>love(i,u)</code> 中的 <code>arity = 2</code>.</p>
<p>在 Prolog 中可以定义两个名字相同, 而 arity 不同的 predicate.</p>
<p>当我们讨论到 predicate 时, 我们经常使用 <code>/</code> 后面跟着 <code>arity</code> 的数量来表示 predicate.</p>
<p>例如:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">happy/1</span><br><span class="line">love/2</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2><p>到目前为止, 我们已经对 Prolog 有着一个大体的了解, 也能感觉到它与其他编程语言的与众不同, 而这种不同就是驱使我学习它的最大因素.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="为什么学习_Prolog?">为什么学习 Prolog?</h2><p><a href="http://zh.wikipedia.org/zh/Prolog" target="_blank" rel="external">Prolog</a> 是种逻辑式的编程语言]]>
    </summary>
    
      <category term="Logical Programming" scheme="http://deltax.me/tags/Logical-Programming/"/>
    
      <category term="Prolog" scheme="http://deltax.me/tags/Prolog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[散列表]]></title>
    <link href="http://deltax.me/2015/04/04/%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    <id>http://deltax.me/2015/04/04/散列表/</id>
    <published>2015-04-04T08:33:49.000Z</published>
    <updated>2015-04-04T15:02:46.000Z</updated>
    <content type="html"><![CDATA[<p>散列表(hash table)是实现字典操作的一种有效的数据结构. 尽管在最坏情况下, 散列表中查找一个元素的时间与链表中查找的时间相同, 达到了 $\Theta(n)$. 然而在实际的应用中, 散列表的性能是极好的, 查找元素的平均时间是 $O(1)$.</p>
<h2 id="直接寻址表">直接寻址表</h2><p>当关键字的全域 $U$ 比较小的时候, 直接寻址是一种简单有效的技术. 为表示动态集合, 我们用一个数组, 或称为<strong>直接寻址表</strong>, 记为 $T[0..m-1]$ 其中每个位置称为<strong>槽</strong>(slot).</p>
<p><img src="http://deltax.qiniudn.com/direct-address.png?attname=&e=1428235532&token=YJb_IPQrTSw1ox9LenQDH1HRcgHii9w_bp9ddmcz:a-JMUZtykWnrKYcgnea7KzRKDlo" style="display:block;margin:auto"></p>
<p>如果该集合中没有关键字为 $k$ 的元素, 那么 $T[k]=nil$.</p>
<p>我们使用 Ruby 来实现我们直接寻址表的操作.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DirectAddressTable</span></span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> </span>initialize</span><br><span class="line">		<span class="variable">@table</span> = []</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> </span>search(k)</span><br><span class="line">		<span class="variable">@table</span>[k]</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> </span>insert(x)</span><br><span class="line">		<span class="variable">@table</span>[x.key] = x</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> </span>delete(x)</span><br><span class="line">		<span class="variable">@table</span>[x.key] = <span class="keyword">nil</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>直接寻址表本身就存放动态集合中的元素. 我们直接把对象存放在表的槽中, 节省了空间. 使用对象内的一个特殊关键字 <code>nil</code> 来表明槽为空. 因此我们如果知道一个对象在表中的下标就可以得到它的关键字. 因此如果不使用关键字, 我们就需要有一种方法来确定某个槽是否为空.</p>
<h2 id="散列表">散列表</h2><p>直接寻址技术的缺点是及其明显的, 如果全域 $U$ 很大, 那么存储大小为 $\left|U \right|$ 的一张表 $T$ 也许不太实际. 实际存储的关键字集合 $K$ 相对 $U$ 来说可能很小, 使得分配地空间会被浪费掉.</p>
<p>在直接寻址方式下, 具有关键字 $k$ 的元素被存放在槽 $k$ 中. 在散列方式下, 该元素存放在槽 $h(k)$ 中. 使用散列函数 $h$, 通过关键字 $k$ 计算出槽的位置. </p>
<p>函数 $h$ 将关键字的全域 $U$ 映射到<strong>散列表</strong> $T[0..m-1]$ 中的槽上:</p>
<p>$$h:U\rightarrow \big\{0,1,…,m-1 \big\}$$</p>
<p>一个具有关键字 $k$ 的元素被散列到槽 $h(k)$ 上, 也可以说 $h(k)$ 是关键字 $k$ 的<strong>散列值</strong>.</p>
<p><img src="http://deltax.qiniudn.com/hash.png?attname=&e=1428235532&token=YJb_IPQrTSw1ox9LenQDH1HRcgHii9w_bp9ddmcz:TAG52iH7Yp7YJhMG0aEyMH3_M1A" style="display:block;margin:auto"></p>
<p>这里可能存在一个问题: 两个关键字可能映射到同一个槽中, 我们称这种情形为<strong>冲突</strong>(collision). 我们接下来介绍两种方法解决这种冲突, 一种称为<strong>链接法</strong>, 一种称为<strong>开放寻址法</strong>.</p>
<h3 id="链接法">链接法</h3><p>链接法非常地简单, 只需要把 hash 到同一槽中的元素放到同一个链表中, 槽中有一个指针会指向链表的开头, 如果不存在则为 <code>nil</code>.</p>
<p><img src="http://deltax.qiniudn.com/chaining-hash.png?attname=&e=1428237885&token=YJb_IPQrTSw1ox9LenQDH1HRcgHii9w_bp9ddmcz:Mi4Zu4awW1VX2A2y7DIoNYLYPQo" style="display:block;margin:auto"></p>
<p>使用链接法后, 散列表中的操作就很容易实现了:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class ChainedHashTable</span><br><span class="line">	</span><br><span class="line">	def initialize</span><br><span class="line">		@table = []</span><br><span class="line">	<span class="operator"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	def <span class="keyword">insert</span>(x)</span><br><span class="line">		<span class="keyword">if</span> @<span class="keyword">table</span>[x.<span class="keyword">key</span>.hash]</span><br><span class="line">			@<span class="keyword">table</span>[x.<span class="keyword">key</span>.hash] &lt;&lt; x</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			@<span class="keyword">table</span>[x.<span class="keyword">key</span>.hash] = [x]</span><br><span class="line">		<span class="keyword">end</span>	</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	def search(k)</span><br><span class="line">		@<span class="keyword">table</span>[k.hash].<span class="keyword">each</span> <span class="keyword">do</span> |<span class="keyword">key</span>|</span><br><span class="line">			<span class="keyword">if</span> <span class="keyword">key</span> == k</span><br><span class="line">				<span class="keyword">return</span> k</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	def <span class="keyword">delete</span>(x)</span><br><span class="line">		@<span class="keyword">table</span>[x.<span class="keyword">key</span>.hash].<span class="keyword">delete</span>(x)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span></span><br></pre></td></tr></table></figure>
<p>插入操作的最坏情况的运行时间为 $O(1)$. 查找操作的最坏情况运行时间与表的长度成正比. 如果散列表中的链表是双向链接的, 则删除一个元素 $x$ 的操作可以在 $O(1)$ 时间内完成.</p>
<p>给定一个能存放 $n$ 个元素的, 具有 $m$ 个槽位的散列表 $T$, 定义 $T$ 的<strong>装载因子</strong> $\alpha$ 为 $n/m$, 即一个链的平均存储元素数, $\alpha$ 可以小于等于或大于 $1$. 散列方法的平均性能依赖于使用的散列函数 $h$, 将所有的关键字集合分不在 $m$ 个槽位上的均匀程度.</p>
<p>在简单均匀散列的假设下, 对于用链接法解决冲突的散列表, 一次不成功查找的平均时间为 $\Theta(1+\alpha)$.</p>
<h3 id="开放寻址法">开放寻址法</h3><p>在开放寻址法中, 所有的元素都存放在散列表里, 也就是说, 每一个表项或包含动态集合的宇哥元素, 或包含 <code>NIL</code>. 查找某个元素时, 要系统地检查所有的表项, 知道找到所需的元素, 或者最终查明该元素不在表中.</p>
<p>开放寻址法中的散列表可能会被填满, 以至于不能插入任何的新元素. 所以装在因子 $\alpha \leq 1$.</p>
<p>为了使用开发寻址法插入一个元素, 需要连续地检查散列表, 或称为<strong>探查</strong>(probe). 知道找到一个空的槽来插入关键字为止, 探查的顺序不一定是 $0,1,…,m-1$, 而是要依赖于待插入的关键字. 使之包含探查号作为第二个输入参数, 我们的散列函数就变为:</p>
<p>$$h: U \times \big\{ 0,1,…,,-1 \big\}  \rightarrow  \big\{ 0,1,…,,-1 \big\}$$</p>
<p>对没一个关键字 $k$, 使用开放寻址法的探查序列</p>
<p>$$ \big \langle h(k,0),h(k,1),…,h(k,m-1) \big \rangle$$</p>
<p>这样的散列序列的排列, 使得当散列表逐渐填满时, 每一个表位最终都可以被考虑为用来插入新关键字的槽.</p>
<p>当向散列表中插入数据时, 我们使用如下的过程:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenAddressHashTable</span></span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> </span>initialize(max)</span><br><span class="line">		<span class="variable">@max</span> = max</span><br><span class="line">		<span class="variable">@table</span> = []</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> </span>insert(k)</span><br><span class="line">		i = <span class="number">0</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">until</span> i == m</span><br><span class="line">			j = k.hash(i)</span><br><span class="line">			<span class="keyword">if</span> <span class="variable">@table</span>[j] == <span class="keyword">nil</span></span><br><span class="line">				<span class="variable">@table</span>[j] = k</span><br><span class="line">				<span class="keyword">return</span> j</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				i = i + <span class="number">1</span></span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		</span><br><span class="line">		raise <span class="string">"Hash table overflow!"</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> </span>search(k)</span><br><span class="line">		i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">until</span> <span class="variable">@table</span>[j] == <span class="keyword">nil</span> || i == m</span><br><span class="line">			j = k.hash(i)</span><br><span class="line">			<span class="keyword">if</span> <span class="variable">@table</span>[j] == <span class="keyword">nil</span></span><br><span class="line">				<span class="keyword">return</span> j</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			i = i + <span class="number">1</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">nil</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>查找关键字 $k$ 的算法探查序列与将 $k$ 插入时的算法相同.</p>
<p>从开放寻址法的散列表中删除操作元素比较困难, 因为不能直接将其设置为 <code>nil</code> 标识它为空. 如果这样做就会有问题, 就是在槽中置一个特定的值 <code>DELETED</code> 替代为 <code>NIL</code> 来标记该槽. 但是在必须删除关键字的应用中, 最常见的做法是使用链接法来解决冲突.</p>
<p>目前, 我们又三种技术来计算开放寻址法中的探查序列: 线性探查, 二次探查和双重探查. 在这里我们不会介绍.</p>
<h2 id="散列函数">散列函数</h2><p>在散列函数在使用中经常使用启发式方法来构造性能好的散列函数, 在这里我们只介绍两种启发式的方法, 除法散列表和乘法散列表.</p>
<h3 id="除法散列法">除法散列法</h3><p>在用来设计散列函数的除法散列表中, 通过取 $k$ 除以 $m$ 的余数, 讲关键字 $k$ 映射到 $m$ 个槽中的某一个, 即散列函数为:</p>
<p>$$h(k)=k \mod m$$</p>
<p>当应用除法散列法时, 要避免选择 $m$ 的某些值, 不应为 $2$ 的幂, 或者 $10$ 的幂. 一个不太接近 $2$ 的整数幂的素数是一个比较好的选择.</p>
<h3 id="乘法散列法">乘法散列法</h3><p>构造散列函数的乘法的散列法包含两个步骤. 第一步, 用关键字 $k$ 乘上常熟 $A(0 \le A \le 1)$, 并提取 $kA$ 的小数部分. 第二步, 用 $m$ 乘以这个值, 再向下取整. 散列函数为:</p>
<p>$$h(k) = \left \lceil{m(kA \mod 1)}\right \rceil $$</p>
<p>乘法散列法的一个优点就是对 $m$ 的选择不是特别的关键, 一般选择它为 $2$ 的某个幂次.</p>
<p>Knuth 认为</p>
<p>$$A \approx (\sqrt{5}-1)/2 = 0.618 033 988 7…$$</p>
<p>是个比较理想的数值.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>散列表(hash table)是实现字典操作的一种有效的数据结构. 尽管在最坏情况下, 散列表中查找一个元素的时间与链表中查找的时间相同, 达到了 $\Theta(n)$. 然而在实际的应用中, 散列表的性能是极好的, 查找元素的平均时间是 $O(1)$.</p>
<h2 ]]>
    </summary>
    
      <category term="Algorithm" scheme="http://deltax.me/tags/Algorithm/"/>
    
      <category term="Ruby" scheme="http://deltax.me/tags/Ruby/"/>
    
      <category term="clrs" scheme="http://deltax.me/categories/clrs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[基本数据结构]]></title>
    <link href="http://deltax.me/2015/04/03/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://deltax.me/2015/04/03/基本数据结构/</id>
    <published>2015-04-03T07:20:07.000Z</published>
    <updated>2015-04-04T08:58:04.000Z</updated>
    <content type="html"><![CDATA[<p>在这一次的 post 中, 我们将要介绍一些简单的数据结构: 栈, 队列, 链表和树.</p>
<h1 id="栈和队列">栈和队列</h1><p>栈和队列都是动态集合, 在这两种数据结构上进行 <code>DELETE</code> 操作所移除的元素都是预先设定的. 它们是两种最常用的数据结构.</p>
<h2 id="栈">栈</h2><p>在栈中, 被删除的元素是<strong>最近插入</strong>的元素. 它实现的是一种<strong>后进先出</strong>(last-in, first-out, LIFO)的策略. </p>
<p>栈上的 <code>INSERT</code> 操作叫做 <code>PUSH</code>, 而无参数的 <code>DELETE</code> 操作叫做 <code>POP</code>. 我们可以使用 Ruby 中的数组来实现一个栈不需要考虑栈中所容纳的最多元素.</p>
<p>当栈中不包含任何元素时, 即栈是<strong>空</strong>的. 如果对一个空栈执行 <code>POP</code> 操作, 那么称为 <code>underflow</code>. 如果栈中的元素数量超出了所容纳的上限, 那么成为 <code>overflow</code>. 在这里我们不考虑栈的 <code>overflow</code> 问题.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span></span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> </span>initialize</span><br><span class="line">		<span class="variable">@elements</span> = []</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> </span>empty</span><br><span class="line">		<span class="variable">@elements</span>.size == <span class="number">0</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> </span>push(x)</span><br><span class="line">		<span class="variable">@elements</span>[<span class="variable">@elements</span>.size] = x</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> </span>pop</span><br><span class="line">		raise <span class="string">"Cannot pop empty stack!"</span> <span class="keyword">if</span> <span class="variable">@elements</span>.size &lt; <span class="number">0</span></span><br><span class="line">		result = <span class="variable">@elements</span>[<span class="variable">@elements</span>.size - <span class="number">1</span>]</span><br><span class="line">		<span class="variable">@elements</span>[<span class="variable">@elements</span>.size - <span class="number">1</span>] = <span class="keyword">nil</span></span><br><span class="line">		result</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这三种操作的执行时间都为 $O(1)$.</p>
<h2 id="队列">队列</h2><p>在队列中, 被删去的元素都是在集合中存在时间最长, 最先加入队列的元素. 队列实现的是一种<strong>先进先出</strong>(first-in, first-out, FIFO)策略.</p>
<p>队列中的 <code>INSERT</code> 操作成为 <code>ENQUEUE</code>, 无参数的 <code>DELETE</code> 操作被称为 <code>DEQUEUE</code>. 队列有 <code>head</code> 和 <code>tail</code>. 当一个元素入队时会放到队尾的位置, 就像排在队伍末尾买票的人, 而出队的元素总是队伍最前面等待最久的人.</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class <span class="type">Queue</span></span><br><span class="line"></span><br><span class="line">	def initialize</span><br><span class="line">		@elements = []</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	def enqueue(x)</span><br><span class="line">		@elements[@elements.size] = x</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	def dequeue</span><br><span class="line">		<span class="keyword">raise</span> <span class="string">"Queue is empty!"</span> <span class="keyword">if</span> @elements.size == <span class="number">0</span></span><br><span class="line">		<span class="literal">result</span> = @elements.shift</span><br><span class="line">		<span class="literal">result</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在这段实现代码中, 我们并没有使用 <code>@head</code> 和 <code>@tail</code> 来保存队列的头部和尾部属性. 而是使用其他的操作来代替.</p>
<h1 id="链表">链表</h1><p>链表是一种这样的数据结构, 其中的各对象按线性顺序排序. 数组的线性顺序是由数组下标决定的, 然而与数组不同的是, 链表的顺序是由各个对象里的指针决定的. 链表为动态集合提供了一种简单而灵活的表示方法.</p>
<p><strong>双向链表</strong>中的每一个元素都是一个对象, 每一个对象都有一个关键字 <code>key</code> 和两个指针: <code>next</code> 和 <code>prev</code>.</p>
<p>链表可以有多种形式. 它可以是单链接的或双链接的, 可以使已排序的或未排序的, 可以是排序的或未排序的. </p>
<ul>
<li>如果一个链表是<strong>单链接的</strong>, 则省略每个元素中的 <code>prev</code> 指针. </li>
<li>如果链表是<strong>已排序</strong>的, 则链表的线性顺序与链表元素中关键字的线性顺序一直. </li>
<li>如果链表是<strong>未排序</strong>的, 则表中的元素可以以任何顺序出现.</li>
<li>如果链表是<strong>循环链表</strong>, 表头元素的 <code>prev</code> 指针指向表尾元素, 而表尾元素的 <code>next</code> 指针指向表头元素.</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkList</span></span></span><br><span class="line">	<span class="keyword">attr_accessor</span> <span class="symbol">:head</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> </span>initialize</span><br><span class="line">		<span class="variable">@head</span> = <span class="keyword">nil</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> </span>search(key)</span><br><span class="line">		x = <span class="variable">@head</span></span><br><span class="line">		<span class="keyword">while</span> x != <span class="keyword">nil</span> &amp;&amp; x.value != key</span><br><span class="line">			x = x.<span class="keyword">next</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		x</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> </span>insert(node)</span><br><span class="line">		node.<span class="keyword">next</span> = <span class="variable">@head</span></span><br><span class="line">		<span class="variable">@head</span>.prev = node <span class="keyword">if</span> <span class="variable">@head</span> != <span class="keyword">nil</span></span><br><span class="line">		<span class="variable">@head</span> = node</span><br><span class="line">		node.prev = <span class="keyword">nil</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> </span>delete(node)</span><br><span class="line">		<span class="keyword">if</span> node.prev != <span class="keyword">nil</span></span><br><span class="line">			node.prev.<span class="keyword">next</span> = node.<span class="keyword">next</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="variable">@head</span> = node.<span class="keyword">next</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		node.<span class="keyword">next</span>.prev = node.prev <span class="keyword">if</span> node.<span class="keyword">next</span> != <span class="keyword">nil</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span></span><br><span class="line">	<span class="keyword">attr_accessor</span> <span class="symbol">:prev</span>, <span class="symbol">:value</span>, <span class="symbol">:next</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> </span>initialize(value)</span><br><span class="line">		<span class="variable">@prev</span> = <span class="keyword">nil</span></span><br><span class="line">		<span class="variable">@value</span> = value</span><br><span class="line">		<span class="variable">@next</span> = <span class="keyword">nil</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>要搜索一个有 <code>n</code> 个对象的链表, 过程 <code>search</code> 的最坏情况下的运行时间为 $\Theta(n)$, 因为可能搜索整个链表.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> </span>search(key)</span><br><span class="line">	x = <span class="variable">@head</span></span><br><span class="line">	<span class="keyword">while</span> x != <span class="keyword">nil</span> &amp;&amp; x.value != key</span><br><span class="line">		x = x.<span class="keyword">next</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	x</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>链表的插入的执行时间为 $O(1)$.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> </span>insert(node)</span><br><span class="line">	node.<span class="keyword">next</span> = <span class="variable">@head</span></span><br><span class="line">	<span class="variable">@head</span>.prev = node <span class="keyword">if</span> <span class="variable">@head</span> != <span class="keyword">nil</span></span><br><span class="line">	<span class="variable">@head</span> = node</span><br><span class="line">	node.prev = <span class="keyword">nil</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>我们先使用 <code>search</code> 寻找到目标之后, 再将目标元素 <code>delete</code>. 它的运行时间为 $O(1)$. 但是要先寻找到指定元素时, 因为要调用 <code>search</code> 所以运行时间为 $\Theta(n)$.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> </span>delete(node)</span><br><span class="line">	<span class="keyword">if</span> node.prev != <span class="keyword">nil</span></span><br><span class="line">		node.prev.<span class="keyword">next</span> = node.<span class="keyword">next</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="variable">@head</span> = node.<span class="keyword">next</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	node.<span class="keyword">next</span>.prev = node.prev <span class="keyword">if</span> node.<span class="keyword">next</span> != <span class="keyword">nil</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h1 id="树">树</h1><p>树的结点用对象表示, 我们首先将讨论二叉树.</p>
<h2 id="二叉树">二叉树</h2><p>首先我们来介绍一下二叉树的表示.</p>
<p><img src="http://deltax.qiniudn.com/bonary-tree.png?attname=&e=1428144652&token=YJb_IPQrTSw1ox9LenQDH1HRcgHii9w_bp9ddmcz:ijsBu-QD13JsmP3BXx1jRAU2t5U" style="display:block;margin:auto"> </p>
<p>上图中表示了在二叉树中, 数据是如何存储和表示的.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在这一次的 post 中, 我们将要介绍一些简单的数据结构: 栈, 队列, 链表和树.</p>
<h1 id="栈和队列">栈和队列</h1><p>栈和队列都是动态集合, 在这两种数据结构上进行 <code>DELETE</code> 操作所移除的元素都是预先设定的. 它们]]>
    </summary>
    
      <category term="Algorithm" scheme="http://deltax.me/tags/Algorithm/"/>
    
      <category term="Ruby" scheme="http://deltax.me/tags/Ruby/"/>
    
      <category term="clrs" scheme="http://deltax.me/categories/clrs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2015年3月总结]]></title>
    <link href="http://deltax.me/2015/04/02/2015%E5%B9%B43%E6%9C%88%E6%80%BB%E7%BB%93/"/>
    <id>http://deltax.me/2015/04/02/2015年3月总结/</id>
    <published>2015-04-02T14:49:23.000Z</published>
    <updated>2015-04-03T09:20:04.000Z</updated>
    <content type="html"><![CDATA[<h2 id="CTMCP">CTMCP</h2><p>这一个月的前半部分时间利用率并不是特别的高, 后半个月基本上每两天看一章算法导论, 和一部分的 CTCMP, 到今天为止 CTMCP 终于看完了.</p>
<p>看这本书的过程中虽然有些收获, 不过并没有阅读 SICP 收获来得大, 而且这本书也并没有 SICP 有趣, 能颠覆我对编程的理解和认识, 不过我还是了解了一些非常非常好玩的语言, 也对一些编程范式, 编程语言有了更深层次地理解. 以后也可以从另一个角度来看待各种各样的编程语言了. </p>
<p>不过书籍的最后一部分实在是无法阅读下去, 也只得放弃, 不过估计以后也不会再回头来看了. 书的网站对于这本书的支持也并不够, 我找到了这本书的官方社区, 发现社区 3 年只有 20 个左右的帖子. 书中的好多代码也是无法运行的, 尤其是逻辑式编程地部分, 严重地影响了读书的体验.</p>
<h2 id="Prolog_Smalltalk_Scheme">Prolog Smalltalk Scheme</h2><p>阅读这本书之后, 我对 Scheme Smalltalk 和 Prolog 有着非常浓厚地兴趣, 我会在下一个阶段的学习中学习它们, 我预计先学习 Prolog, 因为 Prolog 相对于 Smalltalk 的资源还是比较充足一些的. 而 Scheme 由于之前看过 SICP 所以只打算复习一下, 而 Smalltalk 近期还没有学习的打算.</p>
<h2 id="Sinatra">Sinatra</h2><p>在这个月我还接触到了 Ruby 的 Sinatra 框架感觉也是一个非常简介的框架, 再加上 Ruby 是一门非常优雅的语言. 我写起来还是非常爽的. 我会在下个月深入学习一下 Sinatra 的使用和部署, 争取完成一个使用 sinatra 的小项目.</p>
<h2 id="算法导论">算法导论</h2><p>算法导论这本书还是很有意思的, 不过一些数学方面的证明对于我来说还是很吃力的. 不过对于我以后不会去做算法工程师的定位, 我准备还是略微读一下这本算法界的经典, 提升一下自己的算法能力, 也能为面试做下准备. 不过对于一些习题我还是打算跳过的. 只完成一些基础方面的东西, 对算法有一些基本的理解.</p>
<h2 id="设计师">设计师</h2><p>关于设计方面, 我目前还是很头疼的, 因为我身边比较缺少这样的人, 我也一直在找, 另外我也在尝试做一些简单的设计, 虽然不能达到优秀的水平, 不过也能勉强作为一个应用的界面.</p>
<h2 id="进度">进度</h2><ol>
<li>完成 CTMCP</li>
<li>算法导论前 10 章.</li>
<li>了解 Sinatra</li>
</ol>
<h2 id="目标">目标</h2><ol>
<li>学习 Prolog</li>
<li>阅读 4 章操作系统</li>
<li>阅读 10 章算法导论</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="CTMCP">CTMCP</h2><p>这一个月的前半部分时间利用率并不是特别的高, 后半个月基本上每两天看一章算法导论, 和一部分的 CTCMP, 到今天为止 CTMCP 终于看完了.</p>
<p>看这本书的过程中虽然有些收获, 不过并没有阅读 SICP 收获]]>
    </summary>
    
      <category term="Conclusion" scheme="http://deltax.me/categories/Conclusion/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Graphical User Interface Programming]]></title>
    <link href="http://deltax.me/2015/04/02/Graphical-User-Interface-Programming/"/>
    <id>http://deltax.me/2015/04/02/Graphical-User-Interface-Programming/</id>
    <published>2015-04-02T05:03:18.000Z</published>
    <updated>2015-04-02T07:44:52.000Z</updated>
    <content type="html"><![CDATA[<p>This post will show a particularly simple and powerful way to do graphical user inteerface programming. We combine the declarative model together with the shared-state concurrent model. First, we will summarize the existing approaches.</p>
<ul>
<li>Purely procedurel<ul>
<li>The user interface is constructed by a sequence of graphics commands. These commands can be purely imperative or even functional. The object-oriented or functional style is preferable to an imperative style.</li>
</ul>
</li>
<li>Purely declarative<ul>
<li>The user interface is constructed by choosing from a set of predefined possibilities. This is an example of descriptive declarativeness.</li>
</ul>
</li>
<li>Using an interface builder<ul>
<li>The user interface is constructed manully by the developer, using a direct manipulation interface.</li>
</ul>
</li>
</ul>
<p>The procedural approach is expressive but is complex to use.<br>The declarative approach is easy to use but lacks expressiveness.<br>The interface builder is easy to use and gives immediate feedback on the interface but it lacks expressiveness and the interface is haard to change at run time.</p>
<h2 id="The_Declarative/Procedural_Approach">The Declarative/Procedural Approach</h2><p>What are the relative merits of the declarative and procedural approaches to specifying user interfaces? The trade-off is between expressiveness and manipulability:</p>
<ul>
<li>The declrative approach defines a set of possibilities for different attributes. The developer chooses among this set and defines a data structure that describes the interface. <ul>
<li>The pure declarative approach makes it easy to formally manipulate the user definitions. But the expressiveness is limited bacause it is only possible to express what the designers initially thought of.</li>
</ul>
</li>
<li>The procedural approach gives a set of primitive operations and the ability to write programs to them. These programs construct the interface. <ul>
<li>A purely procedural approach has no limits on its expressiveness. However, this makes harder to do formal manipulations on the user interface definitions.</li>
</ul>
</li>
</ul>
<p>The trade-off is not a temporary state of affairs. It is a deep property of computational models. As a language becomes more expressive, its programs become less amenable to formal manipulation.</p>
<p>It is still possible to define a model that is both manipulate and expressive. We can do it by combing the declarative and procedural approaches.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>This post will show a particularly simple and powerful way to do graphical user inteerface programming. We combine the declarative model ]]>
    </summary>
    
      <category term="CTMCP" scheme="http://deltax.me/tags/CTMCP/"/>
    
      <category term="GUI Programming" scheme="http://deltax.me/tags/GUI-Programming/"/>
    
      <category term="Programming Paradigm" scheme="http://deltax.me/categories/Programming-Paradigm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Relational Programming]]></title>
    <link href="http://deltax.me/2015/04/01/Relational-Programming/"/>
    <id>http://deltax.me/2015/04/01/Relational-Programming/</id>
    <published>2015-04-01T07:15:09.000Z</published>
    <updated>2015-04-01T13:47:27.000Z</updated>
    <content type="html"><![CDATA[<p>A relational procedure is more flexible than a functional procedure in two ways. </p>
<ul>
<li>First, there can be any number of results to a call. </li>
<li>Second, which arguments are inputs and which are outputs can be different for each call.</li>
</ul>
<p>These features make relational programming well-suited for databases and parsers. And it extends declarative programming with a new kind of statement called a “choice”. And <code>Prolog</code> language uses a choice operation as the heart of its execution model.</p>
<p>The flexibility of relational programming has a reverse side. It can easily lead to inefficient programs. Relational programming is practical in these areas:</p>
<ul>
<li>When the search space is small.</li>
<li>As an exploratory tool.</li>
</ul>
<h1 id="The_Relational_Computational_Model">The Relational Computational Model</h1><p>The relational computational model extends the declrative model with two new statements, <code>choice</code> and <code>fail</code>.</p>
<ul>
<li>The <code>choice</code> statement group together a set of alternative statements.</li>
<li>The <code>fail</code> statement indicates that the current alternative is wrong.</li>
</ul>
<h2 id="Search_Tree">Search Tree</h2><p>A relational program is executed sequentially. The <code>choice</code> statements are executed in the order that they are encountered during execution.</p>
<p>When a <code>choice</code> is first executed, its first alternativeis picked. When  <code>fail</code> is executed, execution “backs up” to the most recent <code>choice</code> statement.</p>
<p>This execution stategy can be illustrated with a tree called the search tree.</p>
<p><img src="http://deltax.qiniudn.com/Search-Tree.png?attname=&e=1427974813&token=YJb_IPQrTSw1ox9LenQDH1HRcgHii9w_bp9ddmcz:O2ESA3L4RlojzLV7kuJE2QxJrVk" style="display:block;margin:auto"></p>
<h2 id="The_Solve_Function">The <code>Solve</code> Function</h2><p>We provide encapsulated search by adding one function, <code>Solve</code> to the computation model. The call <code>{Solve F}</code> is given a zero-argument function <code>F</code> that returns a solution to a relational program. This returns a lazy list of all solutions with <code>DFS</code>.</p>
<p>We just look the first element with this function:</p>
<figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fun</span> &#123;<span class="type">SolveOne</span> <span class="type">F</span>&#125;</span><br><span class="line">   <span class="type">L</span>=&#123;<span class="type">Solve</span> <span class="type">F</span>&#125;</span><br><span class="line"><span class="keyword">in</span></span><br><span class="line">   <span class="keyword">if</span> <span class="type">L</span>==<span class="literal">nil</span> <span class="keyword">then</span> <span class="literal">nil</span> <span class="keyword">else</span> [<span class="type">L</span>.<span class="number">1</span>] <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>To get all-solution search, we look at the whole list:</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun &#123;<span class="type">SolveAll</span> F&#125;</span><br><span class="line">   L=&#123;<span class="type">Solve</span> F&#125;</span><br><span class="line">   <span class="keyword">proc</span> &#123;<span class="type">TouchAll</span> L&#125;</span><br><span class="line">      <span class="keyword">if</span> L==<span class="keyword">nil</span> then skip <span class="keyword">else</span> &#123;<span class="type">TouchAll</span> L.<span class="number">2</span>&#125; <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">in</span></span><br><span class="line">   &#123;<span class="type">TouchAll</span> L&#125;</span><br><span class="line">   L</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>A relational procedure is more flexible than a functional procedure in two ways. </p>
<ul>
<li>First, there can be any number of results ]]>
    </summary>
    
      <category term="CTMCP" scheme="http://deltax.me/tags/CTMCP/"/>
    
      <category term="Oz" scheme="http://deltax.me/tags/Oz/"/>
    
      <category term="Relational Programming" scheme="http://deltax.me/tags/Relational-Programming/"/>
    
      <category term="Programming Paradigm" scheme="http://deltax.me/categories/Programming-Paradigm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Transactions]]></title>
    <link href="http://deltax.me/2015/04/01/Transactions/"/>
    <id>http://deltax.me/2015/04/01/Transactions/</id>
    <published>2015-04-01T03:50:46.000Z</published>
    <updated>2015-04-01T07:13:06.000Z</updated>
    <content type="html"><![CDATA[<p>Transactions were introduced as a basic concept for the management of larget shared database.</p>
<p>The term “transaction” has acquired a fairly meaning, it is any operation satisfies the four <code>ACID</code> properties which is an acronym.</p>
<ul>
<li>A stands for <strong>atmoic</strong><ul>
<li>No intermediate states of a transaction’s execution are observable.</li>
</ul>
</li>
<li>C stands for <strong>consistent</strong><ul>
<li>Observable state changes respect the system invariants. Consistentcy is closely related to atomicity. The difference is the consistency is responsibility for programmer, whereas atmoicity is the responsibility of the implemenation of the trasaction system.</li>
</ul>
</li>
<li>I stands for <strong>isolation</strong><ul>
<li>Several transactions can execute concurrently without interfering with each other. They execute as if they were sequential.</li>
</ul>
</li>
<li>D stands for <strong>durabulity</strong><ul>
<li>Observable state changes survive across system shutdowns. This is often called persistence.</li>
</ul>
</li>
</ul>
<h2 id="Movivations">Movivations</h2><ul>
<li>One motivation for transactions was to increase the throughtput of concurrent accesses to a database.</li>
<li>A second motivation is concurrent programming with exceptions. Most routines has two way to exit, either they exit normally or they raise an exception. And there are two solutions when an exception raised.<ul>
<li>The caller can clean up the called routine’s mess.</li>
<li>The routine can be inside a transaction. Raising an exception corresponds to aborting the transaction.</li>
</ul>
</li>
<li>A third motivation is fault tolerance. A fault tolerance application has to take three steps:<ol>
<li>Detect the fault.</li>
<li>Contain the fault in a limited part of the application</li>
<li>Repair any problems caused by the fault.</li>
</ol>
</li>
<li>A fourth motivation is resource management.</li>
</ul>
<h2 id="Concurrency_Control">Concurrency Control</h2><p>Consider a large database by many clients at the same time. They are concurrent yet still satisfy serializability. The implementation should allow concurrent transaction and yet it has to make sure that they are still serializable.</p>
<p>Concurrency control is the set of techniques used to build and program concurrent sysmtems with transactional properties. Our algorithm is interesting because it is both practical and simple.</p>
<h3 id="Locks_and_Timestamps">Locks and Timestamps</h3><p>The two most widely used approaches to concurrency control are locks and timestamps:</p>
<ul>
<li>Lock-based concurrency control<ul>
<li>Each stateful entity has a lock that controls access to the entity Locks always restricting the system’s behavior so that it is safe.</li>
</ul>
</li>
<li>Timestamp-based concurrency control<ul>
<li>Each transaction is given a timestamp that gives it a priority. Timestamps are important to ensure that execution makes progress.</li>
</ul>
</li>
</ul>
<p>Safety and liveness propeties describe how a system hahaves as a function of time.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Transactions were introduced as a basic concept for the management of larget shared database.</p>
<p>The term “transaction” has acquired ]]>
    </summary>
    
      <category term="CTMCP" scheme="http://deltax.me/tags/CTMCP/"/>
    
      <category term="Oz" scheme="http://deltax.me/tags/Oz/"/>
    
      <category term="Programming Paradigm" scheme="http://deltax.me/categories/Programming-Paradigm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Stateful Concurrent Data Abstraction]]></title>
    <link href="http://deltax.me/2015/03/31/Stateful-Concurrent-Data-Abstraction/"/>
    <id>http://deltax.me/2015/03/31/Stateful-Concurrent-Data-Abstraction/</id>
    <published>2015-03-31T08:56:39.000Z</published>
    <updated>2015-04-01T03:11:18.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Lock">Lock</h1><p>It often happens when threads wish to access a shared resource, but the resource can only be accessed by one thread at a time. This always called race condition and may causes unexcepted error during execution.</p>
<p>To manage this situation, we introduce a language concept called lock, to help control access to resource.</p>
<p>A lock dynamicically controls access to part of the program, called a critical region. If the shared resource is only accessed from within the critical region, then the lock can be used to control access to the resource.</p>
<p>We are ready to program stateful concurrent data abstractions and give a systematic way to transform a declrative data abstraction to become stateful concurrent data abstraction.</p>
<p>We illustrate the different techniques by means of simple example, a queue.</p>
<h2 id="Declarative_Version">Declarative Version</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fun <span class="string">&#123;NewQueue&#125;</span></span><br><span class="line">X in</span><br><span class="line">	<span class="string">q(0 X X)</span></span><br><span class="line">end</span><br><span class="line">fun &#123;Insert <span class="string">q(N S E)</span> X&#125;</span><br><span class="line">E1 in</span><br><span class="line">	E=X|E1 <span class="string">q(N+1 S E1)</span></span><br><span class="line">end</span><br><span class="line">fun &#123;Delete <span class="string">q(N S E)</span> X&#125;</span><br><span class="line">S1 in</span><br><span class="line">	S=X|S1 <span class="string">q(N-1 S1 E)</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>This is essentially the declarative queue. The order of the queue operations is explicitly determined by the program.</p>
<h2 id="Sequential_Stateful_Version">Sequential Stateful Version</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fun <span class="string">&#123;NewQueue&#125;</span></span><br><span class="line">	X C=&#123;NewCell <span class="string">q(0 X X)</span>&#125;</span><br><span class="line">	proc &#123;Insert X&#125;</span><br><span class="line">	N E E1 in</span><br><span class="line">		<span class="string">q(N S X|E1)</span>=<span class="variable">@C</span></span><br><span class="line">		C:=<span class="string">q(N+1 S E1)</span></span><br><span class="line">	end</span><br><span class="line">	fun <span class="string">&#123;Delete&#125;</span></span><br><span class="line">	N S1 E X in</span><br><span class="line">		<span class="string">q(N X|S1 E)</span>=<span class="variable">@C</span></span><br><span class="line">		C:=<span class="string">q(N-1 S1 E)</span></span><br><span class="line">		X</span><br><span class="line">	end</span><br><span class="line">in</span><br><span class="line">	queue(insert:Insert <span class="keyword">delete</span>:Delete)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>This show the same queue in a stateful version encapsulated the queue’s data. But this version cannot be used in concurrency. Because the <code>@</code> operation and <code>:=</code> operation. If two threads each do an insert operation, this may causes interleaving, which may gets incorrect answer.</p>
<h2 id="Concurrent_Stateful_Version_with_Lock">Concurrent Stateful Version with Lock</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fun <span class="string">&#123;NewQueue&#125;</span></span><br><span class="line">	X C=&#123;NewCell <span class="string">q(0 X X)</span>&#125;</span><br><span class="line">	L=<span class="string">&#123;NewLock&#125;</span></span><br><span class="line">	proc &#123;Insert X&#125;</span><br><span class="line">	N E E1 in</span><br><span class="line">		lock L then</span><br><span class="line">			<span class="string">q(N S X|E1)</span>=<span class="variable">@C</span></span><br><span class="line">			C:=<span class="string">q(N+1 S E1)</span></span><br><span class="line">	end</span><br><span class="line">	end</span><br><span class="line">	fun <span class="string">&#123;Delete&#125;</span></span><br><span class="line">	N S1 E X in</span><br><span class="line">		lock L then</span><br><span class="line">			<span class="string">q(N X|S1 E)</span>=<span class="variable">@C</span></span><br><span class="line">			C:=<span class="string">q(N-1 S1 E)</span></span><br><span class="line">		end</span><br><span class="line">		X</span><br><span class="line">	end</span><br><span class="line">in</span><br><span class="line">	queue(insert:Insert <span class="keyword">delete</span>:Delete)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>This version shows a concurrent version of stateful queue, using a lock to ensure atomicity of the read-operation-write sequence. Doing this version in different threads will not impose any synchronization between the threads. This property is a consequence of using state.</p>
<h2 id="Concurrent_Object-Oriented_Version_with_Lock">Concurrent Object-Oriented Version with Lock</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Queue</span><br><span class="line">	attr queue</span><br><span class="line">	prop locking</span><br><span class="line">	</span><br><span class="line">	meth init</span><br><span class="line">		queue:=<span class="string">q(0 X X)</span></span><br><span class="line">	end</span><br><span class="line">	</span><br><span class="line">	meth insert(X)</span><br><span class="line">		lock N S E1 in</span><br><span class="line">			<span class="string">q(N S X|E1)</span>=<span class="variable">@queue</span></span><br><span class="line">			queue:=<span class="string">q(N+1 S E1)</span></span><br><span class="line">		end</span><br><span class="line">	end</span><br><span class="line">	</span><br><span class="line">	meth <span class="keyword">delete</span>(X)</span><br><span class="line">		lock N S1 E in</span><br><span class="line">			<span class="string">q(N X|S1 E)</span>=<span class="variable">@queue</span></span><br><span class="line">			queue:=<span class="string">q(N-1 S1 E)</span></span><br><span class="line">		end</span><br><span class="line">	end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>This version is rewrittern with object-oriented syntax. The cell is replaced by the attribute <code>queue</code> and the lock is implicitly defined by the <code>locking</code> property.</p>
<h2 id="Concurrent_Stateful_Version_with_Exchange">Concurrent Stateful Version with Exchange</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fun <span class="string">&#123;NewQueue&#125;</span></span><br><span class="line">	X C=&#123;NewCell <span class="string">q(0 X X)</span>&#125;</span><br><span class="line">	proc &#123;Insert X&#125;</span><br><span class="line">	N S E1 N1 in</span><br><span class="line">		&#123;Exchange C <span class="string">q(N S X|E1)</span>	 <span class="string">q(N1 S E1)</span>&#125;</span><br><span class="line">		N1=N+<span class="number">1</span></span><br><span class="line">	end</span><br><span class="line">	fun <span class="string">&#123;Delete&#125;</span></span><br><span class="line">	N S1 E N1 X in</span><br><span class="line">		&#123;Exchange C <span class="string">q(N X|S1 S)</span>	 <span class="string">q(N1 S1 E)</span>&#125;</span><br><span class="line">		N1=N-<span class="number">1</span></span><br><span class="line">		X</span><br><span class="line">	end</span><br><span class="line">in</span><br><span class="line">	queue(insert:Insert <span class="keyword">delete</span>:Delete)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>This version is made by <code>Exchange</code> operation, because this is single state operation, so no locks are needed.</p>
<h1 id="Monitors">Monitors</h1><p>Locks are an important tool for building abstraction in a stateful model, but they are not sufficient. </p>
<p>The standard way of coordinating threads in a stateful model is by monitor. A monitor is a lock extended with program control over how waiting threads enter and exit the lock.</p>
<p>The monitors adds a <code>wait</code> and <code>notify</code> operation to the lock entry and exit operations. </p>
<ul>
<li>When inside a monitor, a thread can explicitly do a <code>wait</code>; suspend the thread, and entered into the monitor wait set, and release the monitor lock.</li>
<li>When a thread does a <code>notify</code>, it lets one thread in the wait set continue. This thread attempts to get the monitor lock again.</li>
</ul>
<h2 id="Definition">Definition</h2><p>A monitor is always part of an object. It is an object with an internal lock and wait set. Object methoded can be protected by the lock by annotating them as <code>synchronized</code>. There are three  operations to manage the lock: <code>wait</code>, <code>notify</code>, and <code>notifyAll</code>.</p>
<ul>
<li>The <code>wait</code> operation<ul>
<li>The current thread is suspended.</li>
<li>The thread is placed in the object’s internal wait set.</li>
<li>The lock for the object is released.</li>
</ul>
</li>
<li>The <code>notify</code> operation<ul>
<li>If one exists, an arbitrary thread <code>T</code> is removed from the object’s internal wait set.</li>
<li><code>T</code> proceeds to get the lock, just as any other thread. This means that <code>T</code> will always suspend for a short time, until the notifying releases the lock.</li>
<li><code>T</code> resumes execution at the point it was suspended.</li>
</ul>
</li>
<li>The <code>notify</code> operation<ul>
<li>Similar to <code>notify</code> except does above steps for all threads. The wait set is emptied.</li>
</ul>
</li>
</ul>
<p>Monitors are disigned for building concurrent data abstractions based on shared state.</p>
<h2 id="Bounded_Buffer">Bounded Buffer</h2><p>The bounded buffer is an object with three operations.</p>
<ul>
<li><code>B={New Buffer init(N)}</code>: create a new bouned buffer <code>B</code> of size <code>N</code>.</li>
<li><code>B={Put (X)}</code>: put the element <code>X</code> in buffer. If the buffer is fill, this will block until the buffer has room for the element.</li>
<li><code>B={Get (X)}</code>: remove the element <code>X</code> from the buffer. If the buffer is empty this will block until there is at least one element.</li>
</ul>
<h3 id="Partial_Definition_of_Monitor_Version">Partial Definition of Monitor Version</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Buffer</span><br><span class="line">   attr</span><br><span class="line">      buf <span class="keyword">first</span> <span class="keyword">last</span> n i</span><br><span class="line"></span><br><span class="line">   meth init(N)</span><br><span class="line">      buf:=&#123;NewArray <span class="number">0</span> N-<span class="number">1</span> <span class="constant">null</span>&#125;</span><br><span class="line">      <span class="keyword">first</span>:=<span class="number">0</span></span><br><span class="line">      <span class="keyword">last</span>:=<span class="number">0</span></span><br><span class="line">      n:=N</span><br><span class="line">      i:=<span class="number">0</span></span><br><span class="line">   <span class="function"><span class="keyword">end</span></span></span><br><span class="line"></span><br><span class="line">   meth <span class="built_in">put</span>(X)</span><br><span class="line">      @buf.@<span class="keyword">last</span>:=X</span><br><span class="line">      <span class="keyword">last</span>:=(@<span class="keyword">last</span>+<span class="number">1</span>) <span class="operator">mod</span> @n</span><br><span class="line">      i:=@i+<span class="number">1</span></span><br><span class="line">   <span class="function"><span class="keyword">end</span></span></span><br><span class="line"></span><br><span class="line">   meth <span class="built_in">get</span>(X)</span><br><span class="line">      X=@buf.@<span class="keyword">first</span></span><br><span class="line">      <span class="keyword">first</span>:=(@<span class="keyword">first</span>+<span class="number">1</span>) <span class="operator">mod</span> @n</span><br><span class="line">      i:=@i-<span class="number">1</span></span><br><span class="line">   <span class="function"><span class="keyword">end</span></span></span><br><span class="line"><span class="function"><span class="keyword">end</span></span></span><br></pre></td></tr></table></figure>
<p>The partial definition of the monitor does not check the bounded of the monitor. And then we will use monitor to implement this.</p>
<h3 id="Monitor_Version">Monitor Version</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Buffer</span><br><span class="line">   attr m buf <span class="keyword">first</span> <span class="keyword">last</span> n i</span><br><span class="line"></span><br><span class="line">   meth init(N)</span><br><span class="line">      m:=&#123;NewMonitor&#125;</span><br><span class="line">      buf:=&#123;NewArray <span class="number">0</span> N-<span class="number">1</span> <span class="constant">null</span>&#125;</span><br><span class="line">      n:=N i:= <span class="number">0</span> <span class="keyword">first</span>:=<span class="number">0</span> <span class="keyword">last</span>:=<span class="number">0</span></span><br><span class="line">   <span class="function"><span class="keyword">end</span></span></span><br><span class="line">   </span><br><span class="line">   meth <span class="built_in">put</span>(X)</span><br><span class="line">      &#123;@m.<span class="string">'lock'</span> proc &#123;$&#125;</span><br><span class="line">		    <span class="keyword">if</span> @i&gt;@n <span class="keyword">then</span> &#123;@m.<span class="built_in">wait</span>&#125; &#123;self <span class="built_in">put</span>(X)&#125;</span><br><span class="line">		    <span class="keyword">else</span></span><br><span class="line">		       @buf.@<span class="keyword">last</span>:=X</span><br><span class="line">		       <span class="keyword">last</span>:=(@<span class="keyword">last</span>+<span class="number">1</span>) <span class="operator">mod</span> @n</span><br><span class="line">		       i:=@i+<span class="number">1</span></span><br><span class="line">		       &#123;@m.notifyAll&#125;</span><br><span class="line">		    <span class="function"><span class="keyword">end</span></span></span><br><span class="line">		 <span class="function"><span class="keyword">end</span>&#125;</span></span><br><span class="line">   <span class="function"><span class="keyword">end</span></span></span><br><span class="line"></span><br><span class="line">   meth <span class="built_in">get</span>(X)</span><br><span class="line">      &#123;M.<span class="string">'lock'</span> proc &#123;$&#125;</span><br><span class="line">		   <span class="keyword">if</span> @i==<span class="number">0</span> <span class="keyword">then</span> &#123;@m.<span class="built_in">wait</span>&#125; &#123;self <span class="built_in">get</span>(X)&#125;</span><br><span class="line">		   <span class="keyword">else</span></span><br><span class="line">		      X=@buf.@<span class="keyword">first</span></span><br><span class="line">		      <span class="keyword">first</span>:=(@<span class="keyword">first</span>+<span class="number">1</span>) <span class="operator">mod</span> n</span><br><span class="line">		      i:=i-<span class="number">1</span></span><br><span class="line">		      &#123;@m.notifyAll&#125;</span><br><span class="line">		   <span class="function"><span class="keyword">end</span></span></span><br><span class="line">		<span class="function"><span class="keyword">end</span>&#125;</span></span><br><span class="line">   <span class="function"><span class="keyword">end</span></span></span><br><span class="line"><span class="function"><span class="keyword">end</span></span></span><br></pre></td></tr></table></figure>
<p>If the buffer is full, then <code>{M.wait}</code> simply waits until it is no longer full. When <code>get(X)</code> removes an element, it calls <code>{M.notifyAll}</code>, which wakes up the waiting thread.</p>
<h2 id="Programming_with_Monitors">Programming with Monitors</h2><p>The idea of monitors is guarded. Guarded methods are implemented using the <code>wait</code> and <code>notifyAll</code> operations.</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">meth methHead</span><br><span class="line">	lock</span><br><span class="line">		<span class="keyword">while</span> <span class="keyword">not</span> &lt;expr&gt; <span class="keyword">do</span> wait;</span><br><span class="line">		&lt;stmt&gt;</span><br><span class="line">		notifyAll;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>In this example, <code>&lt;expr&gt;</code> is the guard and <code>&lt;stmt&gt;</code> is the guarded body. When the method is called, the thread enters the lock and waits for conition in a <code>while</code> loop. If the <code>&lt;expr&gt;</code> is true, this executes the body and notify all the other threads. If not, threads wait until other notify them.</p>
<h2 id="Implementing_Monitors">Implementing Monitors</h2><p>Now let us impelement monitors in the shared-state concurrent model. This is thread-reentrant and correctly handles exceptions.</p>
<h3 id="Extended_Concurrent_Stateful_Version_Queue">Extended Concurrent Stateful Version Queue</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fun &#123;NewQueue&#125;</span><br><span class="line">	......</span><br><span class="line">   fun &#123;Size&#125;</span><br><span class="line">      <span class="operator"><span class="keyword">lock</span> L <span class="keyword">then</span> @C<span class="number">.1</span> <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   fun &#123;DeleteAll&#125;</span><br><span class="line">      <span class="keyword">lock</span> L <span class="keyword">then</span> </span><br><span class="line">     	X q(_ S E)=@C <span class="keyword">in</span></span><br><span class="line">			C:=q(<span class="number">0</span> X X)</span><br><span class="line">			E=nil S</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   fun &#123;DeleteNonBlock&#125;</span><br><span class="line">      <span class="keyword">lock</span> L <span class="keyword">then</span></span><br><span class="line"> 			<span class="keyword">if</span> &#123;<span class="keyword">Size</span>&#125;&gt;<span class="number">0</span> <span class="keyword">then</span> [&#123;<span class="keyword">Delete</span>&#125;] <span class="keyword">else</span> nil <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">in</span></span><br><span class="line">   queue(<span class="keyword">insert</span>:<span class="keyword">Insert</span> <span class="keyword">delete</span>:<span class="keyword">Delete</span> <span class="keyword">size</span>:<span class="keyword">Size</span> deleteAll:DeleteAll deleteNonBlock:DeleteNonBlock)</span><br><span class="line"><span class="keyword">end</span></span></span><br></pre></td></tr></table></figure>
<h3 id="Reentrant_Get-release_Version_Lock">Reentrant Get-release Version Lock</h3><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fun &#123;<span class="type">NewGRLock</span>&#125;</span><br><span class="line">	<span class="type">Token1</span>=&#123;<span class="type">NewCell</span> unit&#125;</span><br><span class="line">	<span class="type">Token2</span>=&#123;<span class="type">NewCell</span> unit&#125;</span><br><span class="line">	<span class="type">CurThr</span>=&#123;<span class="type">NewCell</span> unit&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">proc</span> &#123;<span class="type">GetLock</span>&#125;</span><br><span class="line">		<span class="keyword">if</span> &#123;<span class="type">Thread</span>.this&#125;\=@<span class="type">CurThr</span> then <span class="type">Old</span> <span class="type">New</span> <span class="keyword">in</span></span><br><span class="line">			&#123;<span class="type">Exchange</span> <span class="type">Token1</span> <span class="type">Old</span> <span class="type">New</span>&#125;</span><br><span class="line">			&#123;<span class="type">Wait</span> <span class="type">Old</span>&#125;</span><br><span class="line">			<span class="type">Token2</span>:=<span class="type">New</span></span><br><span class="line">			<span class="type">CurThr</span>:=&#123;<span class="type">Thread</span>.this&#125;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">proc</span> &#123;<span class="type">ReleaseLock</span>&#125;</span><br><span class="line">		<span class="type">CurThr</span>:=unit</span><br><span class="line">		unit=@<span class="type">Token2</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">in</span></span><br><span class="line">	'lock'(get:<span class="type">GetLock</span> release:<span class="type">ReleaseLock</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="Monitor_Implementation">Monitor Implementation</h3><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fun &#123;<span class="type">NewMonitor</span>&#125;</span><br><span class="line">   Q=&#123;<span class="type">NewQueue</span>&#125;</span><br><span class="line">   L=&#123;<span class="type">NewGRLock</span>&#125;</span><br><span class="line">   <span class="keyword">proc</span> &#123;<span class="type">LockM</span> P&#125;</span><br><span class="line">      &#123;L.get&#125; <span class="keyword">try</span> &#123;P&#125; <span class="keyword">finally</span> &#123;L.release&#125; <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">proc</span> &#123;<span class="type">WaitM</span>&#125; X <span class="keyword">in</span></span><br><span class="line">      &#123;Q.insert X&#125; &#123;L.release&#125; &#123;<span class="type">Wait</span> X&#125; &#123;L.get&#125;</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">proc</span> &#123;<span class="type">NotifyM</span>&#125; U=&#123;Q.deleteNonBlock&#125; <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">case</span> U <span class="keyword">of</span> [X] then X=unit <span class="keyword">else</span> skip <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">proc</span> &#123;<span class="type">NotifyAllM</span>&#125; L=&#123;Q.deleteAll&#125; <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">for</span> X <span class="keyword">in</span> L <span class="keyword">do</span> X=unit <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">in</span></span><br><span class="line">   monitor('lock':<span class="type">LockM</span> wait:<span class="type">WaitM</span> notify:<span class="type">NotifyM</span></span><br><span class="line">	   notifyAll:<span class="type">NotifyAllM</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Lock">Lock</h1><p>It often happens when threads wish to access a shared resource, but the resource can only be accessed by one threa]]>
    </summary>
    
      <category term="CTMCP" scheme="http://deltax.me/tags/CTMCP/"/>
    
      <category term="Concurrency" scheme="http://deltax.me/tags/Concurrency/"/>
    
      <category term="Oz" scheme="http://deltax.me/tags/Oz/"/>
    
      <category term="Programming Paradigm" scheme="http://deltax.me/categories/Programming-Paradigm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Shared-State Concurrency]]></title>
    <link href="http://deltax.me/2015/03/30/Shared-State-Concurrency/"/>
    <id>http://deltax.me/2015/03/30/Shared-State-Concurrency/</id>
    <published>2015-03-30T06:54:21.000Z</published>
    <updated>2015-03-31T11:48:26.000Z</updated>
    <content type="html"><![CDATA[<p>After reading the chapter 8 in CTMCP, I wirte this post gives an alternative way to implement concurrency model by adding cells.</p>
<h1 id="Programming_With_Concurrency">Programming With Concurrency</h1><p>By now, we have seen many different apporoach to write concurrent programs. And before introduce to <code>Shared-State Concurrency</code>. Let’s list all the approaches to implement concurrency.</p>
<ul>
<li>Sequential Programming</li>
<li>Declarative Programming</li>
<li>Message-Passing Concurrency</li>
<li>Shared-State Concurrency</li>
</ul>
<h2 id="Sequential_Programming">Sequential Programming</h2><p>In a sequential model, there is a total order among all opertions. This is the strongest order invariant a program can have. And this variant model is deterministic.</p>
<h2 id="Declarative_Concurrency">Declarative Concurrency</h2><p>This does not change the result of a calculation, but only changes the order in which the result is obtained.</p>
<p>These models have nondeterminism in the implementation, since the system choose how to advance the threads.</p>
<p>The demand-driven concurrent model, also known as lazy execution, is a form of declarative concurrency. It does not change the result of a calculation but only affects how much calculation is done to obtain the result.</p>
<h2 id="Message-Passing_Concurrency">Message-Passing Concurrency</h2><p>Message passing is a basic programming style of stateful concurrent model. It extends the declarative model with a simple kind of communication channel, a port.</p>
<h2 id="Shared-State_Concurrency">Shared-State Concurrency</h2><p>Shared state is another basic programming style of the stateful concurrent model. It consists of a set of threads accessing a set of shared passive object.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>After reading the chapter 8 in CTMCP, I wirte this post gives an alternative way to implement concurrency model by adding cells.</p>
<h1 ]]>
    </summary>
    
      <category term="CTMCP" scheme="http://deltax.me/tags/CTMCP/"/>
    
      <category term="Concurrency" scheme="http://deltax.me/tags/Concurrency/"/>
    
      <category term="Oz" scheme="http://deltax.me/tags/Oz/"/>
    
      <category term="Programming Paradigm" scheme="http://deltax.me/categories/Programming-Paradigm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Active Object]]></title>
    <link href="http://deltax.me/2015/03/30/Active-Object/"/>
    <id>http://deltax.me/2015/03/30/Active-Object/</id>
    <published>2015-03-30T06:05:38.000Z</published>
    <updated>2015-03-30T06:28:07.000Z</updated>
    <content type="html"><![CDATA[<p>An active object is a port object whose behavior is defined by a class. It consists of a port, a thread that reads messages from the port’s stream, and an object that is a class inheritance.</p>
<p>Active objects combine the abilities of OOP and the abilities of message-passing concurrency.</p>
<p>With respect to active obejects, the other obejcts of this object are called <em>passive objects</em>, since they have an internal thread.</p>
<h1 id="NewActive_Abstraction">NewActive Abstraction</h1><p>The behavior of avtive objects is defined with a class. Sending a message to an active object is the same as sending message to an object. And the invocation of the method is asynchronous. It returns immediately without waiting until the message has been handled.</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun &#123;<span class="type">NewActive</span> <span class="type">Class</span> <span class="type">Init</span>&#125;</span><br><span class="line">   <span class="type">Obj</span>=&#123;<span class="type">New</span> <span class="type">Class</span> <span class="type">Init</span>&#125;</span><br><span class="line">   P</span><br><span class="line"><span class="keyword">in</span></span><br><span class="line">   thread S <span class="keyword">in</span></span><br><span class="line">      &#123;<span class="type">NewPort</span> S P&#125;</span><br><span class="line">      <span class="keyword">for</span> M <span class="keyword">in</span> S <span class="keyword">do</span> &#123;<span class="type">Obj</span> M&#125; <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">proc</span> &#123;$ M&#125; &#123;<span class="type">Send</span> P M&#125; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>This makes defining active objects very intuitive.</p>
<h1 id="Synchronous_Abstraction">Synchronous Abstraction</h1><p>A synchronous invocation <code>{Obj M}</code> does not return until the method corresponding to <code>M</code> is completely executed. Here is the definition of <code>NewSync</code>, which creates a synchronous active object.</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun &#123;<span class="type">NewSync</span> <span class="type">Class</span> <span class="type">Init</span>&#125;</span><br><span class="line">P <span class="type">Obj</span>=&#123;<span class="type">New</span> <span class="type">Class</span> <span class="type">Init</span>&#125; <span class="keyword">in</span></span><br><span class="line">	thread S <span class="keyword">in</span></span><br><span class="line">		&#123;<span class="type">NewPort</span> S P&#125;</span><br><span class="line">		<span class="keyword">for</span> M<span class="comment">#X in S do &#123;Obj M&#125; X=unit end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">proc</span> &#123;$ M&#125; X <span class="keyword">in</span> &#123;<span class="type">Send</span> P M<span class="comment">#X&#125; &#123;Wait X&#125; end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>Each message sent to the object contains a synchronization token <code>X</code>, which is bound only when the message is completely handled.</p>
<h1 id="Active_Objects_with_Exception_Handling">Active Objects with Exception Handling</h1><p>Use exception handling means add <code>try catch</code> in the statement. The abstraction needs another argument whether or not an exception occurred.</p>
<p>The extra argument is bound to <code>normal</code> if the invocation completes normally, and to <code>exception(E)</code> if the object raises the exception <code>E</code>.</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fun &#123;NewActiveExc Class Init&#125;</span><br><span class="line">P Obj=&#123;New Class Init&#125; <span class="operator">in</span></span><br><span class="line">	thread S <span class="operator">in</span></span><br><span class="line">		&#123;NewPort S P&#125;</span><br><span class="line">		<span class="keyword">for</span> M<span class="comment">#X in S do</span></span><br><span class="line">			<span class="keyword">try</span> &#123;Obj M&#125; X=<span class="keyword">normal</span></span><br><span class="line">			<span class="keyword">catch</span> E <span class="keyword">then</span> X=exception(E) <span class="function"><span class="keyword">end</span></span></span><br><span class="line">		<span class="function"><span class="keyword">end</span></span></span><br><span class="line">	<span class="function"><span class="keyword">end</span></span></span><br><span class="line">	proc &#123;$ M X&#125; &#123;Send P M<span class="comment">#X&#125; end</span></span><br><span class="line"><span class="function"><span class="keyword">end</span></span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>An active object is a port object whose behavior is defined by a class. It consists of a port, a thread that reads messages from the port]]>
    </summary>
    
      <category term="CTMCP" scheme="http://deltax.me/tags/CTMCP/"/>
    
      <category term="OOP" scheme="http://deltax.me/tags/OOP/"/>
    
      <category term="Oz" scheme="http://deltax.me/tags/Oz/"/>
    
      <category term="Programming Paradigm" scheme="http://deltax.me/categories/Programming-Paradigm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[中位数和顺序统计量]]></title>
    <link href="http://deltax.me/2015/03/27/%E4%B8%AD%E4%BD%8D%E6%95%B0%E5%92%8C%E9%A1%BA%E5%BA%8F%E7%BB%9F%E8%AE%A1%E9%87%8F/"/>
    <id>http://deltax.me/2015/03/27/中位数和顺序统计量/</id>
    <published>2015-03-27T10:34:48.000Z</published>
    <updated>2015-03-27T14:10:29.000Z</updated>
    <content type="html"><![CDATA[<h1 id="顺序统计量">顺序统计量</h1><p>在一个由 $n$ 个元素组成的集合中, 第 $i$ 个顺序统计量 (order statistic) 是该集合中第 $i$ 小的元素.</p>
<ul>
<li><strong>最小值</strong>是第 $1$ 个顺序统计量 $i=1$.</li>
<li><strong>最大值</strong>是第 $n$ 个顺序统计量 $i=n$.</li>
<li><strong>中位数</strong>是所属集合的中点元素.<ul>
<li>当 $n$ 为偶数时, 存在两个中位数, 分别位于 $i=n/2$ 和 $i=n/2+1$.</li>
<li>当 $n$ 为奇数时, 中位数是唯一的, 位于 $i=(n+1)/2$.</li>
</ul>
</li>
</ul>
<h1 id="选择问题">选择问题</h1><p>我们将讨论从一个由 $n$ 个元素互异的集合中选择第 $i$ 个顺序统计量的问题, 把这一类问题形式化定义为如下的<strong>选择问题</strong>.</p>
<blockquote>
<p>输入: 一个包含 $n$ 个(互异的)数的集合 $A$ 和一个整数 $i$, 其中 $1 \leq i \leq n$<br>输出: 元素 $x \in A$, 且 $A$ 中恰好有 $i-1$个其它元素小于它.</p>
</blockquote>
<h1 id="期望为线性时间的选择算法">期望为线性时间的选择算法</h1><p>我们将介绍一种解决选择问题的算法, 渐进时间为 $\Theta (n)$. 与快速排序一样, 我们将输入数组进行递归划分. 但与快速排序不同的是, 我们只会处理划分的一边. 所以快速排序的期望运行复杂度为 $\Theta (n \lg n)$, 而在这里选择算法的期望运行时间为 $\Theta (n)$</p>
<p><code>RANDOMIZED_SELECT</code> 利用了 <code>randomized_partition</code> 过程, 它也是一个随机算法.</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#define EXCHANGE(a, b) tmp = a; a = b; b = tmp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">randomized_select</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> p, <span class="keyword">int</span> r, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q, k;</span><br><span class="line">    <span class="keyword">if</span> (p == r) &#123;</span><br><span class="line">        <span class="keyword">return</span> A[p];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    q = randomized_partition(A, p, r);</span><br><span class="line">    k = q - p + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == k) &#123;</span><br><span class="line">        <span class="keyword">return</span> A[q];</span><br><span class="line">    &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(i &lt; k)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">randomized_select</span><span class="params">(A, p, q - <span class="number">1</span>, i)</span></span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">randomized_select</span><span class="params">(A, q + <span class="number">1</span>, r, i - k)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">randomized_partition</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = rand() % (r - p) + p,</span><br><span class="line">        tmp;</span><br><span class="line"></span><br><span class="line">    EXCHANGE(A[i], A[r - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">partition</span><span class="params">(A, p, r)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = A[r - <span class="number">1</span>],</span><br><span class="line">        i = p - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = p; j &lt; r; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[j] &lt;= x) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            EXCHANGE(A[j], A[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    EXCHANGE(A[r], A[i + <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RANDOMIZED_SELECT</code> 的运行过程如下:</p>
<ul>
<li><code>if (p == r)</code> 检查递归的基本情况, 即数组 $A[p..r]$ 中只包含一个元素.</li>
<li><code>randomized_partition(A, p, r)</code> 将数组 $A[p..r]$ 划分为两个可能为空的子数组 $A[p..q - 1]$ 和  $A[q + 1..r]$, 使得前者中每个元素都小于 $A[p]$, 后者大于 $A[p]$, 其中  $A[q]$ 为主元.</li>
<li><code>k = q - p + 1</code> 计算子数组 $A[p..q]$ 中的元素个数, 及处于划分的低区的元素的个数加 $1$, $1$ 为主元素..</li>
<li><code>if (i == k)</code> 检查 $A[q]$ 是否是第 $i$ 小的元素, 如果是就返回 <code>RANDOMIZED_SELECT(A, p, q - 1, i)</code>, 如果是直接返回 $A[q]$, 否则返回 <code>RANDOMIZED_SELECT(A, q + 1, r, i - k)</code>, 其中 $i-k$ 为元素在高区的相对位置.</li>
</ul>
<p><code>RANDOMIZED_SELECT</code> 的最坏情况的运行时间为 $\Theta (n^2)$. 这样的运行时间并不是我们需要的, 下面我们将介绍一种效率更高的选择算法.</p>
<h1 id="最坏情况为线性时间的选择算法">最坏情况为线性时间的选择算法</h1><p>我们现在来介绍一个最坏情况的运行时间 $O(n)$ 的选择算法. 像 <code>RANDOMIZED_SELECT</code> 算法一样, <code>SELECT</code> 算法通过对输入数组的递归划分来找出所需的元素. 它使用的也是来自快速排序的确定性划分算法, <code>PARTITION</code>.</p>
<p>通过执行一下步骤, 算法可以确定一个有 $n&gt;1$ 个不同元素的输入数组中第 $i$ 小的元素:</p>
<ol>
<li>将输入数组的 $n$ 个元素划分成 $\left \lceil{x/5}\right \rceil$ , 每组 $5$ 个元素, 且至多由剩下的 $n mod 5$ 个元素组成.</li>
<li>寻找这 $\left \lfloor{x/5}\right \rfloor$ 组中每一组饿中位数: 首先对每组元素进行插入排序, 然后确定中位数.</li>
<li>对第 $2$ 步中找出的 $\left \lceil{x/5}\right \rceil$ 个中位数, 递归调用 <code>SELECT</code> 以找出其中位数 $x$.</li>
<li>利用修改过的 <code>partition</code> 版本, 按中位数的中位数 $x$ 对输入数组进行划分. 让 $k$ 比划分的低区中的元素数目多 $1$. 因此 $x$ 是第 $k$ 小的元素, 并且有 $n-k$ 个元素在划分的高区.</li>
<li>如果 $i=k$, 则返回 $x$. 如果 $i<k$, 则在低区递归调用="" `select`="" 已找出第="" $i$="" 小的元素.="" 如果="" $i="">k$ 小的元素.</k$,></li>
</ol>
<p>如果划分的主元素为 $x$, 至少有一半大于或等于中位数的中位数 $x$. 只要有一半的组中有 $3$ 个元素大于 $x$, 不算中间这个组, 大于 $x$ 的元素个数只要为:</p>
<p>$$3(\left \lceil \frac{1}{2}\left \lceil{\frac{n}{5}}\right \rceil \right \rceil) \geq \frac{3n}{10}$$</p>
<p>所以我们现在有一个递归式来推导 <code>SELECT</code> 算法的最坏情况的运行时间 $T(n)$了.</p>
<p>$$T(n) \leq \begin{cases}<br> &amp; O(1) &amp; \text{ if } n &lt; 140 \\<br> &amp; T(\left \lceil{x/5}\right \rceil) + T(7n/10+6) + O(n) &amp; \text { if } n \geq 140<br>\end{cases}$$</p>
<p>所以, 可以得到 $T(n) = O(n)$.</p>
<p>与比较排序一样, <code>SELECT</code> 和 <code>RANDOMIZED_SELECT</code> 也是通过元素之间的比较来确定它们之间的相对次序的.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="顺序统计量">顺序统计量</h1><p>在一个由 $n$ 个元素组成的集合中, 第 $i$ 个顺序统计量 (order statistic) 是该集合中第 $i$ 小的元素.</p>
<ul>
<li><strong>最小值</strong>是第 $1$ 个顺序统]]>
    </summary>
    
      <category term="Algorithm" scheme="http://deltax.me/tags/Algorithm/"/>
    
      <category term="clrs" scheme="http://deltax.me/categories/clrs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Object-Oriented-Programming and Other Programming Paradigms]]></title>
    <link href="http://deltax.me/2015/03/26/Object-Oriented-Programming-and-Other-Programming-Paradigms/"/>
    <id>http://deltax.me/2015/03/26/Object-Oriented-Programming-and-Other-Programming-Paradigms/</id>
    <published>2015-03-26T11:09:33.000Z</published>
    <updated>2015-03-26T13:29:00.000Z</updated>
    <content type="html"><![CDATA[<p>Object-Oriented Programming is one way to structure programs which is most often used together with explicit state. The main difference between this computational model to other is <strong>polymorphism</strong> and <strong>inheritance</strong>.</p>
<p>In my opinion, this computational model is important but not magic. There are many opponents and different ideas.</p>
<p><a href="https://www.quora.com/Was-object-oriented-programming-a-failure" target="_blank" rel="external">Was object-oriented programming a failure?</a></p>
<p><a href="https://www.quora.com/What-are-some-programming-paradigms-other-than-Object-Oriented" target="_blank" rel="external">What are some programming paradigms other than Object Oriented?</a></p>
<h1 id="Higher-order_Programming">Higher-order Programming</h1><p>Object-oriented programming and high-order programming are closely related. A new sorting routine can be created by giving a particular order function.</p>
<p>We can write this in high-order programming:</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">proc</span> &#123;<span class="type">NewSortRoutine</span> <span class="type">Order</span> ?<span class="type">SortRoutine</span>&#125;</span><br><span class="line">	<span class="keyword">proc</span> &#123;<span class="type">SortRoutine</span> <span class="type">InL</span> <span class="type">OutL</span>&#125;</span><br><span class="line">		% ... &#123;<span class="type">Order</span> X Y&#125; calculates order</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">proc</span> &#123;<span class="type">Order</span> X Y ?B&#125;</span><br><span class="line">	B=(X&lt;Y)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="type">SortRoutine</span>=&#123;<span class="type">NewSortRoutine</span> <span class="type">Order</span>&#125;</span><br></pre></td></tr></table></figure>
<p>In <code>OOP</code>, this can be written as follows:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">SortRoutineClass</span></span><br><span class="line">	attr ord</span><br><span class="line">	meth init<span class="container">(<span class="type">Order</span>)</span></span><br><span class="line">		ord:=<span class="type">Order</span></span><br><span class="line">	end</span><br><span class="line">	meth sort<span class="container">(<span class="type">InL</span> <span class="type">OutL</span>)</span></span><br><span class="line">		% ... &#123;@ord order<span class="container">(<span class="type">X</span> <span class="type">Y</span> $)</span>&#125; calculates order</span><br><span class="line">	end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="type">OrderClass</span></span><br><span class="line">	meth init skip end</span><br><span class="line">	meth order<span class="container">(<span class="type">X</span> <span class="type">Y</span> <span class="type">B</span>)</span></span><br><span class="line">		<span class="type">B</span>=<span class="container">(<span class="type">X</span>&lt;<span class="type">Y</span>)</span></span><br><span class="line">	end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="type">SortRoutine</span>=&#123;<span class="type">New</span> <span class="type">SortRoutineClass</span> init<span class="container">(&#123;<span class="type">New</span> <span class="type">OrderClass</span> <span class="title">init</span>&#125;)</span>&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="Embellishments">Embellishments</h2><p>Procedure values and objects are closed related. Let us now compare higher-order and object-oriented programming more carefully.</p>
<p>The main difference is that <code>OOP</code> embellishes high-order programming. With embellishments, object-oriented provides a collection of additional idioms beyond procedural abstraction:</p>
<ul>
<li>Explicit state can be defined and used easily.</li>
<li>Multiple methods that share the same explicit state can be defined easily.</li>
<li>Classes are provided, which define a set of methods and can be instantiated. If objects are like procedures, then classes are like procedures that return procedures.</li>
<li>Inheritance is provided, to define new sets of methods from existing sets.</li>
<li>Different degrees of encapsulation can be defined between classes and obejcts.</li>
</ul>
<p>These mechanisms do not provide any fundamentally new ability. All these things can be implemented with high-order programming, explicit state and name values.</p>
<p><code>OOP</code> is an abstraction that provides a rich notation to use any or all of these mechanisms together. But this is a double-edged sword.</p>
<ul>
<li>It makes the abstraction particularly useful for many programming tasks.</li>
<li>The abstraction has a complex semantics and is hard to reason about.</li>
</ul>
<h2 id="Common_Limitations">Common Limitations</h2><p>The object system defined here is particularly close to high-order programming. But not all the object system is so close. In common use, the following characteristics are aften absent or cumbersome to use:</p>
<ul>
<li>Classes are values<ul>
<li>Classes can be created at run time, passed as arguments, and stored in data structures.</li>
</ul>
</li>
<li>Full lexical scoping<ul>
<li>Language supports procedure values with external references.</li>
</ul>
</li>
<li>First-class messages<ul>
<li>Allow messages to be values in the languages.</li>
</ul>
</li>
</ul>
<p>There are also some object-oriented languages do not support high-order programming because they define procedure values with lexical scoping at run time. Many of the mechanisms can be obtained through inheritanceand encapsulation.</p>
<ul>
<li>A procedure value can be encoded as object.<ul>
<li>The object’s attributes represent the procedure value’s external references and the method arguments are the procedure value’s arguments.</li>
</ul>
</li>
<li>A generic procedure can be encoded as an abstract class.<ul>
<li>A generic procedure is one that tkes procedure arguments and return a specific procedure. An abstract class is a class with undefined methods. And the methods are implemented in subclasses.</li>
</ul>
</li>
</ul>
<h2 id="Should_everything_be_an_object?">Should everything be an object?</h2><p>Now, let us discover the practical of everything is object.</p>
<h3 id="String_Objects">String Objects</h3><p>A sensible way to define the principle is as “all language entities should be instances of data abstractions with as many generic properties as possible.” There are six properties this principle implies.</p>
<ul>
<li>All language entities should be defined with the object style.</li>
<li>All language entities should be defined in the terms of classes can be instantiated.</li>
<li>All language entities should be extensible with inheritance.</li>
<li>All language entities should have a unique identity.</li>
<li>All language entities should excapsulate a state.</li>
<li>All language entities should be accessed with a uniform syntax.</li>
</ul>
<p>In most languages, not all entities are strong objects. An integer in Objective-C is a pure value in the <code>ADT</code> style. It is not defined by a class or encapsulate a state. </p>
<p>And there is not any language only have strong objects.</p>
<ol>
<li>The ADT style is sometimes essential.</li>
<li>Stateless entities can play an important role.</li>
<li>Not all entities need a unique identity.</li>
<li>The simplicity of a uniform syntax is illusory.</li>
</ol>
<p>With them, the powerful reasoning techniques of declarative programming become possible.</p>
<h3 id="Objects_and_program_complexity">Objects and program complexity</h3><p>How can one predict a particular object’s behavior. It depends on two factor:</p>
<ol>
<li>Its internal state, which potentially depends on all past calls. These calls can be done from many parts of the program.</li>
<li>Its textual definiation, which depends on all classes it inherits from. These classes can be defined in many places in the program text.</li>
</ol>
<h3 id="Uniform_object_syntax">Uniform object syntax</h3><p>A language’s syntax should help and not hinder programmers in designing, writing and reasoning about programs. An important principle  in syntax design is form mirrors content.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Object-Oriented Programming is one way to structure programs which is most often used together with explicit state. The main difference b]]>
    </summary>
    
      <category term="CTMCP" scheme="http://deltax.me/tags/CTMCP/"/>
    
      <category term="OOP" scheme="http://deltax.me/tags/OOP/"/>
    
      <category term="Oz" scheme="http://deltax.me/tags/Oz/"/>
    
      <category term="Programming Paradigm" scheme="http://deltax.me/categories/Programming-Paradigm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Programming with Inheritance]]></title>
    <link href="http://deltax.me/2015/03/26/Programming-with-Inheritance/"/>
    <id>http://deltax.me/2015/03/26/Programming-with-Inheritance/</id>
    <published>2015-03-26T04:03:48.000Z</published>
    <updated>2015-03-26T07:22:46.000Z</updated>
    <content type="html"><![CDATA[<h1 id="How_to_use_Inheritance">How to use Inheritance</h1><p>There are two ways to view inheritance. </p>
<ul>
<li>The <strong>type</strong> view<blockquote>
<p>Classes are types and subclasses are subtypes. The type view is consistent with the principle that classes should model real-world entities or some abstract versions of them. In type view, classes satisfy the substitution property: every operation works on class <code>C</code> also works on subclass of <code>C</code>.</p>
</blockquote>
</li>
<li>The <strong>structure</strong> view<blockquote>
<p>Inheritance is just another programming tool that is used to structure programs. This view is strongly discouraged bacause classes no longer satisfy the substituion property.</p>
</blockquote>
</li>
</ul>
<p>In the type view, each class stands on its own two feet. And in the structure view, classes are sometimes just scaffolding, which exists only for its role in structuring he program.</p>
<p>In the vast majority of cases, inheritance shuld respect the type view. And the rest of this blog is mainly consider the type view.</p>
<h2 id="Desin_by_Contract">Desin by Contract</h2><p>Based on the teniques such as using aximatic semantics of the formal semantics, Bertrand Mayer has developed a method for designing correct programs called <strong>design by contract</strong> and implement it.</p>
<p>The principle idea of design by contract is that a data abstraction implies a contract between the abstraciton’s designer and its users.</p>
<ul>
<li>The user must guarantee that an abstraction is called in the right way.</li>
<li>The designer must guarantee that the right value is returned after the procedure executed.</li>
</ul>
<p>The user is responsible for the preconditions and the disigner is responsible for the postconditions.</p>
<p>In the data abstraction, we should check if the precondition is valid and the user followed the contract. This is checked at boundary when the data abstraction is called which can be in either runtime or compile time.</p>
<h2 id="Things_should_Prevented">Things should Prevented</h2><p>There are such things that we should not use when dealing with inheritance.</p>
<ul>
<li>The subsitution property was regularly violated.</li>
<li>Classes were subclassed to fix small problems.</li>
</ul>
<p>The most important principle using inheritance is to use it add new functionality and not to patch a broken class.</p>
<h2 id="Reengineering">Reengineering</h2><p>The general goal of reengnnering is to take an exisinting system and attempt to improve some of its property by changing the source code. However reengineering cannot resurrect a failed project.</p>
<h1 id="Generic_Classes">Generic Classes</h1><p>A generic class is one that only defines part of the functionality of a data abstraction. It has to be completely before it can be used to create objects. How can we define generic class, there are two ways for us to make it.</p>
<h2 id="Using_Inheritance">Using Inheritance</h2><p>A common way to use generic class is to use abstract classes. </p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericSort</span></span></span><br><span class="line">   meth init skip <span class="keyword">end</span></span><br><span class="line">   meth qsort(<span class="constant">Xs</span> <span class="constant">Ys</span>)</span><br><span class="line">      <span class="keyword">case</span> <span class="constant">Xs</span></span><br><span class="line">      of <span class="keyword">nil</span> <span class="keyword">then</span> <span class="constant">Ys</span>=<span class="keyword">nil</span></span><br><span class="line">      [] <span class="constant">P</span>|<span class="constant">Xr</span> <span class="keyword">then</span> <span class="constant">S</span> <span class="constant">L</span> <span class="keyword">in</span></span><br><span class="line">	 &#123;<span class="keyword">self</span> partition(<span class="constant">Xr</span> <span class="constant">P</span> <span class="constant">S</span> <span class="constant">L</span>)&#125;</span><br><span class="line">	 &#123;<span class="constant">Append</span> &#123;<span class="keyword">self</span> qsort(<span class="constant">S</span> <span class="variable">$)</span>&#125;</span><br><span class="line">	  <span class="constant">P</span>|&#123;<span class="keyword">self</span> qsort(<span class="constant">L</span> <span class="variable">$)</span>&#125; <span class="constant">Ys</span>&#125;</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   meth partition(<span class="constant">Xs</span> <span class="constant">P</span> <span class="constant">Ss</span> <span class="constant">Ls</span>)</span><br><span class="line">      <span class="keyword">case</span> <span class="constant">Xs</span></span><br><span class="line">      of <span class="keyword">nil</span> <span class="keyword">then</span> <span class="constant">Ss</span>=<span class="keyword">nil</span> <span class="constant">Ls</span>=<span class="keyword">nil</span></span><br><span class="line">      [] <span class="constant">X</span>|<span class="constant">Xr</span> <span class="keyword">then</span> <span class="constant">Sr</span> <span class="constant">Lr</span> <span class="keyword">in</span></span><br><span class="line">	 <span class="keyword">if</span> &#123;<span class="keyword">self</span> less(<span class="constant">X</span> <span class="constant">P</span> <span class="variable">$)</span>&#125; <span class="keyword">then</span></span><br><span class="line">	    <span class="constant">Ss</span>=<span class="constant">X</span>|<span class="constant">Xr</span> <span class="constant">Ls</span>=<span class="constant">Lr</span></span><br><span class="line">	 <span class="keyword">else</span></span><br><span class="line">	    <span class="constant">Ss</span>=<span class="constant">Sr</span> <span class="constant">Ls</span>=<span class="constant">X</span>|<span class="constant">Lr</span></span><br><span class="line">	 <span class="keyword">end</span></span><br><span class="line">	 &#123;<span class="keyword">self</span> partition(<span class="constant">Xr</span> <span class="constant">P</span> <span class="constant">Sr</span> <span class="constant">Lr</span>)&#125;</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>This block of codes define an abstract class <code>GenericSort</code> which remains the method <code>less</code> undefined for subclasses.</p>
<p>So we define this method is subclass <code>IntegerSort</code> and <code>RationalSort</code>.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">IntegerSort</span> from <span class="type">GenericSort</span></span><br><span class="line">   meth less<span class="container">(<span class="type">X</span> <span class="type">Y</span> <span class="type">B</span>)</span></span><br><span class="line">      <span class="type">B</span>=<span class="container">(<span class="type">X</span>&lt;<span class="type">Y</span>)</span></span><br><span class="line">   end</span><br><span class="line">end</span><br><span class="line"><span class="keyword">class</span> <span class="type">RationalSort</span> from <span class="type">GenericSort</span></span><br><span class="line">   meth less<span class="container">(<span class="type">X</span> <span class="type">Y</span> <span class="type">B</span>)</span></span><br><span class="line">      '/'<span class="container">(<span class="type">P</span> <span class="type">Q</span>)</span>=<span class="type">X</span></span><br><span class="line">      '/'<span class="container">(<span class="type">R</span> <span class="type">S</span>)</span>=<span class="type">Y</span></span><br><span class="line">   in <span class="type">B</span>=<span class="container">(<span class="type">P</span>*<span class="type">S</span>&lt;<span class="type">Q</span>*<span class="type">R</span>)</span> end</span><br><span class="line">end</span></span><br></pre></td></tr></table></figure>
<p>The abstraction is really powerful, we can subclass <code>GenericSort</code> and implement <code>less</code> method to sort any kinds of data we want.</p>
<p>But this is just a syntactic sugar for high-order programming.</p>
<h2 id="Using_Higher-order_Programming">Using Higher-order Programming</h2><p>There is a second natual way to create generic classes, namely by using higher-order programming directly. Now we can define a function which takes some arguments and returns a class that is specialized with these arguments.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">fun &#123;<span class="constant">MakeSort</span> <span class="constant">Less</span>&#125;</span><br><span class="line">   <span class="class"><span class="keyword">class</span> $</span></span><br><span class="line">      meth init skip <span class="keyword">end</span></span><br><span class="line">      meth qsort(<span class="constant">Xs</span> <span class="constant">Ys</span>)</span><br><span class="line">	 <span class="keyword">case</span> <span class="constant">Xs</span></span><br><span class="line">	 of <span class="keyword">nil</span> <span class="keyword">then</span> <span class="constant">Ys</span>=<span class="keyword">nil</span></span><br><span class="line">	 [] <span class="constant">P</span>|<span class="constant">Xr</span> <span class="keyword">then</span> <span class="constant">S</span> <span class="constant">L</span> <span class="keyword">in</span></span><br><span class="line">	    &#123;<span class="keyword">self</span> partition(<span class="constant">Xr</span> <span class="constant">P</span> <span class="constant">S</span> <span class="constant">L</span>)&#125;</span><br><span class="line">	    &#123;<span class="constant">Append</span> &#123;<span class="keyword">self</span> qsort(<span class="constant">S</span> <span class="variable">$)</span>&#125;</span><br><span class="line">	     <span class="constant">P</span>|&#123;<span class="keyword">self</span> qsort(<span class="constant">L</span> <span class="variable">$)</span>&#125; <span class="constant">Ys</span>&#125;</span><br><span class="line">	 <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      meth partition(<span class="constant">Xs</span> <span class="constant">P</span> <span class="constant">Ss</span> <span class="constant">Ls</span>)</span><br><span class="line">	 <span class="keyword">case</span> <span class="constant">Xs</span></span><br><span class="line">	 of <span class="keyword">nil</span> <span class="keyword">then</span> <span class="constant">Ss</span>=<span class="keyword">nil</span> <span class="constant">Ls</span>=<span class="keyword">nil</span></span><br><span class="line">	 [] <span class="constant">X</span>|<span class="constant">Xr</span> <span class="keyword">then</span> <span class="constant">Sr</span> <span class="constant">Lr</span> <span class="keyword">in</span></span><br><span class="line">	    <span class="keyword">if</span> &#123;<span class="constant">Less</span> <span class="constant">X</span> <span class="constant">P</span>&#125; <span class="keyword">then</span></span><br><span class="line">	       <span class="constant">Ss</span>=<span class="constant">X</span>|<span class="constant">Sr</span> <span class="constant">Ls</span>=<span class="constant">Lr</span></span><br><span class="line">	    <span class="keyword">else</span></span><br><span class="line">	       <span class="constant">Ss</span>=<span class="constant">Sr</span> <span class="constant">Ls</span>=<span class="constant">X</span>|<span class="constant">Lr</span></span><br><span class="line">	    <span class="keyword">end</span></span><br><span class="line">	    &#123;<span class="keyword">self</span> partition(<span class="constant">Xr</span> <span class="constant">P</span> <span class="constant">Sr</span> <span class="constant">Lr</span>)&#125;</span><br><span class="line">	 <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>The function <code>MakeSort</code> take an argument <code>Less</code> which compares two elements and returns a bool value. And the function returns a class, that can sort different kinds of element.</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">IntegerSort</span>=<span class="tuple">&#123;<span class="variable">MakeSort</span> <span class="keyword">fun</span> <span class="tuple">&#123;$ <span class="variable">X</span> <span class="variable">Y</span>&#125;</span> <span class="variable">X</span>&lt;<span class="variable">Y</span> <span class="keyword">end</span>&#125;</span></span><br><span class="line"><span class="variable">RationalSort</span>=<span class="tuple">&#123;<span class="variable">MakeSort</span> <span class="keyword">fun</span> <span class="tuple">&#123;$ <span class="variable">X</span> <span class="variable">Y</span>&#125;</span></span><br><span class="line">						'/'(<span class="variable">P</span> <span class="variable">Q</span>)=<span class="variable">X</span></span><br><span class="line">						'/'(<span class="variable">R</span> <span class="variable">S</span>)=<span class="variable">Y</span></span><br><span class="line">					   in <span class="variable">P</span>*<span class="variable">S</span>&lt;<span class="variable">Q</span>*<span class="variable">R</span> <span class="keyword">end</span>&#125;</span></span><br></pre></td></tr></table></figure>
<p>And then we can use these as this:</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ISort=<span class="list">&#123;New IntegerSort init&#125;</span></span><br><span class="line"><span class="list">&#123;Browse &#123;ISort qsort([1 2 4 5 6 3] $)&#125;</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Discussion">Discussion</h2><p>What is the different between the two techniques? </p>
<ul>
<li>In most programming languags, the inheritance must be defined at compile time. This gives static genericity. So the compiler can generate better code or do more checking.</li>
<li>High-order programming, when it is possible lets us define dynamic genericity which is much more flexible.</li>
</ul>
<h1 id="Mutiple_Inheritance">Mutiple Inheritance</h1><p>Mutiple inheritance is useful when an object has to be two different things in the same program.</p>
<h2 id="Rules_about_Mutiple_Inheritance">Rules about Mutiple Inheritance</h2><p>Mutiple inheritance is powerful technique that has to be used care.</p>
<ul>
<li>Mutiple inheritance works well when combing two <strong>completely independant abstraction</strong>.</li>
<li>Mutiple inheritance is much harder to use correctly when the abstraction has much in common, this always causes name label conflicts.</li>
</ul>
<p>See more in this post: <a href="http://deltax.me/2014/11/22/Multiple%20Inheritence/" target="_blank" rel="external">Mutiple Inheritance</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="How_to_use_Inheritance">How to use Inheritance</h1><p>There are two ways to view inheritance. </p>
<ul>
<li>The <strong>type</strong]]>
    </summary>
    
      <category term="CTMCP" scheme="http://deltax.me/tags/CTMCP/"/>
    
      <category term="OOP" scheme="http://deltax.me/tags/OOP/"/>
    
      <category term="Oz" scheme="http://deltax.me/tags/Oz/"/>
    
      <category term="Programming Paradigm" scheme="http://deltax.me/categories/Programming-Paradigm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo中LateX的使用]]></title>
    <link href="http://deltax.me/2015/03/25/Hexo%E4%B8%ADLateX%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://deltax.me/2015/03/25/Hexo中LateX的使用/</id>
    <published>2015-03-25T12:22:48.000Z</published>
    <updated>2015-03-25T12:45:14.000Z</updated>
    <content type="html"><![CDATA[<p>我使用 <code>Hexo</code> 已经有很长时间了, 最近升级到 3.0 问题实在是太多. 不过实在是不想在折腾回去了.</p>
<p>最近在学习算法导论, 需要解决很多的公式问题, 所以, 我求助于 <code>LaTeX</code>. <code>LaTeX</code> 是一种基于 <code>TEX</code> 的排版. 我们可以使用它来生成许多的数学公式. 我在这里就简单介绍一下如何使用好了.</p>
<h1 id="准备工作">准备工作</h1><p>如果你是用的 <code>Hexo</code> 主题是 <code>Jacman</code>, 那么非常简单, 你只需要在 <code>front-matter</code> 中添加:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mathjax:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>这样就可以在 markdown 中随意使用 <code>LaTeX</code> 了, 对于我来说, 我直接找到主题资源文件中与 MathJax 有关的代码</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">themes<span class="regexp">/jacman/</span>layout<span class="regexp">/_partial/m</span>athjax.ejs</span><br></pre></td></tr></table></figure>
<p>也就是这个文件, 删除掉第一行和最后一行, 也就是下面这两行.</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="preprocessor">%</span> <span class="keyword">if</span> <span class="comment">(theme.mathjax || page.mathjax)</span>&#123; <span class="preprocessor">%</span>&gt;</span><br><span class="line">&lt;<span class="preprocessor">%</span> &#125; <span class="preprocessor">%</span>&gt;</span><br></pre></td></tr></table></figure>
<p>然后, 你就不要在每次添加 <code>mathjax: true</code> 了, 你也可以去更改你的模板 <code>scaffolds/post.md</code> 在其中加入以下代码, 也可以省去每次添加的麻烦.</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mathjax:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h1 id="LaTeX使用">LaTeX使用</h1><p>做好了准备工作之后, 我们就可以尝试在 post 中添加 <code>LaTeX</code> 公式了, 你可以上网找一些在线的 editor 帮助你写 <code>LaTeX</code> 公式.</p>
<p>我们做几个简单的演示:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$T</span>(n) = \<span class="function"><span class="title">Theta</span><span class="params">(n)</span></span>$</span><br></pre></td></tr></table></figure>
<p>$T(n) = \Theta(n)$</p>
<p><code>LaTeX</code> 需要使用 <code>$</code> 符号进行包围, 当我最开始使用的时候不知道在公式的两边都要加入 <code>$</code> 符号, 所以出现了这样的错误</p>
<p>$T(n) = \Theta(n)</p>
<p><code>LaTeX</code> 公式不会被渲染, 使用单个的 <code>$</code> 符号时时候, 我们可以在行内中添加, 但是如果想在整行内使用, 我们使用双 <code>$</code> 符号, 也就是:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$<span class="variable">$T</span>(n) = \<span class="function"><span class="title">Theta</span><span class="params">(n)</span></span>$$</span><br></pre></td></tr></table></figure>
<p>$$T(n) = \Theta(n)$$</p>
<p>更多的使用方法以及文档可以访问 <a href="https://www.mathjax.org/" target="_blank" rel="external">MathJax</a>.</p>
<h1 id="LaTeX使用的问题">LaTeX使用的问题</h1><p>我在是用LaTeX的过程中遇到了这样一种问题, 当我使用下面这个公式的时候, <code>LaTeX</code> 公式不会被渲染.</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$<span class="label">$T</span>(<span class="keyword">n</span>) = \Theta(<span class="keyword">n</span>) + \sum_&#123;i=0&#125;^&#123;<span class="keyword">n</span>-1&#125;&#123;O(&#123;<span class="keyword">n</span>&#125;_&#123;i&#125;^2)&#125;$$</span><br></pre></td></tr></table></figure>
<p>$$T(n) = \Theta(n) + \sum<em>{i=0}^{n-1}{O({n}</em>{i}^2)}$$</p>
<p>我在官网上尝试了一下, 发现这个公式是完全正确的, 当时百思不得其解, 后来突然发现这个公式的中间部分 <code>{i=0}^{n-1}{O({n}</code> 竟然是倾斜的.</p>
<p>在 Markdown 中, <code>_ _</code> 表示的是中间部分的倾斜, 所以我就将这个公式改成了:</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$<span class="label">$T</span>(<span class="keyword">n</span>) = \Theta(<span class="keyword">n</span>) + \<span class="keyword">sum</span>\_&#123;i=0&#125;^&#123;<span class="keyword">n</span>-1&#125;&#123;O(&#123;<span class="keyword">n</span>&#125;\_&#123;i&#125;^2)&#125;$$</span><br></pre></td></tr></table></figure>
<p>加了两个用于转义的 <code>\</code> 符号, 这样, 公式就可以正确的显示了.</p>
<p>$$T(n) = \Theta(n) + \sum_{i=0}^{n-1}{O({n}_{i}^2)}$$</p>
<h1 id="结束">结束</h1><p>初次体验感觉 <code>LaTeX</code> 还是很强大的, 可以非常轻易的表示各种各样的数学公式, 不过遇到比较复杂的公式, 还是很难一次性完成的, 而且对于已经写好的 <code>LaTeX</code>, 有的实在太过于庞大并且复杂了, 完全无法理解到底是什么意思.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>我使用 <code>Hexo</code> 已经有很长时间了, 最近升级到 3.0 问题实在是太多. 不过实在是不想在折腾回去了.</p>
<p>最近在学习算法导论, 需要解决很多的公式问题, 所以, 我求助于 <code>LaTeX</code>. <code>LaTeX]]>
    </summary>
    
      <category term="Hexo" scheme="http://deltax.me/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[线性时间排序]]></title>
    <link href="http://deltax.me/2015/03/25/%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E6%8E%92%E5%BA%8F/"/>
    <id>http://deltax.me/2015/03/25/线性时间排序/</id>
    <published>2015-03-25T08:20:40.000Z</published>
    <updated>2015-03-25T12:22:06.000Z</updated>
    <content type="html"><![CDATA[<p>我们把在排序的最终结果中, 各元素的次序依赖于它们的比较的排序算法称为<strong>比较排序</strong>. 而我们在这里介绍的排序将不依赖于元素之间的比较.</p>
<p>第一次听到这种说法感觉非常的神奇和震惊, 而在以前的认识中, 排序都是基于比较的. 不经过比较怎么排序, 而这一章线性时间排序就改变了我过去对排序的浅显的认识.</p>
<h1 id="比较排序算法的下届">比较排序算法的下届</h1><p>我们如何才能使排序的时间复杂度达到线性呢, 能否通过元素之间的比较产生一种排序时间复杂度为线性的算法呢.</p>
<p>结论是: 不可能, 比较排序算法最坏情况下的时间复杂度的下届为 $\Theta\left(n\lg n\right)$. 这是为什么呢, 我们可以用<a href="http://zh.wikipedia.org/wiki/%E5%86%B3%E7%AD%96%E6%A0%91" target="_blank" rel="external">决策树</a>模型来证明下届的正确性.</p>
<p>考虑一棵高度为 $h$, 具有 $l$ 个可达的叶结点的决策树, 它对应一个对 $n$ 个元素所做的比较排序, 因为输入数据的 $n!$ 种可能的排列都是叶结点, 并且叶的数目不多于 ${2}^{n}$, 所以, 我们得到:</p>
<p>$$n! \leq l \leq {2}^{n}$$</p>
<p>对该式两边取对数:</p>
<p>$$\begin{align}<br>    h \geq \lg(n!) = \Omega(n\lg n)<br>   \end{align}$$</p>
<p>所以我们可以观察到堆排序和快速排序都是渐近最优的排序算法, 上届为 $O(n \lg n)$.</p>
<h1 id="计数排序(Counting-Sort)">计数排序(Counting-Sort)</h1><p><strong>计数排序</strong>假设 $n$ 个输入元素中的每一个都是在 $0$ 到 $k$ 区间的一个整数. 当 $k=O(n)$ 时, 排序的运行时间为 $\Theta(n)$.</p>
<p>计数排序的基本思想是, 对于每一个输入元素 $x$, 确定小于 $x$ 的元素个数 $n$, 然后把元素 $x$ 直接放到第 $n+1$ 的位置.</p>
<p>我们使用如下代码实现计数排序.</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> counting_sort(<span class="keyword">int</span> A[], <span class="keyword">int</span> B[], <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">int</span> C[k+<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        C[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">length</span>(A); j++) &#123; C[A[j]]++; &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123; C[i] += C[i-<span class="number">1</span>]; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="built_in">length</span>(A) - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">        B[C[A[j]]] = A[j];</span><br><span class="line">        C[A[j]]--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码中, <code>A[]</code> 为输入数组, <code>B[]</code> 为输出数组, <code>C[]</code>提供临时存储空间, 下面我们来分析这段代码.</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for <span class="comment">(int i = 0; i &lt;= k; i++)</span> &#123;</span><br><span class="line">    C[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码运行过后, 数组 <code>C[]</code> 中的所有元素都被初始化为 <code>0</code>, $T(n)=\Theta(k)$</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (int <span class="built_in">j</span> = <span class="number">0</span>; <span class="built_in">j</span> &lt; <span class="built_in">length</span>(A); <span class="built_in">j</span>++) <span class="cell">&#123; C[A[j]]++; &#125;</span></span><br></pre></td></tr></table></figure>
<p>循环的过程中, <code>A[]</code> 数组中的每一个元素都会使 <code>C[]</code> 数组中的对应元素 <code>+1</code>. 循环结束后, <code>C[]</code> 数组中的元素为, 对应索引出现在 <code>A[]</code> 数组中的次数, $T(n)=\Theta(n)$</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for <span class="comment">(int i = 1; i &lt;= k; i++)</span> &#123; C[i] += C[i<span class="number">-1</span>]; &#125;</span><br></pre></td></tr></table></figure>
<p>通过累加, 计算确定对每一个 $i=0, 1, …, k$, 有多少元素是小于或等于 $i$ 的, $T(n)=\Theta(k)$</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (int <span class="built_in">j</span> = <span class="built_in">length</span>(A) - <span class="number">1</span>; <span class="built_in">j</span> &gt;= <span class="number">0</span>; <span class="built_in">j</span>--) <span class="cell">&#123;</span><br><span class="line">    B[C[A[j]]] = A[j];</span><br><span class="line">    C[A[j]]--;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>最后这段代码把 <code>A[]</code> 中的元素, 通过 <code>C[]</code> 中的索引放到恰当的位置,, $T(n)=\Theta(n)$</p>
<p>所以总的时间代价就是 $T(n)=\Theta(n+k)$, 当 $k=O(n)$ 时, 我们一般会使用计数排序, 这样的运行时间为 $\Theta(n)$.</p>
<p>计数排序的另一个重要性质就是它是稳定的, 具有相同值的元素在输出数组中的相对顺序不变, 而这点的主要原因就是</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (int <span class="built_in">j</span> = <span class="built_in">length</span>(A) - <span class="number">1</span>; <span class="built_in">j</span> &gt;= <span class="number">0</span>; <span class="built_in">j</span>--)</span><br></pre></td></tr></table></figure>
<p>如果把这段代码换成</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (int <span class="built_in">j</span> = <span class="number">0</span>; <span class="built_in">j</span> &lt; <span class="built_in">length</span>(A); <span class="built_in">j</span>++)</span><br></pre></td></tr></table></figure>
<p>那么计数排序就是不稳定的.</p>
<h1 id="基数排序(Radix-Sort)">基数排序(Radix-Sort)</h1><p>我们了解了计数排序之后, 接下来介绍另一种排序方法, <strong>基数排序</strong>.</p>
<p>基数排序是将整数按位数切割成不同的数字, 然后按照每个位数进行比较.</p>
<p><img src="http://deltax.qiniudn.com/radix-sort.png?attname=&e=1427369778&token=YJb_IPQrTSw1ox9LenQDH1HRcgHii9w_bp9ddmcz:d-0v6wSh1j09MH_agrIH_Q0DrN0" style="display:block;margin:auto"></p>
<p>为了保证基数排序的准确性, <strong>一位数排序算法必须是稳定的</strong>.</p>
<p>基数排序的实现如下</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void<span class="function"> radix_sort(</span>int A<span class="keyword">[</span>],<span class="instruction"> int </span>d<span class="function">)</span> &#123;</span><br><span class="line">	for<span class="function"> (</span>int i = 0; i &lt; d; i++<span class="function">)</span> &#123;</span><br><span class="line">		Use a stable sort to sort<span class="instruction"> array </span>A on digit i</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用计数排序与基数排序结合, 那么就可以在 $\Theta(d(n+k))$ 时间内排好序.</p>
<h1 id="桶排序(Bucket-Sort)">桶排序(Bucket-Sort)</h1><p><strong>桶排序</strong>假设输入数据服从均匀分布, 平均情况下它的时间代价为 $O(n)$.</p>
<p><img src="http://deltax.qiniudn.com/bucket-sort.png?attname=&e=1427371034&token=YJb_IPQrTSw1ox9LenQDH1HRcgHii9w_bp9ddmcz:D0HE4QlDxJZ455IPQX7uhNNJ_aA" style="display:block;margin:auto"></p>
<p>假设输入数据分布在 $[0..1)$ 区间中, 我们需要一个临时数组 <code>B[0..n-1]</code> 来存放链表. 我们接下来将实现桶排序.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bucket_sort</span><span class="params">(<span class="keyword">int</span> A[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = length(A);</span><br><span class="line">    <span class="keyword">int</span> B[n];</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        B[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        append(B[<span class="keyword">int</span>(n * A[i])], A[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        insertion_sort(B[i]);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (B[i].head) &#123;</span><br><span class="line">            A[j] = B[i].head;</span><br><span class="line">            <span class="keyword">delete</span>(B[i]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为插入排序的时间代价是 $\Theta(n^2)$, 所以桶排序的时间代价为:</p>
<p>$$T(n) = \Theta(n) + \sum_{i=0}^{n-1}{O({n}_{i}^2)}$$</p>
<p>其中 ${n}_{i}$ 表示桶 <code>B[i]</code> 中元素个数的随机变量.</p>
<p>桶排序可以在线性时间内完成, 只要所有桶的大小平方和与总元素数呈线性关系.</p>
]]></content>
    <summary type="html">
    <![CDATA[我们把在排序的最终结果中, 各元素的次序依赖于它们的比较的排序算法称为比较排序. 而我们在这里介绍的排序将不依赖于元素之间的比较, 即线性时间排序.]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://deltax.me/tags/Algorithm/"/>
    
      <category term="clrs" scheme="http://deltax.me/categories/clrs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Inheritence in Object-Oriented-Programming]]></title>
    <link href="http://deltax.me/2015/03/24/Inheritence-in-Object-Oriented-Programming/"/>
    <id>http://deltax.me/2015/03/24/Inheritence-in-Object-Oriented-Programming/</id>
    <published>2015-03-24T01:07:46.000Z</published>
    <updated>2015-03-26T04:05:04.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Introduction">Introduction</h2><p>The main addition that <strong>OOP</strong> adds to component-based programming is inheritence. OOP allows defining a class incrementally by extending existing classes.</p>
<p>While using inheritence, it must be taken good care of. It may lost control if your application doesn’t use good design patterns.</p>
<h2 id="Inheritence_Graph">Inheritence Graph</h2><p>Inheritence is a way to construct new classes from existing classes. </p>
<ul>
<li>A method in <code>class C</code> overrrdes any method with the same label in all of <code>C</code>‘s superclass.</li>
<li>A class that inherits from exactly one class is said to use <strong>single inheritence</strong>. Inheritence from more than one class is called <strong>multiple inheritence</strong>.</li>
<li>A class hierarchy with the superclass relation can be seen as a directed graph with the current class being the root.</li>
<li>The inheritence is directed and acyclic, there cannot be any inherit cicle in the inheritence hierachy.</li>
<li>After striking out all overridden methods, each remaing method should have a unique label.</li>
</ul>
<p><img src="http://deltax.qiniudn.com/Class-Hierarchy.png?attname=&e=1427254344&token=YJb_IPQrTSw1ox9LenQDH1HRcgHii9w_bp9ddmcz:YuVSCsLdlEzG3RyHdiJQmj7fE2Y" style="display:block;margin:auto"></p>
<h2 id="Method_Access_Control">Method Access Control</h2><p>When executing inside an object, we often want to call another method in the same object, do a kind of recursive invocation. </p>
<p>We need two ways to do a recursive call. They are called static binding and dynamic binding.</p>
<p>Both of them are needed when using inheritence to override methods.</p>
<h3 id="Dynamic_Binding">Dynamic Binding</h3><p>Dynamic binding allows the new class to correctly extend the old class by letting old methods can new methods. Even the new method did not exist whtn the old method is defined. </p>
<p>This is written as <code>{self M}</code>. This chooses the method matching <code>M</code> that is visible in the current object.</p>
<h3 id="Static_Binding">Static Binding</h3><p>Static binding allows the new methods call the old methods when they have to.</p>
<p>This is written <code>C, M</code> (with a comma), where <code>C</code> is a class that defines a method matching <code>M</code>. This chooses the method matching <code>M</code> tgat us visible in class <code>C</code>.</p>
<h2 id="Encapsulation_Control">Encapsulation Control</h2><p>The principle of controlling encapsulation in an object-oriented language is to limit access to class members (attributes and methods) according to the requirements of the application architecure.</p>
<h3 id="Private_and_Public_Scopes">Private and Public Scopes</h3><p>The two most basic scopes are private and public.</p>
<ul>
<li>A private member is one which is only visible in the object instance. The object instance can see all members defined in its class and its superclasses.</li>
<li>A public member is one which is visible everywhere in the program.</li>
</ul>
<p>These definitions of private and public are natural if classes are used to construct data abstractions.</p>
<ol>
<li>A class is not the same thing as the data abstractions it defines. The class is increment.</li>
<li>Attributes are internal to the data abstraction and should be invisible from the outside. This is exactly the definition of private scope.</li>
<li>Methods are make up the external interface of the data abstraction, so they should be visible to all entities that reference the abstraction. This is exactly the definition of public scope.</li>
</ol>
<h3 id="Private_Methods">Private Methods</h3><p>When a method head is a name value, then its scope limited to all instances of the class, but not to the subclasses or their instances. These method is only visible inside the class definition. </p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> C</span><br><span class="line">	meth A(X)</span><br><span class="line">		% <span class="function"><span class="keyword">Method</span> <span class="title">body</span></span><br><span class="line">	<span class="title">end</span></span><br><span class="line"><span class="title">end</span></span></span><br></pre></td></tr></table></figure>
<p>And with <code>!</code> we can capture the method outside the scope.</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">local</span><br><span class="line">	A=<span class="comment">&#123;NewName&#125;</span></span><br><span class="line"><span class="keyword">in</span></span><br><span class="line">	<span class="keyword">class</span> C</span><br><span class="line">		meth !A(X)</span><br><span class="line">			% <span class="function"><span class="keyword">Method</span> <span class="title">body</span></span><br><span class="line">		<span class="title">end</span></span><br><span class="line">	<span class="title">end</span></span><br><span class="line"><span class="title">end</span></span></span><br></pre></td></tr></table></figure>
<p>This creates a name at class definition time.</p>
<h3 id="Protected_Methods">Protected Methods</h3><p>In <code>C++</code>,  method is protected if it is accessible only in the class it is defined or in descendant classes (and all instances of this classes).</p>
<h2 id="Forwarding_and_Delegation">Forwarding and Delegation</h2><p>Inheritence is one way to reuse functionality when defining new functionality. But it can be tricky to use, because it implies a tight binding between classes. </p>
<p>When developing a application, we want to decomposition different components, always inheritence is not a greate choice for this reason.</p>
<p>Sometimes we use looser approaches. Two such approaches are forwarding and delegation.</p>
<p><img src="http://deltax.qiniudn.com/Delegation-Forwarding.png?attname=&e=1427254344&token=YJb_IPQrTSw1ox9LenQDH1HRcgHii9w_bp9ddmcz:56KTT0g8JxSKHlqaNzvLtqiiXOs" style="display:block;margin:auto"></p>
<h3 id="Forwarding">Forwarding</h3><p>An object can forward any message to another object. In this system, we implement this strategy in <code>otherwise</code> method.</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">local</span></span><br><span class="line">	class ForwardMixin</span><br><span class="line">		attr Forward:<span class="constant">none</span></span><br><span class="line">		meth setForward(F) Forward:= F <span class="function"><span class="keyword">end</span></span></span><br><span class="line">		meth otherwise(M)</span><br><span class="line">			<span class="keyword">if</span> @Forward==<span class="constant">none</span> <span class="keyword">then</span> raise undefinedMethod <span class="function"><span class="keyword">end</span></span></span><br><span class="line">			<span class="keyword">else</span> &#123;@Forward M&#125; <span class="function"><span class="keyword">end</span></span></span><br><span class="line">		<span class="function"><span class="keyword">end</span></span></span><br><span class="line">	<span class="function"><span class="keyword">end</span></span></span><br><span class="line"><span class="operator">in</span></span><br><span class="line">	fun &#123;NewF Class Init&#125;</span><br><span class="line">		&#123;New class $ <span class="built_in">from</span> Class ForwardMixin <span class="function"><span class="keyword">end</span> <span class="title">Init</span>&#125;</span></span><br><span class="line">	<span class="function"><span class="keyword">end</span></span></span><br><span class="line"><span class="function"><span class="keyword">end</span></span></span><br></pre></td></tr></table></figure>
<p>Objects created with <code>NewF</code> have a method <code>setForward(F)</code> that lets them set dynamically the object to which the object will forward messages if they do not understand.</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class C1</span><br><span class="line">	meth init skip <span class="function"><span class="keyword">end</span></span></span><br><span class="line">	meth cube(A B) B=A*A*A <span class="function"><span class="keyword">end</span></span></span><br><span class="line"><span class="function"><span class="keyword">end</span></span></span><br><span class="line"></span><br><span class="line">class C2</span><br><span class="line">	meth init skip <span class="function"><span class="keyword">end</span></span></span><br><span class="line">	meth square(A B) B=A*A <span class="function"><span class="keyword">end</span></span></span><br><span class="line"><span class="function"><span class="keyword">end</span></span></span><br><span class="line">Obj1=&#123;NewF C1 init&#125;</span><br><span class="line">Obj2=&#123;NewF C2 init&#125;</span><br><span class="line">&#123;Obj2 setForward(Obj1)&#125;</span><br></pre></td></tr></table></figure>
<p>When <code>{Obj2 cube(10 X)}</code> is called, <code>Obj2</code> forward this message to <code>Obj1</code> and bind the result to <code>X</code>.</p>
<h3 id="Delegation">Delegation</h3><p>Delegation is powerful way to struture a system dynamically. <strong>It lets us build a hierachy among objects instead of among classes</strong>.</p>
<p>Delegation can achieve the same effects as inheritence, with two main differences, but with objects instead of classes, and can be changed at any time.</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">local</span></span><br><span class="line">	SetSelf=&#123;NewName&#125;</span><br><span class="line">	class DelegateMixin</span><br><span class="line">		attr this Delegate:<span class="constant">none</span></span><br><span class="line">		meth !SetSelf(S) this:=S <span class="function"><span class="keyword">end</span></span></span><br><span class="line">		meth <span class="built_in">set</span>(A X) A:=X <span class="function"><span class="keyword">end</span></span></span><br><span class="line">		meth <span class="built_in">get</span>(X ?X) X=@A <span class="function"><span class="keyword">end</span></span></span><br><span class="line">		meth setDelegate(D) Delegate:=D End</span><br><span class="line">		meth Del(M S) SS <span class="operator">in</span></span><br><span class="line">			SS:=this this:=S</span><br><span class="line">			<span class="keyword">try</span> &#123;self M&#125; <span class="keyword">finally</span> this:=SS <span class="function"><span class="keyword">end</span></span></span><br><span class="line">		<span class="function"><span class="keyword">end</span></span></span><br><span class="line">		meth call(M) SS <span class="operator">in</span></span><br><span class="line">			SS:=this this:=self</span><br><span class="line">			<span class="keyword">try</span> &#123;self M&#125; <span class="keyword">finally</span> this:=SS <span class="function"><span class="keyword">end</span></span></span><br><span class="line">		<span class="function"><span class="keyword">end</span></span></span><br><span class="line">		meth otherwise(M)</span><br><span class="line">			<span class="keyword">if</span> @Delegate==<span class="constant">none</span> <span class="keyword">then</span></span><br><span class="line">				raise undefinedMethod <span class="function"><span class="keyword">end</span></span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				&#123;@Delegate Del(M @this)&#125;</span><br><span class="line">			<span class="function"><span class="keyword">end</span></span></span><br><span class="line">		<span class="function"><span class="keyword">end</span></span></span><br><span class="line">	<span class="function"><span class="keyword">end</span></span></span><br><span class="line"><span class="operator">in</span></span><br><span class="line">	fun &#123;NewD Class Init&#125;</span><br><span class="line">		Obj=&#123;New class $ <span class="built_in">from</span> Class DelegateMixin <span class="function"><span class="keyword">end</span> <span class="title">Init</span>&#125;</span></span><br><span class="line">	<span class="operator">in</span></span><br><span class="line">		&#123;Obj SetSelf(Obj)&#125;</span><br><span class="line">		Obj</span><br><span class="line">	<span class="function"><span class="keyword">end</span></span></span><br><span class="line"><span class="function"><span class="keyword">end</span></span></span><br></pre></td></tr></table></figure>
<p>If there are two objects <code>Obj1</code> and <code>Obj2</code>, suppose there exists a method <code>setDelegate</code> such that <code>{Obj2 setDelegate(Obj1)}</code> sets <code>Obj2</code> to delegate to <code>Obj1</code>. And <code>Obj1</code> behaves like <code>Obj2</code>‘s superclass.</p>
<p>When we enter the <code>Del</code> method, we should preserve our <code>this</code> value in a temp variable. Because the <code>{Self M}</code> should executes in the <code>Obj1</code> context and change <code>Obj1</code> attributes.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span></span></span><br><span class="line">   attr <span class="symbol">i:</span><span class="number">0</span></span><br><span class="line">   meth init skip <span class="keyword">end</span></span><br><span class="line">   meth inc(<span class="constant">I</span>)</span><br><span class="line">      &#123;<span class="variable">@this</span> set(i &#123;<span class="variable">@this</span> get(i <span class="variable">$)</span>&#125;+<span class="constant">I</span>)&#125;</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   meth browse</span><br><span class="line">      &#123;<span class="variable">@this</span> inc(<span class="number">10</span>)&#125;</span><br><span class="line">      &#123;<span class="constant">Browse</span> c1<span class="comment">#&#123;<span class="yardoctag">@this</span> get(i $)&#125;&#125;</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   meth c &#123;<span class="variable">@this</span> browse&#125; <span class="keyword">end</span> <span class="keyword">end</span></span><br><span class="line"><span class="constant">Obj1</span>=&#123;<span class="constant">NewD</span> <span class="constant">C1</span> init&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C2</span></span></span><br><span class="line">   attr <span class="symbol">i:</span><span class="number">0</span></span><br><span class="line">   meth init skip <span class="keyword">end</span></span><br><span class="line">   meth browse</span><br><span class="line">      &#123;<span class="variable">@this</span> inc(<span class="number">100</span>)&#125;</span><br><span class="line">      &#123;<span class="constant">Browse</span> c2<span class="comment">#&#123;<span class="yardoctag">@this</span> get(i $)&#125;&#125;</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="constant">Obj2</span>=&#123;<span class="constant">NewD</span> <span class="constant">C2</span> init&#125;</span><br><span class="line">&#123;<span class="constant">Obj2</span> setDelegate(<span class="constant">Obj1</span>)&#125;</span><br></pre></td></tr></table></figure>
<p>If we execute</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;Obj<span class="number">1</span> <span class="keyword">call</span><span class="comment">(browse)</span>&#125;</span><br><span class="line">&#123;Obj<span class="number">2</span> <span class="keyword">call</span><span class="comment">(browse)</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">%</span> c<span class="number">1</span><span class="title">#10</span> c<span class="number">2</span><span class="title">#100</span></span><br></pre></td></tr></table></figure>
<p>But if we change the <code>Del</code> procedure like this:</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">meth <span class="constant">Del(M S)</span> <span class="keyword">in</span></span><br><span class="line">	&#123;<span class="keyword">self</span> <span class="constant">M&#125;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>The previous execution will browse</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c1<span class="hexcolor">#100</span> c2#<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>Because the <code>Obj1</code> does not preserve its attributes, <code>this</code> in <code>{self M}</code> means <code>Obj1</code> instead of <code>Obj2</code>. This make no sense, delegation indeed is design pattern that let other handle the message and deal with own attributes. If we do not save the context in <code>Del</code>, it just like send message to <code>Obj2</code>.</p>
<h2 id="Reflection">Reflection</h2><p>A system is reflection if it can inspect part of its execution while running.</p>
<p>Reflection can be purely introspective or intrusive.</p>
<ul>
<li>Purely Introspective<ul>
<li>Only reading the internal state without modifying it.</li>
</ul>
</li>
<li>Instrutive<ul>
<li>Both reading and modifying the internal state.</li>
</ul>
</li>
</ul>
<h3 id="Meta-Object_Protocols">Meta-Object Protocols</h3><p>The description of how an object system works at a basic level is called meta-object protocol. The ability to change the meta-object protocol is a powerful way to modify an obejct system. It is used for many purposes: debugging, customzing, and separation of concerns.</p>
<h3 id="Methig_Wrapping">Methig Wrapping</h3><p>A common use of meta-object protocol is to do method wrapping. We can write a tracer to track the behavior of an object-oriented program.</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun &#123;<span class="type">TraceNew</span> <span class="type">Class</span> <span class="type">Init</span>&#125;</span><br><span class="line">	<span class="type">Obj</span>=&#123;<span class="type">New</span> <span class="type">Class</span> <span class="type">Init</span>&#125;</span><br><span class="line">	<span class="keyword">proc</span> &#123;<span class="type">TraceObj</span> M&#125;</span><br><span class="line">		&#123;<span class="type">Browse</span> entering(&#123;<span class="type">Label</span> M)&#125;</span><br><span class="line">		&#123;<span class="type">Obj</span> M&#125;</span><br><span class="line">		&#123;<span class="type">Browse</span> exiting(&#123;<span class="type">Label</span> M)&#125;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">in</span> <span class="type">TraceObj</span> <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>If an object is created with this procedure, every method will be traced.</p>
<p>A second way is to implement this with a class instead of a procedure.</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fun &#123;TraceNew2 <span class="class"><span class="keyword">Class</span> <span class="title">Init</span>&#125;</span></span><br><span class="line">   Obj=&#123;<span class="keyword">New</span> <span class="class"><span class="keyword">Class</span> <span class="title">Init</span>&#125;</span></span><br><span class="line">   TInit=&#123;NewName&#125;</span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Tracer</span></span></span><br><span class="line">      meth !TInit skip <span class="keyword">end</span></span><br><span class="line">      meth otherwise(M)</span><br><span class="line">	 &#123;Browse entering(&#123;Label M&#125;)&#125; &#123;Obj M&#125;</span><br><span class="line">	 &#123;Browse exiting(&#123;Label M&#125;)&#125;</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">in &#123;<span class="keyword">New</span> Tracer TInit&#125; <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>This strategy is used dynamic class creation, the <code>otherwise</code> method and a freshname <code>TInit</code>.</p>
<h3 id="Reflection_of_object_state">Reflection of object state</h3><p>We would like to ba able to read and write the whole state of an object, independant of the object’s class.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Introduction">Introduction</h2><p>The main addition that <strong>OOP</strong> adds to component-based programming is inheritence. OO]]>
    </summary>
    
      <category term="CTMCP" scheme="http://deltax.me/tags/CTMCP/"/>
    
      <category term="OOP" scheme="http://deltax.me/tags/OOP/"/>
    
      <category term="Oz" scheme="http://deltax.me/tags/Oz/"/>
    
      <category term="Programming Paradigm" scheme="http://deltax.me/categories/Programming-Paradigm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Class as Data Abstraction in OOP]]></title>
    <link href="http://deltax.me/2015/03/23/Class-as-Data-Abstraction-in-OOP/"/>
    <id>http://deltax.me/2015/03/23/Class-as-Data-Abstraction-in-OOP/</id>
    <published>2015-03-23T02:28:07.000Z</published>
    <updated>2015-03-24T17:17:32.000Z</updated>
    <content type="html"><![CDATA[<p>The heart of the object concept is controlled access to encapsulated data. The behaviour of an object is specified by a <strong>class</strong> which is an incremental definition of a data abstraction.</p>
<ul>
<li>Complete data abstraction<ul>
<li>Defining the various elements that make up a class.</li>
<li>Taking advantage of dynamic typing.</li>
</ul>
</li>
<li>Incremental data abstraction<ul>
<li>Related to inheritance.</li>
</ul>
</li>
</ul>
<h2 id="Defining_Classes_and_Objects">Defining Classes and Objects</h2><p>A class is data structure that defines an object’s internal state (attributes), its behavior (methods), the classes it inherits several properties and operations.</p>
<p>A class is a data abstraction that give its partial and total implementation.</p>
<p>Objects of a given class is called <strong>instances</strong>. These object have differenty identities but can have differnet values for their interval state. And instance is initialized with the operation <code>New</code>.<br><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Obj=&#123;<span class="keyword">New</span> <span class="class"><span class="keyword">Class</span> <span class="title">Init</span>&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>This code creates an new object <code>Obj</code> of class <code>Class</code> and invokes with the message <code>Init</code>. And after the initialize, we can use the syntax <code>{Obj Message}</code> to call a message on instance <code>Obj</code>.</p>
<h2 id="Class_members">Class members</h2><p>A class defines the constituent parts part each of its object will have. There are three kinds of members in class:</p>
<ul>
<li><strong>Attributes</strong><blockquote>
<p>An attribute is a cell that contains part of the instance’s state which is always called <strong>instance variable</strong> in an instance. And this just visible in the class definition. Every instance have seperate set of attributes.</p>
</blockquote>
</li>
<li><p><strong>Methods</strong></p>
<blockquote>
<p>A method is a kind of procedure that is called in the context of a particular object and that access the object’s attribute. </p>
</blockquote>
<ul>
<li>The method consists of a head and body. </li>
<li>The head consists of a label, which must be an atom or a name, and a set of arguments.</li>
<li>The arguments must be distinct variables.</li>
</ul>
</li>
<li><strong>Properties</strong><blockquote>
<p>A property modifies how an object behaves.</p>
</blockquote>
</li>
</ul>
<h2 id="Initializing_Attributes">Initializing Attributes</h2><p>Attributes can be initialized in two ways: per instance or per class.</p>
<ul>
<li><p>Per instance</p>
<ul>
<li><p>An attribute can be given a different initial value per instance.</p>
  <figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OneApt</span></span></span><br><span class="line">	attr streetName</span><br><span class="line">	meth init(X) @streetName=X <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">Apt1=&#123;<span class="keyword">New</span> OneApt init(drottninggatan)&#125;</span><br><span class="line">Apt2=&#123;<span class="keyword">New</span> OneApt init(runNeuve)&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>Per class</p>
<ul>
<li><p>An attribute can be given a value that is the same for all instances of a class. This is done by initilizing it with “:” in the class definition.</p>
  <figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YorkApt</span></span></span><br><span class="line">	attr</span><br><span class="line">		streetName:york</span><br><span class="line">		streetNumber:<span class="number">100</span></span><br><span class="line">		wallColor:_</span><br><span class="line">		floorSurface:wood</span><br><span class="line">	meth init skip <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">Apt3=&#123;<span class="keyword">New</span> OneApt init&#125;</span><br><span class="line">Apt4=&#123;<span class="keyword">New</span> OneApt init&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Per brand</p>
<ul>
<li><p>This is another way to use the per-class initialization. A brand is a set of classes that related in some way.</p>
  <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">L</span>=linux</span><br><span class="line"><span class="keyword">class</span> RedHat attr ostype:<span class="keyword">L</span> end</span><br><span class="line"><span class="keyword">class</span> SuSE attr ostype:<span class="keyword">L</span> end</span><br><span class="line"><span class="keyword">class</span> Debian attr ostype:<span class="keyword">L</span> end</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="First-class_Messages">First-class Messages</h2><p>Messages are records and method heads are patterns that match a record. We can use different type of records to pass to a method.</p>
<ol>
<li>Static record as message. In this case, message is known at <strong>compile time</strong>.</li>
<li>Dynamic record as message. In this case, message is a variable that references a record that calculated at <strong>run time</strong>.</li>
</ol>
<p>In the method definition, the following approach is possible:</p>
<ol>
<li><p>Fixed argument list</p>
 <figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">meth <span class="keyword">add</span>(x:X y:Y)</span><br><span class="line">	% <span class="function"><span class="keyword">Method</span> <span class="title">body</span></span><br><span class="line"><span class="title">end</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Flexible argument list</p>
 <figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">meth <span class="keyword">add</span>(x:X y:Y ...)</span><br><span class="line">	% <span class="function"><span class="keyword">Method</span> <span class="title">body</span></span><br><span class="line"><span class="title">end</span></span></span><br></pre></td></tr></table></figure>
<p> The “…” in the method head means that any message is accepted if has least the listed argument.</p>
</li>
<li><p>Variable reference to method head</p>
<p> The whole method head is referenced by a variable.</p>
 <figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">meth <span class="keyword">add</span>(x:X y:Y ...)=M</span><br><span class="line">	% <span class="function"><span class="keyword">Method</span> <span class="title">body</span></span><br><span class="line"><span class="title">end</span></span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>The variable <code>M</code> references the full message as a record.</p>
<ol>
<li><p>Optional argument</p>
 <figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">meth <span class="keyword">add</span>(x:X y:Y z:Z&lt;=V)</span><br><span class="line">	% <span class="function"><span class="keyword">Method</span> <span class="title">body</span></span><br><span class="line"><span class="title">end</span></span></span><br></pre></td></tr></table></figure>
<p> The <code>&lt;=V</code> in the method head means that field <code>z</code> is optional. You can either called the method with <code>add(x:1 y:2)</code> or <code>add(x:1 y:2 z:3)</code>.</p>
</li>
<li><p>Private method label</p>
<p> Method label can be names. This is denoted by using a variable identifier</p>
 <figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">meth A(bar:X)</span><br><span class="line">	% <span class="function"><span class="keyword">Method</span> <span class="title">body</span></span><br><span class="line"><span class="title">end</span></span></span><br></pre></td></tr></table></figure>
<p> The method <code>A</code> is bound to a fresh name whtn the class is defined. If this method must be used elsewhere in the program, we should pass it explicitly.</p>
</li>
<li><p>Dynamic method label</p>
 <figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">meth !A(bar:X)</span><br><span class="line">	% <span class="function"><span class="keyword">Method</span> <span class="title">body</span></span><br><span class="line"><span class="title">end</span></span></span><br></pre></td></tr></table></figure>
<p> The method label has to be known when the class definitions is executed. The variable must be bound to an atom or a name. This technique can make method secure.</p>
</li>
<li><p>The <code>otherwise</code> method</p>
<p> The method head with label <code>otherwise</code> is a catchall that accepts any message for message for which no other method exists.</p>
 <figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">meth otherwise(M)</span><br><span class="line">	% <span class="function"><span class="keyword">Method</span> <span class="title">body</span></span><br><span class="line"><span class="title">end</span></span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>A class has only one method with <code>otherwise</code>, if this method exists, it accepts any message.</p>
<h2 id="First-class_Attributes">First-class Attributes</h2><p>Attribute names can be calculated at tun time. It is possible to write methods to access and assign any attributes.</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Inspector</span><br><span class="line">	meth <span class="built_in">get</span>(A ?X)</span><br><span class="line">		X=@A</span><br><span class="line">	<span class="function"><span class="keyword">end</span></span></span><br><span class="line">	meth <span class="built_in">set</span>(A X)</span><br><span class="line">		A:=X</span><br><span class="line">	<span class="function"><span class="keyword">end</span></span></span><br><span class="line"><span class="function"><span class="keyword">end</span></span></span><br></pre></td></tr></table></figure>
<p>The <code>get</code> method can get any attribute, and the <code>set</code> method can assign any attribute.</p>
<h2 id="Programming_Techniques">Programming Techniques</h2><p>The class concept we have introduced so far gives a convenient syntax for defining data abstractions with excapsulated state and multiple operations.</p>
<ul>
<li>The class statement defines a class value, which can be instantiated to give objects.</li>
<li>Classes can have external references.</li>
<li>Classes are cmpositional, they can be nested within classes.</li>
<li>Classes are compatible with procedure values, they can be nested within procedures and vice versa.</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>The heart of the object concept is controlled access to encapsulated data. The behaviour of an object is specified by a <strong>class</st]]>
    </summary>
    
      <category term="CTMCP" scheme="http://deltax.me/tags/CTMCP/"/>
    
      <category term="OOP" scheme="http://deltax.me/tags/OOP/"/>
    
      <category term="Oz" scheme="http://deltax.me/tags/Oz/"/>
    
      <category term="Programming Paradigm" scheme="http://deltax.me/categories/Programming-Paradigm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[快速排序]]></title>
    <link href="http://deltax.me/2015/03/22/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://deltax.me/2015/03/22/快速排序/</id>
    <published>2015-03-22T05:06:38.000Z</published>
    <updated>2015-04-04T08:57:10.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F" target="_blank" rel="external">快速排序</a>使用分治法策略把一个数组分成两个子数组, 并对两个子数组递归排序.</p>
<p>快速排序的分治过程有三步:</p>
<ul>
<li>分解<ul>
<li>数组 <code>A[p..r]</code> 被分解为两个可能为空的子数组 <code>A[p..q-1]</code> 和 <code>A[q+1..r]</code>, 使 <code>A[p..q-1]</code> 中的所有元素都小于或等于 <code>A[q]</code>, <code>A[q+1..r]</code> 中的所有元素都大于或等于 <code>A[q]</code>.</li>
</ul>
</li>
<li>解决<ul>
<li>地柜地调用快速排序, 对子数组 <code>A[p..q-1]</code> 和 <code>A[q+1..r]</code> 进行排序.</li>
</ul>
</li>
<li>合并<ul>
<li>不需要合并操作, 数组 <code>A[p..r]</code> 已经有序.</li>
</ul>
</li>
</ul>
<h2 id="快速排序的实现">快速排序的实现</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p &lt; r - <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> q = partition(A, p, r);</span><br><span class="line">		quicksort(A, p, q - <span class="number">1</span>);</span><br><span class="line">		quicksort(A, q + <span class="number">1</span>, r);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了排序一个数组, 我们需要调用 `quicksort(A, 0, A.length - 1)</p>
<h2 id="数组的划分(partition)">数组的划分(partition)</h2><p>快速排序最关键的部分就是数组的划分, 也就是过程 <code>partition</code>, 它实现了对数组的重新排序.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define EXCHANGE(a, b) tmp = a; a = b; b = tmp;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> partition(<span class="keyword">int</span> A[], <span class="keyword">int</span> p, <span class="keyword">int</span> r) &#123;</span><br><span class="line">	<span class="keyword">int</span> <span class="keyword">x</span> = A[r],</span><br><span class="line">		 i = p - <span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = p; j &lt; r; j++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (A[j] &lt;= <span class="keyword">x</span>) &#123;</span><br><span class="line">			i++;</span><br><span class="line">			EXCHANGE(A[i], A[j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	EXCHANGE(A[r], A[i + <span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每一轮迭代开始时, 对于任意数组下标 <code>k</code>, 有:</p>
<ol>
<li><code>p &lt;= k &lt;= i, A[k] &lt;= x</code></li>
<li><code>i + 1 &lt;= k &lt;= j - 1, A[k] &gt; x</code></li>
<li><code>k = r, A[k] = x</code></li>
</ol>
<h2 id="性能">性能</h2><p>快速排序的性能依赖于数组是否被平衡的划分, 如果平衡, 那么快速排序的划分是<strong>平衡</strong>的. 那么快速排序的性能与归并排序相同, 否则, 划分是<strong>不平衡</strong>的, 快速排序的性能就接近于插入排序.</p>
<h3 id="最坏情况下的性能">最坏情况下的性能</h3><p>当快速排序在最坏情况下时, 我们获得一个递归式:</p>
<blockquote>
<p>T(n) = T(n-1) + Θ(n)</p>
</blockquote>
<p>得到最坏情况下的时间复杂度仍然为 <code>Θ(n^2)</code>, 而插入排序在最坏情况下时间复杂度也为 <code>Θ(n^2)</code>, 而在几乎有序的情况下快速排序的时间复杂度也为 <code>Θ(n^2)</code>, 插入排序则为 <code>Θ(n)</code>.</p>
<h3 id="最好情况下性能">最好情况下性能</h3><p>在最好的情况下, 每次划分都是平均的, 递归式为:</p>
<blockquote>
<p>T(n) = 2T(n/2) + Θ(n)</p>
</blockquote>
<p>最好的情况下的时间复杂度为 <code>Θ(nlgn)</code>, 我们得到了一个渐进时间最快的算法.</p>
<h3 id="平衡的划分">平衡的划分</h3><p>假设划分算法总是产生 9:1 的划分, 那么递归式为:</p>
<blockquote>
<p> T(n) = T(n/10) + T(9n/10) + cn</p>
</blockquote>
<p>我们在这里求得快速排序的总时间代价依然为 <code>Ο(nlgn)</code>, 由此可以发现, 任何一种<strong>常数</strong>比例的划分都会产生时间复杂度为 <code>Ο(nlgn)</code> 的算法.</p>
<h3 id="随机版本的快速排序">随机版本的快速排序</h3><p>因为快速排序的时间复杂度取决于数组的划分, 有时, 我们希望引入随机性来改善算法的性能. 在这里我们可以采用一种随机抽样的方式选择数组的主元, 达到随机的目的.</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">randomized_partition</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = i = rand() % (r - p) + p;</span><br><span class="line">	EXCHANGE(A[r], A[i])	;</span><br><span class="line">	<span class="function"><span class="keyword">return</span> <span class="title">partition</span><span class="params">(A, p, r)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">randomized_quicksort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p &lt; r - <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> q = randomized_partition(A, p, r);</span><br><span class="line">		randomized_quicksort(A, p, q - <span class="number">1</span>);</span><br><span class="line">		randomized_quicksort(A, q + <span class="number">1</span>, r);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们只需要在调用 <code>partition</code> 之前随机选择一个 pivot 然后与 <code>A[r]</code> 交换即可.</p>
<h3 id="Hoare版本的快速排序">Hoare版本的快速排序</h3><p>我们在之前使用的 <code>partition</code> 并不是快速排序算法最初的版本, 下面给出的是快速排序最初的版本.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hoare_partition</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = A[p],</span><br><span class="line">		 i = p - <span class="number">1</span>,</span><br><span class="line">		 j = r + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">		<span class="keyword">do</span> &#123; j--; &#125; <span class="keyword">while</span> (!(A[i] &lt;= x));</span><br><span class="line">		<span class="keyword">do</span> &#123; i++; &#125; <span class="keyword">while</span> (!(A[j] &gt;= x));</span><br><span class="line">		<span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">			EXCHANGE(A[i], A[j]);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> k;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hoare_quicksort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p &lt; r - <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> q = hoare_partition(A, p, r);</span><br><span class="line">		hoare_quicksort(A, p, q - <span class="number">1</span>);</span><br><span class="line">		hoare_quicksort(A, q + <span class="number">1</span>, r);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="针对相同元素的快速排序">针对相同元素的快速排序</h3><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">&#125; pivot_t;</span><br><span class="line"></span><br><span class="line">pivot_t partition(<span class="type">int</span> A[], <span class="type">int</span> p, <span class="type">int</span> r) &#123;</span><br><span class="line">    <span class="type">int</span> x = A[r - <span class="number">1</span>],</span><br><span class="line">        q = p,</span><br><span class="line">        t,</span><br><span class="line">        tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = p; i &lt; r - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] &lt; x) &#123;</span><br><span class="line">            <span class="type">EXCHANGE</span>(A[q], A[i]);</span><br><span class="line">            q++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (t = q; t &lt; r &amp;&amp; A[t] == x; t++);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = r - <span class="number">1</span>; i &gt;= t; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] == x) &#123;</span><br><span class="line">            <span class="type">EXCHANGE</span>(A[t], A[i]);</span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pivot_t <span class="literal">result</span> = &#123;q, t&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>partition</code> 过程在这一版本中, 返回 <code>q</code> 和 <code>t</code>, 使得 </p>
<ul>
<li><code>A[p..q-1]</code> 中的每个元素都小于 <code>A[q]</code>.</li>
<li><code>A[q..t]</code> 中的每个元素都等于 <code>A[q]</code>.</li>
<li><code>A[t+1..r]</code> 中的每个元素都大于 <code>A[q]</code>.</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F" target="_blank" rel="external">快速排序</a>使用分治法策略把一个数组分成两个子数组, 并]]>
    </summary>
    
      <category term="Algorithm" scheme="http://deltax.me/tags/Algorithm/"/>
    
      <category term="clrs" scheme="http://deltax.me/categories/clrs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Stateful Collections]]></title>
    <link href="http://deltax.me/2015/03/20/Stateful-Collections/"/>
    <id>http://deltax.me/2015/03/20/Stateful-Collections/</id>
    <published>2015-03-20T15:51:23.000Z</published>
    <updated>2015-03-24T17:39:45.000Z</updated>
    <content type="html"><![CDATA[<p>There are different kinds of collection depending on what operations are provided. We discuss in two axises about collections.</p>
<ol>
<li>Indexed collections and unindexed collections, depending on whether or not thereis rapid access to individual elements.</li>
<li>Extensible or inextensible collections, depending on whether the number of elements is variable or fixed.</li>
</ol>
<h2 id="Indexed_Collections">Indexed Collections</h2><p>The stateful versions of <strong>tuples</strong> and <strong>records</strong> are <strong>arrays</strong> and <strong>dictionaries</strong>. And now, we have four different kinds of indexed collections.</p>
<p><img src="http://deltax.qiniudn.com/Stateful%20Collections1.png?attname=&amp;e=1426994526&amp;token=YJb_IPQrTSw1ox9LenQDH1HRcgHii9w_bp9ddmcz:UnC-uFe4--jbxOxg76kR83rvZB4" alt="Indexes Collections"></p>
<h3 id="Arrays">Arrays</h3><p>An array is a mapping from integers to partial values. </p>
<ul>
<li>The domain is a set of consecutive integers from lower bound to an upper bound.</li>
<li>The domain is givenwhen the array is declared and cannot be changed afterward.</li>
<li>The range of the mapping can be changed.</li>
<li>Both accessing and changing an array element are done in constant time.</li>
</ul>
<p>There is a strong relationship between tuples and arrays, each of them are mapping from integers to partial values. <strong>But tuples are stateless and arrays are stateful.</strong> And the content of arrays can be changed but tuples can not.</p>
<h3 id="Dictionaries">Dictionaries</h3><p>A dictionary is a mapping from simple constants to partial values. </p>
<ul>
<li>Both the domain and the range of the range of mapping can be changes.</li>
<li>Accessing and changing are done in constant time and adding/removal are done in amortized constant time.</li>
<li>There are no limits to the number of fields in the mapping.</li>
</ul>
<p>There is a close relationship between records and dictionaries. Each of them maps simple contants to partial values. <strong>But records and stateless and dictionaries and stateful.</strong> A records has a fixed set of field but dictionary not.</p>
<h3 id="Choosing_Indexed_Collections">Choosing Indexed Collections</h3><p>The different has different trade-offs in possible operations, memory use, and execution time.</p>
<p>Let us compare the four collections mention above:</p>
<ul>
<li>Tuples<ul>
<li>Most restrictive</li>
<li>Fastest</li>
<li>Require less memory</li>
<li>Stored consecutively</li>
<li>Indexed by number</li>
</ul>
</li>
<li>Records<ul>
<li>More flexible then tuples</li>
<li>Indecies can te literal</li>
<li>Efficient</li>
<li>Stored consecutively</li>
</ul>
</li>
<li>Arrays<ul>
<li>Field can be changed</li>
<li>Bounds can not be changes</li>
<li>Stored consecutively</li>
<li>Efficient</li>
<li>Indexed by number</li>
</ul>
</li>
<li>Dictionaries<ul>
<li>Most general</li>
<li>Indecies can te literal</li>
<li>Created empty</li>
<li>Efficient</li>
<li>More memory and alower access (by a constant factor)</li>
</ul>
</li>
</ul>
<p>We can choose the proper collection type when we use.</p>
<h2 id="Unindexed_Collections">Unindexed Collections</h2><p>Indexed collection are not always the best choice. Sometimes it is better to use unindexed collections, such as lists and streams.</p>
<p>Both of them are declrative data types that collect elements in a linear sqeuence can be traversed from front to back. Any number of traversals can beb done simulataneously on the same list or stream.</p>
<h3 id="Lists">Lists</h3><p>Lists are of finite, fixed length. They are one of the most important data struture in functional programming language. It is really an elegant data struture. And we use <code>map</code> <code>filter</code> <code>fold</code> and many powerful operation to deal with it.</p>
<h3 id="Streams">Streams</h3><p>Streams are also called incomplete lists or partial lists. Their tail are unbound variables. </p>
<ul>
<li>Stream is one of the most efficient extensible collections.</li>
<li>Stream is useful for representing orered sequences of message.</li>
</ul>
<h2 id="Extensible_Collections">Extensible Collections</h2><p>Final, I will introduce some extensible collections, streams, dictionaries and extensible arrays.</p>
<h3 id="Extensible_Arrays">Extensible Arrays</h3><p>As we mentioned above, array is a bounded data structure. How do extensible array work? </p>
<ul>
<li>When the array is full, we create a new array with double size of the older one. And copy all the elements from old one to new one. </li>
<li>When the array is quarter full, we create a new array with half size of the older one. And copy the elements.</li>
</ul>
<p>This data structure take constant time to the cost of resize operation. The most important thing is to ensure that the index must always remain in bound.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>There are different kinds of collection depending on what operations are provided. We discuss in two axises about collections.</p>
<ol>
<]]>
    </summary>
    
      <category term="CTMCP" scheme="http://deltax.me/tags/CTMCP/"/>
    
      <category term="Functional Programming" scheme="http://deltax.me/tags/Functional-Programming/"/>
    
      <category term="Programming Paradigm" scheme="http://deltax.me/categories/Programming-Paradigm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Incredible Functional Programming]]></title>
    <link href="http://deltax.me/2015/03/20/Incredible%20Functional%20Programming/"/>
    <id>http://deltax.me/2015/03/20/Incredible Functional Programming/</id>
    <published>2015-03-19T16:40:16.000Z</published>
    <updated>2015-03-24T17:24:39.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Experience">Experience</h2><p>这一次我为大家分享的主题是, <code>Incredible Functional Programming</code>. 分享的主要的内容是<strong>函数式编程</strong>的一些非常基础的东西, 这与我们平时所使用的<strong>面向对象编程</strong>这种编程范式有着极大的不同. 也希望能给今天的各位带来一些收获或者启发, 而我也能为 <code>Function Programming</code> 的传播与壮大做出自己的一份贡献.</p>
<h3 id="Encounter_Functinol_Programming">Encounter Functinol Programming</h3><p>首先呢, 我想说一下我是如何接触到函数式编程这一编程范式的, 在大一下学期的时候, 有几位 Thoughtworks 的工程师, 来为我们讲解如何使用 Rails 建站. 我个人对这几位工程师也是非常的尊敬的, 在一次偶然的交流中, 他多次提出 Functional Programming 这一编程范式, 当时我对它的第一感觉是很好奇, 而且哪位工程师说过一句话, 我只能记住大概的意思:</p>
<blockquote>
<p>OOP 现在也被很多人批评, 未来一定是 FP 的天下.</p>
</blockquote>
<p>这对于当时只用 Ojective-C 的我来说是不可想象的, 也极大地激起了我的兴趣, 不过, 这件事情虽然没有让我直接转投 FP 的怀抱但是, 我也对 FP 有了很深的印象, 我想: 我就是那时被传教的吧, 也让我之后陷入了这个大坑中.</p>
<p>在之后的学习中, 我学习了<br><a href="http://www.amazon.cn/%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B6-%E7%A1%85%E8%B0%B7%E5%88%9B%E4%B8%9A%E4%B9%8B%E7%88%B6Paul-Graham%E6%96%87%E9%9B%86-Paul-Graham/dp/B004WHZGZQ/ref=sr_1_4?ie=UTF8&amp;qid=1426784128&amp;sr=8-4&amp;keywords=%E9%BB%91%E5%AE%A2" target="_blank" rel="external">黑客与画家</a><br>这本书, 书中提到了对 <a href="http://zh.wikipedia.org/wiki/LISP" target="_blank" rel="external">Lisp</a> (Lisp 是第一个函数式编程语言, 其名称源自列表处理器（英语：List Processor）的缩写) 的推崇, 以及他们使用 Lisp 进行开发的效率是当时其他公司的几十倍, 这对于当时使用 OOP 的我是一种巨大的震撼.</p>
<p>EXTREMLY INCREDIBLE!</p>
<h3 id="Learn_Functional_Programming">Learn Functional Programming</h3><p>随着我对 Lisp 的了解, 我也开始学习 Lisp 的方言, 也就是 Scheme. 当时看的书呢, 也是倍受推崇的 SICP(计算机程序的构造和解释), 这也是到目前为止对我影响最大的书, 第一次颠覆了我对编程这项活动的认识, 而我也感觉到了 Lisp 的神奇, 而我们 Programmer 实际上就是魔术师. 我们使用代码当做我们的咒语, 控制着计算机做出各种神奇的事情. </p>
<p>而在学习 Lisp 之后, 我有参加了 Coursera 中的一门公开课, Programming Language, 在这门课中, 我学习了 <a href="http://zh.wikipedia.org/wiki/ML%E8%AF%AD%E8%A8%80" target="_blank" rel="external">Standerd ML</a>, 而且学习了各种各样的编程范式和编程语言 Ruby SML Racket, 以及它们的区别和联系, 而且写了人生中第二个解释器. 这门课也是我在 Coursera 唯一一门从头追到尾并且完成的课程. 感觉跟下来收获还是非常大的.</p>
<p>之后在几个月前, 我又开始学习了 <a href="http://zh.wikipedia.org/wiki/Haskell" target="_blank" rel="external">Haskell</a>, 了解了 Haskell 这门语言的抽象能力是多么的强大, 多么的难学, 概念多么的难以理解, 不过我还是选择学习 Haskell 这门编程语言, 而我学习的最大理由就是他太好玩了, 在 Learn you a Haskell for Great Good 这本书中的前言写到:</p>
<blockquote>
<p>Haskell 很有趣, 这就够了.</p>
</blockquote>
<p>然后就是在 <a href="https://www.hackerrank.com/domains/fp" target="_blank" rel="external">HackerRank</a> 上隔三差五刷两道题解解闷, 顺便陶冶一下情操. 后来我有接触到了 <a href="http://zh.wikipedia.org/wiki/Scala" target="_blank" rel="external">Scala</a>, 不过看着那个丑陋的 IDE 和字体我果断放弃了. 目前就是闲来无事刷刷题, 看看博客, 读读论文. 这基本上就是我到目前为止学习函数式编程的全部经历了.</p>
<hr>
<h2 id="Why_Functional_Programming">Why Functional Programming</h2><p>函数式编程有哪些好处, 我们为什么要学习函数式编程呢.</p>
<ul>
<li>首先, 它很有趣, 这也是我学习函数式编程的原因</li>
<li>其次, 函数在函数式编程中作为一等公民, 提供了强大的抽象能力.  <code>map</code> <code>fold</code> <code>filter</code> 等等操作处理数据非常的优雅. 传统的编程语言都在想方设法集成这些特性.</li>
<li>由于函数式编程中的数据不可改变, 线程竞争在函数式编程是不可能的事情, 这也就能够大大地提高并发编程的处理速度. </li>
<li>同时, 在纯函数式编程语言中, 函数没有任何副作用. 因为函数的返回结果只与输入结果有关, 所以它的稳定性是面向对象编程所不能比的. 因为所有的函数, 都不会依赖于外部的状态, 只取决于输入的参数.</li>
</ul>
<p>随着人们对函数式编程的认识越来越高, 许多公司也开始重视函数式编程在高并发以及稳定性方面的强大能力. </p>
<hr>
<h2 id="Introduction">Introduction</h2><p>接下来, 我介绍一下函数式编程的一些特点和如何学习(入)习(坑), 入坑前请深思熟虑, 我是否能为一个我很少用到的东西投入大量的时间, 换来一些对于个人可以接受的结果.</p>
<p>而对于使用哪一种语言来对函数式编程进行介绍, 我选择了非常简单的 <a href="http://zh.wikipedia.org/wiki/Scheme" target="_blank" rel="external">Scheme</a> 来为各位演示函数式编程, 与我们平时使用的命令式编程有什么区别.</p>
<h3 id="Lambda_Calculus">Lambda Calculus</h3><p>我们在讨论 Scheme 之前, 首先要了解什么是 <a href="http://zh.wikipedia.org/wiki/%CE%9B%E6%BC%94%E7%AE%97" target="_blank" rel="external">lambda演算</a></p>
<blockquote>
<p>λ演算（英语: lambda calculus，λ-calculus）是一套用于研究函数定义、函数应用和递归的形式系统. Lambda 演算可以被称为最小的通用程序设计语言. 它包括一条变换规则（变量替换）和一条函数定义方式, Lambda 演算之通用在于, 任何一个可计算函数都能用这种形式来表达和求值. 因而, 它是等价于图灵机的. 尽管如此, Lambda演算强调的是变换规则的运用,  而非实现它们的具体机器. 可以认为这是一种更接近软件而非硬件的方式.</p>
</blockquote>
<p>我们在接下来的讨论中会提高 lambda 在 Scheme 中如何使用, 所以在这里就先不再多说了.</p>
<h3 id="Church_Number">Church Number</h3><p><a href="http://zh.wikipedia.org/wiki/%E9%82%B1%E5%A5%87%E6%95%B0" target="_blank" rel="external">邱奇数</a> 是把数据和运算符嵌入到 lambda 演算内的一种方式, 它是使用 lambda 符号的自然数表示法.</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span> zero <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">f</span>)</span> <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">x</span>)</span> x)</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span> one <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">f</span>)</span> <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">x</span>)</span> <span class="list">(<span class="keyword">f</span> x)</span>)</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span> two <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">f</span>)</span> <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">x</span>)</span> <span class="list">(<span class="keyword">f</span> <span class="list">(<span class="keyword">f</span> x)</span>)</span>)</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword">plus</span> n m)</span></span><br><span class="line">  <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">f</span>)</span> <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">x</span>)</span> <span class="list">(<span class="list">(<span class="keyword">m</span> f)</span> <span class="list">(<span class="list">(<span class="keyword">n</span> f)</span> x)</span>)</span>)</span>)</span>)</span></span><br><span class="line">  </span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span> true <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">x</span>)</span> <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">y</span>)</span> x)</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span> false <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">x</span>)</span> <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">y</span>)</span> y)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>我在这里只为各位简单的展示一下如何使用 lambda 来表示一些数据类型.</p>
<h3 id="Intrduction_to_Scheme">Intrduction to Scheme</h3><p>Scheme 是一种函数式语言, 是 Lisp 的两种主要的方言之一, 它的设计极其的简单, 一个小型语言核心作为标准, 加上各种强力的语法糖扩展语言本身. Scheme的哲学是: 设计计算机语言不应该进行功能的堆砌, 而应该尽可能减少弱点和限制, 使剩下的功能显得必要. Scheme 是第一个使用静态作用域的 Lisp 方言, 也是第一个引入”干净宏”和第一类续延的编程语言.</p>
<h4 id="Warm_Up">Warm Up</h4><p>我现在介绍一下在 Scheme 中最简单的一些表达式</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(+ <span class="number">2</span> <span class="number">5</span>) =&gt; <span class="number">7</span></span><br><span class="line">(* <span class="number">3</span> <span class="number">5</span> (+ <span class="number">2</span> <span class="number">4</span>)) =&gt; <span class="number">90</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到, 在 Scheme 中所有的表达式都是被采用前序(prefix)表示法, 并且<strong>括号</strong>以及空白作为分隔符.</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(define a 1)</span></span><br><span class="line"><span class="comment">(define b 2)</span></span><br><span class="line"><span class="comment">(define (double x)</span> <span class="comment">(+ x x)</span>)</span><br><span class="line"><span class="comment">(if (= (double a)</span> <span class="number">2</span>)</span><br><span class="line">	<span class="comment">((lambda (x)</span> <span class="comment">(+ x b)</span>) <span class="number">2</span>)</span><br><span class="line">	<span class="number">0</span>)</span><br><span class="line">	</span><br><span class="line">=&gt; <span class="number">4</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>define</code> 不仅可以定义一个变量 <code>(define  a 1)</code>, 也可以定义一个函数 <code>(define (double x) (+ x x))</code>.<ul>
<li><code>(define &lt;identifier&gt; &lt;expression&gt;)</code></li>
</ul>
</li>
<li><code>if</code> 语句的语法如下<ul>
<li><code>(if &lt;predicate-clause&gt; &lt;true-clause&gt; &lt;false-clause&gt;)</code></li>
</ul>
</li>
<li><code>lambda</code> 其实可以看作一个匿名函数, 在这里它接收一个参数 <code>x</code> 返回一个单参数的函数, 然后把 <code>2</code> 作为这个函数的参数返回 <code>(+ 2 b) =&gt; 4</code>.<ul>
<li><code>(lambda (parameters) expression)</code></li>
</ul>
</li>
</ul>
<p>而到目前为止, 我们已经掌握了这次分享与 Scheme 有关的全部语法了.</p>
<h4 id="Newton’s_Method">Newton’s Method</h4><p>不论你学习哪一种函数式编程语言, <strong>牛顿法</strong> (Newton’s method)求平方跟都是一个你基本扰不过的问题, 因为我在很多函数式编程语言的书或者课程中, 都发现了他的身影, 包括 Scala Haskell Scheme …</p>
<p>牛顿法怎么求某个 <code>x</code> 的平方根呢.</p>
<ol>
<li>做出一个猜测 <code>guess</code>.</li>
<li>求出 <code>guess</code> 的平方, 然后与 <code>x</code> 比较, 如果差值在可以容忍的范围之内, 那么 <code>guess</code> 就是我们要求的近似的平方根, 如果不满足, 则继续步骤 3.</li>
<li>求出 <code>x/guess</code> 的值, 并与 <code>guess</code> 求平均数, 提高 <code>guess</code> 的准确性, 返回步骤 2.</li>
</ol>
<p>代码如下:</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword"><span class="built_in">sqrt</span></span> x)</span></span><br><span class="line">  <span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword">good-enough?</span> guess)</span></span><br><span class="line">    <span class="list">(<span class="keyword"><span class="built_in">&lt;</span></span> <span class="list">(<span class="keyword"><span class="built_in">abs</span></span> <span class="list">(<span class="keyword"><span class="built_in">-</span></span> <span class="list">(<span class="keyword">square</span> guess)</span> x)</span>)</span> tolerance)</span>)</span></span><br><span class="line">  <span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword">improve</span> guess)</span></span><br><span class="line">    <span class="list">(<span class="keyword">average</span> guess <span class="list">(<span class="keyword"><span class="built_in">/</span></span> x guess)</span>)</span>)</span></span><br><span class="line">  <span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword">sqrt-iter</span> guess)</span></span><br><span class="line">    <span class="list">(<span class="keyword"><span class="built_in">if</span></span> <span class="list">(<span class="keyword">good-enough?</span> guess)</span></span><br><span class="line">        guess</span><br><span class="line">        <span class="list">(<span class="keyword">sqrt-iter</span> <span class="list">(<span class="keyword">improve</span> guess)</span>)</span>)</span>)</span></span><br><span class="line">  <span class="list">(<span class="keyword"><span class="built_in">define</span></span> tolerance <span class="number">0.001</span>)</span></span><br><span class="line">  <span class="list">(<span class="keyword">sqrt-iter</span> <span class="number">1.0</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>这段代码使用了非常神奇的方式, 迭代地解决了如何使求平方根的问题, 我觉得在此处用作例子也再好不过, 我们整理一下这段代码, 让你们感觉到函数式编程的神奇和它带给我们的强大的表达能力.</p>
<h3 id="Introduction_to_Haskell">Introduction to Haskell</h3><p>接下来我们将使用 Haskell 继续对函数式编程进行介绍. 我们接下来将介绍一下几个概念:</p>
<ul>
<li>列表(和列表推导式)</li>
<li>模式匹配</li>
<li>柯里化</li>
</ul>
<p>这三个重要的概念都是在函数编程中极其常用的, 如果你选择了函数式编程, 那么几乎每时每刻都在与这三者打交道.</p>
<h4 id="Warm_Up-1">Warm Up</h4><p>我们先来写几个非常简单的 Haskell 函数来热一热身, 我们先把之前 使用 Scheme 求平方根的代码, 转换为 Haskell 编译器能够理解的 Haskell 代码.</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sqrt :: (Ord s, Floating s) =&gt; s -&gt; s</span><br><span class="line">sqrt <span class="variable">x =</span> sqrtIter <span class="number">1.0</span></span><br><span class="line">  where <span class="variable">tolerance =</span> <span class="number">0.0001</span></span><br><span class="line">        goodEnough <span class="variable">guess =</span> abs ((guess ** <span class="number">2</span>) - x) &lt; tolerance</span><br><span class="line">        improve <span class="variable">guess =</span> (guess + x / guess) / <span class="number">2</span></span><br><span class="line">        sqrtIter <span class="variable">guess =</span> <span class="keyword">if</span> goodEnough guess</span><br><span class="line">                         <span class="keyword">then</span> guess</span><br><span class="line">                         <span class="keyword">else</span> sqrtIter $ improve guess</span><br></pre></td></tr></table></figure>
<p>在 Haskell 中为函数加上类型声明是非常好的习惯, 这里的类型声明暂时不需要大家理解.</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> :: <span class="keyword">Int</span> -&gt; <span class="keyword">Int</span></span><br><span class="line"><span class="keyword">double</span> x = x * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">square :: <span class="keyword">Int</span> -&gt; <span class="keyword">Int</span></span><br><span class="line">square x = x * x</span><br></pre></td></tr></table></figure>
<p>这里我们可以看到两个函数的类型声明都是 <code>Int -&gt; Int</code> 就是接收一个 <code>Int</code> 类型的值, 返回一个 <code>Int</code> 类型的值.</p>
<h4 id="List_and_List_Comprehension">List and List Comprehension</h4><p>在Haskell中, List 非常的重要. 它是最常用的数据结构，并且十分强大，灵活地使用它可以解决很多问题. 它是一种单类型的数据结构, 可以用来存储多个类型相同的元素. 我们可以在里面装一组数字或者一组字符, 但不能把字符和数字装在一起, 而且 List 是可以嵌套的.</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ghci&gt; let numbers = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line">ghci&gt; numbers</span><br><span class="line">[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">ghci&gt; let nestedNumbers = <span class="string">[[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]</span>   </span><br><span class="line">ghci&gt; nestedNumbers</span><br><span class="line"><span class="string">[[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]</span>   </span><br><span class="line"></span><br><span class="line">ghci&gt; <span class="number">3</span>:[head numbers] ++ [head $ tail numbers]</span><br><span class="line">[<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>我们使用 head tail ++ : 几种对列表进行简单的处理.<ul>
<li>head 取出列表中第一个元素</li>
<li>tail 取出列表去掉第一个元素后剩下的列表</li>
<li>++ 连接两个列表</li>
<li>: 在列表前添加一个元素</li>
</ul>
</li>
</ul>
<p>至于一些其他的方法, 在这里也不做过多的介绍, 比如说 <code>length</code> <code>reverse</code> <code>take</code> … 他们都是非常重要的操作.</p>
<p>如果你现在还记得对集合的 Comprehension 那么, 你对 Haskell 的 List Comprehension 理解也会十分的轻松.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [x*<span class="number">2</span> | x &lt;- [<span class="number">1.</span><span class="number">.10</span>]]   </span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">20</span>]</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; [x*<span class="number">2</span> | x &lt;- [<span class="number">1.</span><span class="number">.10</span>], x*<span class="number">2</span> &gt;= <span class="number">12</span>]   </span><br><span class="line">[<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">20</span>] </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; [ x | x &lt;- [<span class="number">50.</span><span class="number">.100</span>], x `mod` <span class="number">7</span> == <span class="number">3</span>]   </span><br><span class="line">[<span class="number">52</span>,<span class="number">59</span>,<span class="number">66</span>,<span class="number">73</span>,<span class="number">80</span>,<span class="number">87</span>,<span class="number">94</span>]</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; [ x*y | x &lt;- [<span class="number">2</span>,<span class="number">5</span>,<span class="number">10</span>], y &lt;- [<span class="number">8</span>,<span class="number">10</span>,<span class="number">11</span>]]   </span><br><span class="line">[<span class="number">16</span>,<span class="number">20</span>,<span class="number">22</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">55</span>,<span class="number">80</span>,<span class="number">100</span>,<span class="number">110</span>]</span><br></pre></td></tr></table></figure>
<p>这里也没啥好说的, 太简单了.</p>
<p>我们使用列表推倒来实现 quicksort.</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">quicksort :: [Int] -&gt; [Int]</span><br><span class="line">quicksort [] = []</span><br><span class="line">quicksort (x:xs) = quicksort <span class="keyword">ls</span> ++ [x] ++ quicksort <span class="keyword">bs</span></span><br><span class="line">  where <span class="keyword">ls</span> = [<span class="keyword">l</span> | <span class="keyword">l</span> &lt;- xs, <span class="keyword">l</span> &lt;= x]</span><br><span class="line">        <span class="keyword">bs</span> = [b | b &lt;- xs, b &gt; x]</span><br></pre></td></tr></table></figure>
<h4 id="Pattern_Matching">Pattern Matching</h4><p>模式匹配通过检查数据的特定结构来检查其是否匹配, 并按模式从中取得数据. 举一个例子大家就能非常轻松地理解模式匹配.</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">factorial ::</span> (Integral <span class="literal">a</span>) =&gt; <span class="literal">a</span> -&gt; <span class="literal">a</span>   </span><br><span class="line">factorial <span class="number">0</span> = <span class="number">1</span>   </span><br><span class="line">factorial n = n * factorial (n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p><code>factorial</code> 是一个递归的函数, <code>factorial</code> 接收一个参数, 当这个参数为 0 的时候, 会匹配到第一种情况直接返回 1, 否则就会匹配到第二种情况, 递归地求解 <code>factorial</code>, 直到参数为 0, 返回结果.</p>
<p>这个函数可以等价为</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">factorial ::</span> (Integral <span class="literal">a</span>) =&gt; <span class="literal">a</span> -&gt; <span class="literal">a</span></span><br><span class="line">factorial n = <span class="keyword">if</span> n == <span class="number">0</span> then <span class="number">1</span> <span class="keyword">else</span> n * factorial (n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>不过使用模式匹配的写法对于使用函数式编程的人来说更加具有可读性, 而经过长时间的使用, 相信各位一定会习惯模式匹配的写法.</p>
<p>有很多命令式语言都提供 <code>case</code> 表达式, 就是取一个变量, 按照对变量的判断选择对应的代码块, 而模式匹配实际上就是 <code>case</code> 表达式的语法糖.</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> expression <span class="keyword">of</span> pattern -&gt; <span class="literal">result</span>   </span><br><span class="line">                   pattern -&gt; <span class="literal">result</span>   </span><br><span class="line">                   pattern -&gt; <span class="literal">result</span></span><br></pre></td></tr></table></figure>
<p>我们将阶乘函数转化为 <code>case</code> 形式:</p>
<figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">factorial :: (<span class="type">Integral</span> a) =&gt; a -&gt; a   </span><br><span class="line">factorial n = <span class="keyword">case</span> n <span class="keyword">of</span> <span class="number">0</span> -&gt; <span class="number">1</span></span><br><span class="line">								 n -&gt; n * factorial (n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>好了, 我们已经对模式匹配有了了解, 接下来我们该介绍函数式编程下一个非常有趣的话题.</p>
<h4 id="Currying">Currying</h4><p><a href="http://zh.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C%E5%8C%96" target="_blank" rel="external">柯里化</a> 是把接收多个参数的函数变换成接收一个单一参数的函数.</p>
<p>比如我们定义一个函数 <code>add</code>:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add</span> :: <span class="keyword">Int</span> -&gt; <span class="keyword">Int</span> -&gt; <span class="keyword">Int</span></span><br></pre></td></tr></table></figure>
<p>在之前的理解中, <code>add</code> 是一个接收两个 <code>Int</code> 类型参数的并返回一个 <code>Int</code> 的函数.</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add</span> <span class="built_in">x</span> <span class="built_in">y</span> = <span class="built_in">x</span> + <span class="built_in">y</span></span><br></pre></td></tr></table></figure>
<p>我们直接将两个参数传入这个函数 <code>add 3 4</code> 就会返回 <code>5</code>.</p>
<p>但是, 现在我们能不能只给他传一个参数呢, 我么来尝试一下:</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ghci&gt;<span class="instruction"> add </span>3</span><br><span class="line">	</span><br><span class="line">&lt;interactive&gt;:9:1:</span><br><span class="line">    No<span class="instruction"> instance </span>for<span class="function"> (</span>Show<span class="function"> (</span>a0 -&gt; a0<span class="function">)</span><span class="function">)</span> arising from a use of ‘print’</span><br><span class="line">    In a stmt of an interactive GHCi command: print it</span><br></pre></td></tr></table></figure>
<p>我们直接在 ghci 中输入 <code>add 3</code> 然后, 编译器报错了, 错误的内容是不能正确的显示这个结果, 说明编译器不理解如何 <code>print</code> 这个结果, 我们换一种方式查看一下类型:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ghci&gt; :t <span class="keyword">add</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">add</span> <span class="number">3</span> :: <span class="keyword">Int</span> -&gt; <span class="keyword">Int</span></span><br></pre></td></tr></table></figure>
<p>发现这个 <code>add 3</code> 的类型竟然是 <code>Int -&gt; Int</code> 这说明, <code>add</code> 函数接受了一个 <code>Int</code> 返回了一个 <code>Int -&gt; Int</code> 的函数.</p>
<p>我们接下来为这个函数起一个名字</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ghci&gt; let addThree = <span class="keyword">add</span> <span class="number">3</span></span><br><span class="line">ghci&gt; :t <span class="keyword">add</span></span><br><span class="line"><span class="keyword">add</span>       addThree</span><br><span class="line">ghci&gt; :t addThree</span><br><span class="line">addThree :: <span class="keyword">Int</span> -&gt; <span class="keyword">Int</span></span><br></pre></td></tr></table></figure>
<p>然后尝试调用这个函数</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ghci&gt; addThree 4</span><br><span class="line">7</span><br></pre></td></tr></table></figure>
<p>发现这个函数的返回值竟然也是 <code>7</code> 这是为什么呢?</p>
<p>因为在函数式语言的实现中, 函数的定义会被转换为如下的形式:</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add :: Int<span class="function"> -&gt;</span> Int<span class="function"> -&gt;</span> Int</span><br><span class="line">add = <span class="string">\x</span> <span class="function">-&gt;</span> (<span class="string">\y</span> <span class="function">-&gt;</span> x + y)</span><br></pre></td></tr></table></figure>
<p>它可以每次只接受一个参数, 然后返回一个函数或者值. 这就是函数为什么可以柯里化的原因.</p>
<p>柯里化又可以做些什么呢, 我们在介绍一个非常重要的函数 <code>map</code>, <code>map</code> 翻译过来就是映射, 他把一个函数映射到一个列表中, 我们简单的举个例子.</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ghci</span>&gt; map (\x -&gt; x * x)<span class="sqbracket"> [1,2,3,4,5]</span><span class="sqbracket"></span><br><span class="line">[1,4,9,16,25]</span></span><br></pre></td></tr></table></figure>
<p>它把一个匿名函数依次映射到列表 <code>[1,2,3,4,5]</code> 中, 最后将这些结果连接成一个列表.</p>
<p><code>map</code> 为我们提供了一个高阶的抽象, 它以一个函数和列表作为参数, 返回一个列表.</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map :: <span class="function"><span class="params">(a -&gt; b)</span> -&gt;</span> [a]<span class="function"> -&gt;</span> [b]</span><br></pre></td></tr></table></figure>
<p>我们接下来就可以使用 <code>map</code> 和柯里化构建大量的函数, 减少我们的工作量</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">square :: <span class="keyword">Int</span> -&gt; <span class="keyword">Int</span></span><br><span class="line">square = \x -&gt; x * x</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> :: <span class="keyword">Int</span> -&gt; <span class="keyword">Int</span></span><br><span class="line"><span class="keyword">double</span> = (+<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">squareList :: [<span class="keyword">Int</span>] -&gt; [<span class="keyword">Int</span>]</span><br><span class="line">squareList = map square</span><br><span class="line"></span><br><span class="line">doubleList :: [<span class="keyword">Int</span>] -&gt; [<span class="keyword">Int</span>]</span><br><span class="line">doubleList = map <span class="keyword">double</span></span><br></pre></td></tr></table></figure>
<p>而接下来我们就可以直接使用 <code>squareList</code> 和 <code>doubleList</code> 完成对列表的操作.</p>
<hr>
<h2 id="Application">Application</h2><p>目前应用到生产环境还是比较少, 不过已经有一些公司, 使用 scala, Erlang 等等语言做一些后端方面的开发. 我对这些语言的了解还是比较少的.</p>
<p>Lisp 也被用来开发 Emacs 和一些人工智能的领域, 具体戳这里<a href="http://en.wikipedia.org/wiki/Common_Lisp#Applications" target="_blank" rel="external">http://en.wikipedia.org/wiki/Common_Lisp#Applications</a>.</p>
<p>当你理解了函数式编程的一些思想, 你会发现原来以前所学过的很多东西都是函数式编程的缩影, 而对于 iOS 开发, 目前是十分流行的框架 <code>ReactiveCocoa</code> 就是由函数式编程的思想开发的.</p>
<hr>
<h2 id="Final">Final</h2><p>最后的最后, 我为大家推荐一些函数式编程的学习资料.</p>
<p>Scheme:</p>
<ul>
<li><a href="http://www.amazon.cn/The-Little-Schemer-Friedman-Daniel-P/dp/0262560992/ref=sr_1_1?ie=UTF8&amp;qid=1426822097&amp;sr=8-1&amp;keywords=the+little+schemer" target="_blank" rel="external">The Litter Schemer</a></li>
<li><a href="http://www.amazon.cn/Structure-and-Interpretation-of-Computer-Programs-Abelson-Harold/dp/0262510871/ref=sr_1_2?ie=UTF8&amp;qid=1426822081&amp;sr=8-2&amp;keywords=Structure+and+Interpretation+of+Computer+Program" target="_blank" rel="external">Structure and Interpretation of Computer Program</a></li>
<li><a href="http://mitpress.mit.edu/sicp/" target="_blank" rel="external">http://mitpress.mit.edu/sicp/</a></li>
</ul>
<p>Haskell:</p>
<ul>
<li><a href="http://learnyouahaskell.com/" target="_blank" rel="external">Learn you a haskell for great good</a></li>
<li><a href="http://book.realworldhaskell.org/read/" target="_blank" rel="external">Real World Haskell</a></li>
</ul>
<p>终于结束了…真累.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Experience">Experience</h2><p>这一次我为大家分享的主题是, <code>Incredible Functional Programming</code>. 分享的主要的内容是<strong>函数式编程</strong>的一些非常基础的]]>
    </summary>
    
      <category term="Functional Programming" scheme="http://deltax.me/tags/Functional-Programming/"/>
    
      <category term="Scheme" scheme="http://deltax.me/tags/Scheme/"/>
    
      <category term="Programming Paradigm" scheme="http://deltax.me/categories/Programming-Paradigm/"/>
    
  </entry>
  
</feed>