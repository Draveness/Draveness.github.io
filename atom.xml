<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[DeltaX]]></title>
  <subtitle><![CDATA[我们来填坑吧]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://deltax.me/"/>
  <updated>2015-04-07T04:50:12.000Z</updated>
  <id>http://deltax.me/</id>
  
  <author>
    <name><![CDATA[Draven]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Prolog 匹配 <2>]]></title>
    <link href="http://deltax.me/2015/04/07/Prolog-%E5%8C%B9%E9%85%8D-2/"/>
    <id>http://deltax.me/2015/04/07/Prolog-匹配-2/</id>
    <published>2015-04-07T02:45:48.000Z</published>
    <updated>2015-04-07T04:50:12.000Z</updated>
    <content type="html"><![CDATA[<p>这篇 post 有两个主要的目的:</p>
<ol>
<li>讨论 Prolog 中的匹配, 解释匹配(match)与相等的不同.</li>
<li>使用 Prolog 搜索的机制解决一些问题.</li>
</ol>
<h2 id="Matching">Matching</h2><p>Prolog 中有三种不同的 term, 分别的 <code>constants</code>, <code>variables</code> 和 <code>complex terms</code>.</p>
<p>接下来我们解释一下两个 terms 是如何匹配的.</p>
<blockquote>
<p>当两个 term 含有相等, 或者两个 term 中的变量在被绑定为指定值之后, 两个 term 相等时, 两个 term 匹配.</p>
</blockquote>
<p>也就是说, 以下的 term 都会匹配:</p>
<ul>
<li>mia = mia.</li>
<li>42 = 42.</li>
<li>mia = X.</li>
<li>X = Y.</li>
<li>friends(john,X) = friends(Y,tom).</li>
</ul>
<p>接下来我们对匹配进行更精确的定义:</p>
<ol>
<li>如果 term1 和 term2 都是常量, 那么只有当两者是相同的原子或者相同的数字, term1 term2 匹配.</li>
<li>如果 term1 是变量, term2 是任意类型的 term, 那么 term1 和 term2 匹配, term1 会被绑定为 term2.</li>
<li>如果 term1 term2 是 complex term, 那么在下面情况下, 它们会匹配<ul>
<li>它们含有相同的名字和参数数量.</li>
<li>它们对应的参数匹配.</li>
<li>变量的绑定是兼容的, 同一个变量不会同时绑定为两个值.</li>
</ul>
</li>
<li>两个 terms 只有在上述 3 个条件之一成立时, 才会匹配.</li>
</ol>
<p>匹配有什么作用呢? 我们可以使用匹配来为我们提供更强大的抽象能力:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">vertical</span><span class="params">(line(point(X,Y)</span></span>,<span class="function"><span class="title">point</span><span class="params">(X,Z)</span></span>)).</span><br><span class="line"><span class="function"><span class="title">horizontal</span><span class="params">(line(point(X,Y)</span></span>,<span class="function"><span class="title">point</span><span class="params">(Z,Y)</span></span>)).</span><br></pre></td></tr></table></figure>
<p>这两行 Prolog 代码并不是规则, 而是事实, 我们可以使用匹配的能力, 写出这两个规则, 这样我们就可以轻易地判断一条直线是否是垂直的或是水平的.</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?- vertical(<span class="built_in">line</span>(<span class="built_in">point</span>(<span class="number">1</span>,<span class="number">1</span>),<span class="built_in">point</span>(<span class="number">1</span>,<span class="number">3</span>))).</span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<p>同样我们也可以利用匹配来寻找与某一点构成垂线的点.</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?- vertical(<span class="built_in">line</span>(<span class="built_in">point</span>(<span class="number">1</span>,<span class="number">1</span>),<span class="built_in">point</span>(X,<span class="number">4</span>))).</span><br><span class="line">X = <span class="number">1.</span></span><br></pre></td></tr></table></figure>
<p>同样我们也可以利用 Prolog 的匹配解决更加复杂更加困难的问题.</p>
<p>现在我们有 6 个单词, 我们需要将它们填入下面的拼图里:</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">word</span>(abalone,a,b,a,<span class="keyword">l</span>,o,<span class="keyword">n</span>,<span class="keyword">e</span>). <span class="literal">word</span>(abandon,a,b,a,<span class="keyword">n</span>,<span class="keyword">d</span>,o,<span class="keyword">n</span>). </span><br><span class="line"><span class="literal">word</span>(enhance,<span class="keyword">e</span>,<span class="keyword">n</span>,<span class="keyword">h</span>,a,<span class="keyword">n</span>,c,<span class="keyword">e</span>). </span><br><span class="line"><span class="literal">word</span>(anagram,a,<span class="keyword">n</span>,a,<span class="keyword">g</span>,r,a,<span class="keyword">m</span>). </span><br><span class="line"><span class="literal">word</span>(connect,c,o,<span class="keyword">n</span>,<span class="keyword">n</span>,<span class="keyword">e</span>,c,t). </span><br><span class="line"><span class="literal">word</span>(elegant,<span class="keyword">e</span>,<span class="keyword">l</span>,<span class="keyword">e</span>,<span class="keyword">g</span>,a,<span class="keyword">n</span>,t).</span><br></pre></td></tr></table></figure>
<p><img src="http://deltax.qiniudn.com/grid.png?attname=&e=1428468444&token=YJb_IPQrTSw1ox9LenQDH1HRcgHii9w_bp9ddmcz:HRx3nHoQ3qkHtLdWoQI0-Q6LUUA" style="display:block;margin:auto"></p>
<p>我们可以通过 Prolog 得出答案, 只需要将需要满足的条件写在 predicate 里:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">crosswd</span><span class="params">(V1,V2,V3,H1,H2,H3)</span></span>:-</span><br><span class="line">    <span class="function"><span class="title">word</span><span class="params">(V1,_,A,_,B,_,C,_)</span></span>,</span><br><span class="line">    <span class="function"><span class="title">word</span><span class="params">(V2,_,D,_,E,_,F,_)</span></span>,</span><br><span class="line">    <span class="function"><span class="title">word</span><span class="params">(V3,_,G,_,H,_,I,_)</span></span>,</span><br><span class="line">    <span class="function"><span class="title">word</span><span class="params">(H1,_,A,_,D,_,G,_)</span></span>,</span><br><span class="line">    <span class="function"><span class="title">word</span><span class="params">(H2,_,B,_,E,_,H,_)</span></span>,</span><br><span class="line">    <span class="function"><span class="title">word</span><span class="params">(H3,_,C,_,F,_,I,_)</span></span>,</span><br></pre></td></tr></table></figure>
<p>这样我们就可以得到结果:</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">?- crosswd(H1,H2,H3,V1,V2,V3).</span><br><span class="line"><span class="variable">H1 =</span> abalone,</span><br><span class="line"><span class="variable">H2 =</span> anagram,</span><br><span class="line"><span class="variable">H3 =</span> connect,</span><br><span class="line"><span class="variable">V1 =</span> abandon,</span><br><span class="line"><span class="variable">V2 =</span> elegant,</span><br><span class="line"><span class="variable">V3 =</span> enhance ;</span><br><span class="line"><span class="variable">H1 =</span> abandon,</span><br><span class="line"><span class="variable">H2 =</span> elegant,</span><br><span class="line"><span class="variable">H3 =</span> enhance,</span><br><span class="line"><span class="variable">V1 =</span> abalone,</span><br><span class="line"><span class="variable">V2 =</span> anagram,</span><br><span class="line"><span class="variable">V3 =</span> connect ;</span><br><span class="line"><span class="constant">false</span>.</span><br></pre></td></tr></table></figure>
<p>Prolog 中匹配的能力非常强大, 其实它就是对已经有的条件和数据进行搜索, 尝试所有的答案, 最后给出满足条件的所有结果, 能够极大的降低我们的计算量.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这篇 post 有两个主要的目的:</p>
<ol>
<li>讨论 Prolog 中的匹配, 解释匹配(match)与相等的不同.</li>
<li>使用 Prolog 搜索的机制解决一些问题.</li>
</ol>
<h2 id="Matching">Matching</]]>
    </summary>
    
      <category term="Logical Programming" scheme="http://deltax.me/tags/Logical-Programming/"/>
    
      <category term="Prolog" scheme="http://deltax.me/tags/Prolog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[红黑树]]></title>
    <link href="http://deltax.me/2015/04/07/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>http://deltax.me/2015/04/07/红黑树/</id>
    <published>2015-04-07T02:02:48.000Z</published>
    <updated>2015-04-07T11:54:25.000Z</updated>
    <content type="html"><![CDATA[<p>红黑树是一棵二叉搜索树, 它在每个结点上增加了一个存储位来表示结点的颜色, 可以使 <code>RED</code> 或 <code>BLACK</code>. 红黑树中没有一条路径会比其他路径长出 2 倍, 所以是近似平衡的.</p>
<p>树中的每个结点包含 5 个属性: <code>color, key, left, right 和 parent</code>. 下面是一个红黑树需要满足的性质:</p>
<ol>
<li>每个结点是红色的或者是黑色的.</li>
<li>根节点是黑色的.</li>
<li>每个叶结点是黑色的.</li>
<li>如果一个结点是红色的, 则它的两个子节点都是黑色的.</li>
<li>对每个结点, 从该结点到其所有后代子结点的简单路径上, 均包含相同数目的黑色结点.</li>
</ol>
<h2 id="旋转">旋转</h2><p>搜索树的操作 <code>tree_insert</code> 和 <code>tree_delete</code> 在含 $n$ 个关键字的红黑树上, 运行时间都为 $O(\lg n)$. 但是这两个操作可能会违反红黑树的性质, 所以我们需要在适当的时间改变树中每个结点的颜色以及指针结构.</p>
<p>指针结构的修改是通过<strong>旋转</strong>来完成的, 这是一种能保持二叉搜索树性质的局部操作.</p>
<p><img src="http://deltax.qiniudn.com/rotate.png?attname=&e=1428480443&token=YJb_IPQrTSw1ox9LenQDH1HRcgHii9w_bp9ddmcz:L_x8FI_ij3vUo81HGDeXNw0kSdk" style="display:block;margin:auto"></p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">struct tree_t &#123;</span><br><span class="line">    struct node_t <span class="subst">*</span>root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct node_t &#123;</span><br><span class="line">    struct node_t <span class="subst">*</span>left;</span><br><span class="line">    struct node_t <span class="subst">*</span>right;</span><br><span class="line">    struct node_t <span class="subst">*</span><span class="keyword">parent</span>;</span><br><span class="line">    color_t color;</span><br><span class="line">    int key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="literal">void</span> left_rotate(tree_t <span class="subst">*</span>tree, node_t <span class="subst">*</span>x) &#123;</span><br><span class="line">    node_t <span class="subst">*</span>y <span class="subst">=</span> x<span class="subst">-&gt;</span>right;</span><br><span class="line">    x<span class="subst">-&gt;</span>right <span class="subst">=</span> y<span class="subst">-&gt;</span>left;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y<span class="subst">-&gt;</span>left <span class="subst">!=</span> <span class="built_in">NULL</span>) &#123;</span><br><span class="line">        y<span class="subst">-&gt;</span>left<span class="subst">-&gt;</span><span class="keyword">parent</span> <span class="subst">=</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    y<span class="subst">-&gt;</span><span class="keyword">parent</span> <span class="subst">=</span> x<span class="subst">-&gt;</span><span class="keyword">parent</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x<span class="subst">-&gt;</span><span class="keyword">parent</span> <span class="subst">==</span> <span class="built_in">NULL</span>) &#123;</span><br><span class="line">        tree<span class="subst">-&gt;</span>root <span class="subst">=</span> y;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x <span class="subst">==</span> x<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span>left) &#123;</span><br><span class="line">        x<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span>left <span class="subst">=</span> y;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span>right <span class="subst">=</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">    y<span class="subst">-&gt;</span>left <span class="subst">=</span> x;</span><br><span class="line">    x<span class="subst">-&gt;</span><span class="keyword">parent</span> <span class="subst">=</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="literal">void</span> right_rotate(tree_t <span class="subst">*</span>tree, node_t <span class="subst">*</span>x) &#123;</span><br><span class="line">    node_t <span class="subst">*</span>y <span class="subst">=</span> x<span class="subst">-&gt;</span>left;</span><br><span class="line">    x<span class="subst">-&gt;</span>left <span class="subst">=</span> y<span class="subst">-&gt;</span>right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y<span class="subst">-&gt;</span>right <span class="subst">!=</span> <span class="built_in">NULL</span>) &#123;</span><br><span class="line">        y<span class="subst">-&gt;</span>left<span class="subst">-&gt;</span><span class="keyword">parent</span> <span class="subst">=</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    y<span class="subst">-&gt;</span><span class="keyword">parent</span> <span class="subst">=</span> x<span class="subst">-&gt;</span><span class="keyword">parent</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x<span class="subst">-&gt;</span><span class="keyword">parent</span> <span class="subst">==</span> <span class="built_in">NULL</span>) &#123;</span><br><span class="line">        tree<span class="subst">-&gt;</span>root <span class="subst">=</span> y;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x <span class="subst">==</span> x<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span>right) &#123;</span><br><span class="line">        x<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span>right <span class="subst">=</span> y;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span>left <span class="subst">=</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    y<span class="subst">-&gt;</span>right <span class="subst">=</span> x;</span><br><span class="line">    x<span class="subst">-&gt;</span><span class="keyword">parent</span> <span class="subst">=</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>left_rotate</code> 和 <code>right_rotate</code> 的都能在时间复杂度 $O(1)$ 内完成, 在这个操作中只有指针改变, 其他所有属性都保持不变.</p>
<h2 id="插入">插入</h2><p>我们可以在 $O(\lg n)$ 时间内完成向一棵含有 $n$ 个结点的红黑树中插入一个新结点. 我们在 <code>tree-insert</code> 的基础上进行修改, 实现了 <code>red_black_insert</code>, 同时我们调用一个辅助函数 <code>red_black_insert_fixup</code> 来对结点进行着色和旋转.</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">void</span> red_black_insert(tree_t <span class="subst">*</span>tree, node_t <span class="subst">*</span>z) &#123;</span><br><span class="line">	node_t <span class="subst">*</span>t <span class="subst">=</span> <span class="built_in">NULL</span>;</span><br><span class="line">	node_t <span class="subst">*</span>x <span class="subst">=</span> tree<span class="built_in">.</span>root;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (x <span class="subst">!=</span> <span class="built_in">NULL</span>) &#123;</span><br><span class="line">		y <span class="subst">=</span> x;</span><br><span class="line">		<span class="keyword">if</span> (z<span class="subst">-&gt;</span>key <span class="subst">&lt;</span> x<span class="subst">-&gt;</span>key) &#123;</span><br><span class="line">			x <span class="subst">=</span> x<span class="subst">-&gt;</span>left;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			x <span class="subst">=</span> x<span class="subst">-&gt;</span>right;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	z<span class="subst">-&gt;</span><span class="keyword">parent</span> <span class="subst">=</span> y;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (y <span class="subst">==</span> <span class="built_in">NULL</span>) &#123;</span><br><span class="line">		tree<span class="subst">-&gt;</span>root <span class="subst">=</span> z;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (z<span class="subst">-&gt;</span>key <span class="subst">&lt;</span> y<span class="subst">-&gt;</span>key) &#123;</span><br><span class="line">		y<span class="subst">-&gt;</span>left <span class="subst">=</span> z;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		y<span class="subst">-&gt;</span>right <span class="subst">=</span> z;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	z<span class="subst">-&gt;</span>left <span class="subst">=</span> <span class="built_in">NULL</span>;</span><br><span class="line">	z<span class="subst">-&gt;</span>right <span class="subst">=</span> <span class="built_in">NULL</span>;</span><br><span class="line">	z<span class="subst">-&gt;</span>color <span class="subst">=</span> RED;</span><br><span class="line"></span><br><span class="line">	red_black_insert_fixup(tree, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为将 z 着色为红色可能违反红黑书的性质, 所以我们需要 <code>red_black_insert_fixup</code> 来保持红黑性质.</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">void</span> red_black_insert_fixup(tree_t <span class="subst">*</span>tree, node_t <span class="subst">*</span>z) &#123;</span><br><span class="line">	<span class="keyword">while</span> (z<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span>colot <span class="subst">==</span> RED) &#123;</span><br><span class="line">		<span class="keyword">if</span> (z<span class="subst">-&gt;</span><span class="keyword">parent</span> <span class="subst">==</span> z<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span>left) &#123;</span><br><span class="line">			y <span class="subst">=</span> z<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span>right;</span><br><span class="line">			<span class="keyword">if</span> (y<span class="subst">-&gt;</span>color <span class="subst">==</span> RED) &#123;</span><br><span class="line">				z<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span>color <span class="subst">=</span> BLACK;</span><br><span class="line">				y<span class="subst">-&gt;</span>color <span class="subst">=</span> BLACK;</span><br><span class="line">				z<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span>color <span class="subst">=</span> RED;</span><br><span class="line">				z <span class="subst">=</span> z<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span><span class="keyword">parent</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (z <span class="subst">==</span> z<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span>right) &#123;</span><br><span class="line">				z <span class="subst">=</span> z<span class="subst">-&gt;</span><span class="keyword">parent</span>;</span><br><span class="line">				left_rotate(tree, z);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (z <span class="subst">==</span> z<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span>left) &#123;</span><br><span class="line">				z<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span>color <span class="subst">=</span> BLACK;</span><br><span class="line">				z<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span>color <span class="subst">=</span> RED;</span><br><span class="line">				right_rotate(tree, z<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span><span class="keyword">parent</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			y <span class="subst">=</span> z<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span>left;</span><br><span class="line">			<span class="keyword">if</span> (y<span class="subst">-&gt;</span>color <span class="subst">==</span> RED) &#123;</span><br><span class="line">				z<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span>color <span class="subst">=</span> BLACK;</span><br><span class="line">				y<span class="subst">-&gt;</span>color <span class="subst">=</span> BLACK;</span><br><span class="line">				z<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span>color <span class="subst">=</span> RED;</span><br><span class="line">				z <span class="subst">=</span> z<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span><span class="keyword">parent</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (z <span class="subst">==</span> z<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span>left) &#123;</span><br><span class="line">				z <span class="subst">=</span> z<span class="subst">-&gt;</span><span class="keyword">parent</span>;</span><br><span class="line">				right_rotate(tree, z);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (z <span class="subst">==</span> z<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span>right) &#123;</span><br><span class="line">				z<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span>color <span class="subst">=</span> BLACK;</span><br><span class="line">				z<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span>color <span class="subst">=</span> RED;</span><br><span class="line">				left_rotate(tree, z<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span><span class="keyword">parent</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	tree<span class="subst">-&gt;</span>root<span class="subst">-&gt;</span>color <span class="subst">=</span> BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该过程总共有三种情况:</p>
<p><img src="http://deltax.qiniudn.com/rb_fixup.png?attname=&e=1428489715&token=YJb_IPQrTSw1ox9LenQDH1HRcgHii9w_bp9ddmcz:gAM32FsSe9SYfyPT4fiJhdgmPFw" style="display:block;margin:auto"></p>
<h3 id="情况1">情况1</h3><p><code>z</code> 的 uncle 结点是红色的, <code>y</code> 为 <code>z</code> 的 uncle 结点.</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">z<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span>color <span class="subst">=</span> BLACK;</span><br><span class="line">y<span class="subst">-&gt;</span>color <span class="subst">=</span> BLACK;</span><br><span class="line">z<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span>color <span class="subst">=</span> RED;</span><br><span class="line">z <span class="subst">=</span> z<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span><span class="keyword">parent</span>;</span><br></pre></td></tr></table></figure>
<p>然后, 再次进入循环, <code>z</code> 变成了 <code>z-&gt;parent-&gt;parent</code>.</p>
<h3 id="情况2">情况2</h3><p><code>z</code> 的 uncle 结点是黑色的, 并且 <code>z</code> 是一个 right child.</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">z <span class="subst">=</span> z<span class="subst">-&gt;</span><span class="keyword">parent</span>;</span><br><span class="line">left_rotate(tree, z);</span><br></pre></td></tr></table></figure>
<p>向左旋转 <code>z</code> 的父结点.</p>
<h3 id="情况3">情况3</h3><p><code>z</code> 的 uncle 结点是黑色的, 并且 <code>z</code> 是一个 left child.</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">z<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span>color <span class="subst">=</span> BLACK;</span><br><span class="line">z<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span>color <span class="subst">=</span> RED;</span><br><span class="line">right_rotate(tree, z<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span><span class="keyword">parent</span>);</span><br></pre></td></tr></table></figure>
<h2 id="删除">删除</h2><p>删除一个结点需要话费 $O(\lg n)$ 时间. 与插入操作相比, 删除操作要稍微复杂一点.</p>
<p>从一棵红黑树中删除结点的过程是基于 <code>tree_delete</code> 过程, 我们需要设计一个 <code>transplant</code> 过程, 并将它应用到红黑树上.</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">void</span> red_black_transplant(tree_t <span class="subst">*</span>tree, node_t <span class="subst">*</span>u, node_t <span class="subst">*</span>v) &#123;</span><br><span class="line">	<span class="keyword">if</span> (u<span class="subst">-&gt;</span><span class="keyword">parent</span> <span class="subst">==</span> <span class="built_in">NULL</span>) &#123;</span><br><span class="line">		tree<span class="subst">-&gt;</span>root <span class="subst">=</span> v;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (u <span class="subst">==</span> u<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span>left) &#123;</span><br><span class="line">		u<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span>left <span class="subst">=</span> v;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		u<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span>right <span class="subst">=</span> v;</span><br><span class="line">	&#125;</span><br><span class="line">	v<span class="subst">-&gt;</span><span class="keyword">parent</span> <span class="subst">=</span> u<span class="subst">-&gt;</span><span class="keyword">parent</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个过程非常的简单, 我们接下来实现 <code>red_black_delete</code> 函数.</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">void</span> red_black_delete(tree_t <span class="subst">*</span>tree, node_t <span class="subst">*</span>z) &#123;</span><br><span class="line">	node_t <span class="subst">*</span>x;</span><br><span class="line">	node_t <span class="subst">*</span>y <span class="subst">=</span> z;</span><br><span class="line">	color_t y_original_color <span class="subst">=</span> y<span class="subst">-&gt;</span>color;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (z<span class="subst">-&gt;</span>left <span class="subst">==</span> <span class="built_in">NULL</span>) &#123;</span><br><span class="line">		x <span class="subst">=</span> z<span class="subst">-&gt;</span>right;</span><br><span class="line">		red_black_transplant(tree, z, z<span class="subst">-&gt;</span>right);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (z<span class="subst">-&gt;</span>right <span class="subst">==</span> <span class="built_in">NULL</span>) &#123;</span><br><span class="line">		x <span class="subst">=</span> z<span class="subst">-&gt;</span>left;</span><br><span class="line">		red_black_transplant(tree, z, z<span class="subst">-&gt;</span>left);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		y <span class="subst">=</span> tree_minimum(z<span class="subst">-&gt;</span>right);</span><br><span class="line">		x <span class="subst">=</span> y<span class="subst">-&gt;</span>right;</span><br><span class="line">		<span class="keyword">if</span> (y<span class="subst">-&gt;</span><span class="keyword">parent</span> <span class="subst">==</span> z) &#123;</span><br><span class="line">			x<span class="subst">-&gt;</span><span class="keyword">parent</span> <span class="subst">=</span> z;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			red_black_transplant(tree, y, y<span class="subst">-&gt;</span>right);</span><br><span class="line">			y<span class="subst">-&gt;</span>right <span class="subst">=</span> z<span class="subst">-&gt;</span>left;</span><br><span class="line">			y<span class="subst">-&gt;</span>right<span class="subst">-&gt;</span><span class="keyword">parent</span> <span class="subst">=</span> y;</span><br><span class="line">		&#125;</span><br><span class="line">		red_black_transplant(tree, z, y);</span><br><span class="line">		y<span class="subst">-&gt;</span>left <span class="subst">=</span> z<span class="subst">-&gt;</span>left;</span><br><span class="line">		y<span class="subst">-&gt;</span>left<span class="subst">-&gt;</span><span class="keyword">parent</span> <span class="subst">=</span> y;</span><br><span class="line">		y<span class="subst">-&gt;</span>color <span class="subst">=</span> z<span class="subst">-&gt;</span>color;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (y_original_color <span class="subst">==</span> BLACK) &#123;</span><br><span class="line">		red_black_delete_fixup(tree, x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>red_black_delete</code> 函数与 <code>tree_delete</code> 拥有相同的结构. 如果结点 y 是黑色的, 就会产生三个问题.</p>
<ol>
<li>如果 <code>y</code> 是原来的根节点, 而 <code>y</code> 的一个红色的 child 成为新的根节点</li>
<li><code>x</code> 和 <code>x-&gt;parent</code> 是红色的.</li>
<li>在树中移动 <code>y</code> 会导致先前包含结点 <code>y</code> 的任何简单路径上的黑色结点个数减少 <code>1</code>.</li>
</ol>
<p>现在我们来看一下过程 <code>red_black_delete_fixup</code> 过程是如何修复这些问题的.</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">void</span> red_black_delete_fixup(tree_t <span class="subst">*</span>t, node_t <span class="subst">*</span>x) &#123;</span><br><span class="line">	node_t <span class="subst">*</span>w;</span><br><span class="line">	<span class="keyword">while</span> (x <span class="subst">!=</span> tree<span class="subst">-&gt;</span>root <span class="subst">&amp;&amp;</span> x<span class="subst">-&gt;</span>color <span class="subst">==</span> BLACK) &#123;</span><br><span class="line">		<span class="keyword">if</span> (x <span class="subst">==</span> x<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span>left) &#123;</span><br><span class="line">			w <span class="subst">=</span> x<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span>right;</span><br><span class="line">			<span class="keyword">if</span> (w<span class="subst">-&gt;</span>color <span class="subst">==</span> RED) &#123;</span><br><span class="line">				w<span class="subst">-&gt;</span>color <span class="subst">=</span> BLACK;</span><br><span class="line">				x<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span>color <span class="subst">=</span> RED;</span><br><span class="line">				left_rotate(tree, x<span class="subst">-&gt;</span><span class="keyword">parent</span>);</span><br><span class="line">				w <span class="subst">=</span> x<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span>right;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (w<span class="subst">-&gt;</span>left<span class="subst">-&gt;</span>color <span class="subst">==</span> BLACK <span class="subst">&amp;&amp;</span> w<span class="subst">-&gt;</span>right<span class="subst">-&gt;</span>color <span class="subst">==</span> BLACK) &#123;</span><br><span class="line">				w<span class="subst">-&gt;</span>color <span class="subst">=</span> RED;</span><br><span class="line">				x <span class="subst">=</span> x<span class="subst">-&gt;</span><span class="keyword">parent</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (w<span class="subst">-&gt;</span>right<span class="subst">-&gt;</span>color <span class="subst">==</span> BLACK) &#123;</span><br><span class="line">				w<span class="subst">-&gt;</span>left<span class="subst">-&gt;</span>color <span class="subst">=</span> BLACK;</span><br><span class="line">				w<span class="subst">-&gt;</span>color <span class="subst">=</span> RED;</span><br><span class="line">				right_rotate(tree, w);</span><br><span class="line">				w <span class="subst">=</span> x<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span>right;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				w<span class="subst">-&gt;</span>color <span class="subst">=</span> x<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span>color;</span><br><span class="line">				x<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span>color <span class="subst">=</span> BLACK;</span><br><span class="line">				w<span class="subst">-&gt;</span>right<span class="subst">-&gt;</span>color <span class="subst">=</span> BLACK;</span><br><span class="line">				left_rotate(tree, x<span class="subst">-&gt;</span><span class="keyword">parent</span>);</span><br><span class="line">				x <span class="subst">=</span> tree<span class="subst">-&gt;</span>root;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			w <span class="subst">=</span> x<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span>left;</span><br><span class="line">			<span class="keyword">if</span> (w<span class="subst">-&gt;</span>color <span class="subst">=</span> RED) &#123;</span><br><span class="line">				w<span class="subst">-&gt;</span>color <span class="subst">=</span> BLACK;</span><br><span class="line">				x<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span>color <span class="subst">=</span> RED;</span><br><span class="line">				right_rotate(tree, x<span class="subst">-&gt;</span><span class="keyword">parent</span>);</span><br><span class="line">				w <span class="subst">=</span> x<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span>left;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (w<span class="subst">-&gt;</span>right<span class="subst">-&gt;</span>color <span class="subst">==</span> BLACK <span class="subst">&amp;&amp;</span> w<span class="subst">-&gt;</span>left<span class="subst">-&gt;</span>color <span class="subst">==</span> BLACK) &#123;</span><br><span class="line">				w<span class="subst">-&gt;</span>color <span class="subst">=</span> RED;</span><br><span class="line">				x <span class="subst">=</span> x<span class="subst">-&gt;</span><span class="keyword">parent</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (w<span class="subst">-&gt;</span>left<span class="subst">-&gt;</span>color <span class="subst">==</span> BLACK) &#123;</span><br><span class="line">				w<span class="subst">-&gt;</span>left<span class="subst">-&gt;</span>color <span class="subst">=</span> BLACK;</span><br><span class="line">				w<span class="subst">-&gt;</span>color <span class="subst">=</span> RED;</span><br><span class="line">				left_rotate(tree, w);</span><br><span class="line">				w <span class="subst">=</span> x<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span>left;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				w<span class="subst">-&gt;</span>color <span class="subst">=</span> x<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span>color;</span><br><span class="line">				x<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span>color <span class="subst">=</span> BLACK;</span><br><span class="line">				right_rotate(tree, x<span class="subst">-&gt;</span><span class="keyword">parent</span>);</span><br><span class="line">				x <span class="subst">=</span> tree<span class="subst">-&gt;</span>root;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	x<span class="subst">-&gt;</span>color <span class="subst">=</span> BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图中给出了代码中的 4 种情况.</p>
<p><img src="http://deltax.qiniudn.com/delete-fixup.png?attname=&e=1428493402&token=YJb_IPQrTSw1ox9LenQDH1HRcgHii9w_bp9ddmcz:6X-9kEiOv1tpwgcBf2Pqk9qZgYY" style="display:block;margin:auto;"></p>
<h3 id="情况1-1">情况1</h3><p><code>x</code> 的兄弟结点 <code>w</code> 是红色的.</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">w<span class="subst">-&gt;</span>color <span class="subst">=</span> BLACK;</span><br><span class="line">x<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span>color <span class="subst">=</span> RED;</span><br><span class="line">left_rotate(tree, x<span class="subst">-&gt;</span><span class="keyword">parent</span>);</span><br><span class="line">w <span class="subst">=</span> x<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span>right;</span><br></pre></td></tr></table></figure>
<h3 id="情况2-1">情况2</h3><p><code>x</code> 的兄弟结点 <code>w</code> 是黑色的, 而且 <code>w</code> 的两个子节点都是黑色的.</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">w<span class="subst">-&gt;</span>color <span class="subst">=</span> RED;</span><br><span class="line">x <span class="subst">=</span> x<span class="subst">-&gt;</span><span class="keyword">parent</span>;</span><br></pre></td></tr></table></figure>
<h3 id="情况3-1">情况3</h3><p><code>x</code> 的兄弟结点 <code>w</code> 是黑色的, <code>w</code> 的左子结点是红色的, 右子结点是黑色的.</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">w<span class="subst">-&gt;</span>left<span class="subst">-&gt;</span>color <span class="subst">=</span> BLACK;</span><br><span class="line">w<span class="subst">-&gt;</span>color <span class="subst">=</span> RED;</span><br><span class="line">right_rotate(tree, w);</span><br><span class="line">w <span class="subst">=</span> x<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span>right;</span><br></pre></td></tr></table></figure>
<h3 id="情况4">情况4</h3><p><code>x</code> 的兄弟结点 <code>w</code> 是黑色的, <code>w</code> 右子结点是红色的.</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">w<span class="subst">-&gt;</span>color <span class="subst">=</span> x<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span>color;</span><br><span class="line">x<span class="subst">-&gt;</span><span class="keyword">parent</span><span class="subst">-&gt;</span>color <span class="subst">=</span> BLACK;</span><br><span class="line">w<span class="subst">-&gt;</span>right<span class="subst">-&gt;</span>color <span class="subst">=</span> BLACK;</span><br><span class="line">left_rotate(tree, x<span class="subst">-&gt;</span><span class="keyword">parent</span>);</span><br><span class="line">x <span class="subst">=</span> tree<span class="subst">-&gt;</span>root;</span><br></pre></td></tr></table></figure>
<h3 id="分析">分析</h3><p><code>red_black_delete</code> 的运行时间如何呢, 因为含有 $n$ 的结点的红黑树的高度为 $O(\lg n)$, 不调用 <code>red_black_delete_fixup</code> 的总时间代价为 $O(\lg n)$, 在 <code>red_black_delete_fixup</code> 中, 情况 1 3 4 中, 最多执行常熟次数的颜色改变, 并且最多 3 次旋转之后便停止, 情况 2 中是可以多次执行的, 但是指针沿树最多上升 $O(\lg n)$ 次, 且不执行任何旋转. 所以 <code>red_black_delete</code> 的运行时间最多为 $O(\lg n)$.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>红黑树是一棵二叉搜索树, 它在每个结点上增加了一个存储位来表示结点的颜色, 可以使 <code>RED</code> 或 <code>BLACK</code>. 红黑树中没有一条路径会比其他路径长出 2 倍, 所以是近似平衡的.</p>
<p>树中的每个结点包含 5 个属性]]>
    </summary>
    
      <category term="Algorithm" scheme="http://deltax.me/tags/Algorithm/"/>
    
      <category term="C" scheme="http://deltax.me/tags/C/"/>
    
      <category term="clrs" scheme="http://deltax.me/categories/clrs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[二叉搜索树]]></title>
    <link href="http://deltax.me/2015/04/06/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>http://deltax.me/2015/04/06/二叉搜索树/</id>
    <published>2015-04-06T07:46:57.000Z</published>
    <updated>2015-04-06T15:31:45.000Z</updated>
    <content type="html"><![CDATA[<p>二叉搜索树是以一棵二叉树来组织的, 其中每一个结点都是一个对象, 每个结点都包含属性 <code>left</code> <code>right</code> 和 <code>p</code>, 它们分别指向结点的 left child, right child 和 parent. 如果某个 child 结点不存在, 那么相应的属性就为 <code>nil</code>.</p>
<p>二叉搜索树中的关键字的总是以满足二叉树性质的方式来存储:</p>
<blockquote>
<p>其中对于任何一个结点, left child 中存储的数据都不会大于 parent, right child 中存储的数据都不会小于 parent.</p>
</blockquote>
<p><img src="http://deltax.qiniudn.com/search-tree.png?attname=&e=1428393319&token=YJb_IPQrTSw1ox9LenQDH1HRcgHii9w_bp9ddmcz:azaCzptdMV5SJJ7lsDzPvSzTCI0" style="display:block;margin:auto"></p>
<p>我们先来实现一下树的数据结构:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span></span></span><br><span class="line">	<span class="keyword">attr_accessor</span> <span class="symbol">:root</span>, <span class="symbol">:left</span>, <span class="symbol">:right</span>, <span class="symbol">:parent</span>, <span class="symbol">:key</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> </span>initialize</span><br><span class="line">		<span class="variable">@left</span> = <span class="keyword">nil</span></span><br><span class="line">		<span class="variable">@right</span> = <span class="keyword">nil</span></span><br><span class="line">		<span class="variable">@parent</span> = <span class="keyword">nil</span></span><br><span class="line">		<span class="variable">@key</span> = <span class="keyword">nil</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="Traverse">Traverse</h2><p>二叉搜索树性质允许我们通过一个简单的递归算法来按序输出二叉搜索树中的所有关键字, 这种算法称为<strong>中序遍历</strong>, 这样的命名是因为输出的 root 的关键字位于其 left child 和 right child 之间. 类似地, 我们有<strong>先序遍历</strong>和<strong>后序遍历</strong>.</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def inorder_tree_walk(<span class="built_in">tree</span>)</span><br><span class="line">	<span class="flow">if</span> <span class="built_in">tree</span> != nil</span><br><span class="line">		inorder_tree_walk(<span class="built_in">tree</span>.left)</span><br><span class="line">		puts <span class="built_in">tree</span>.key</span><br><span class="line">		inorder_tree_walk(<span class="built_in">tree</span>.right)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">def preorder_tree_walk(<span class="built_in">tree</span>)</span><br><span class="line">	<span class="flow">if</span> <span class="built_in">tree</span> != nil</span><br><span class="line">		puts <span class="built_in">tree</span>.key</span><br><span class="line">		preorder_tree_walk(<span class="built_in">tree</span>.left)</span><br><span class="line">		preorder_tree_walk(<span class="built_in">tree</span>.right)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">def postorder_tree_walk(<span class="built_in">tree</span>)</span><br><span class="line">	<span class="flow">if</span> <span class="built_in">tree</span> != nil</span><br><span class="line">		postorder_tree_walk(<span class="built_in">tree</span>.left)</span><br><span class="line">		postorder_tree_walk(<span class="built_in">tree</span>.right)</span><br><span class="line">		puts <span class="built_in">tree</span>.key</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>遍历一棵 $n$ 个结点的二叉搜索树, 需要耗费 $\Theta(n)$ 的时间, 因为在第一次调用之后, 每个结点还要调用自己两次, 分别是 left 和 right child.</p>
<h2 id="Query">Query</h2><p>我们经常需要查找存在二叉搜索树中的关键字. 我们不仅需要支持 <code>SEARCH</code> 操作之外, 二叉搜索树还能支持还能支持诸如 <code>MINIMUM</code> <code>MAXIMUM</code> <code>SUCCESSOR</code> <code>PREDECESSOR</code> 的查询操作. 并且这些操作都能在 $O(h)$ 时间内完成.</p>
<h3 id="Search">Search</h3><p>查找操作非常的简单, 我们接下来用 Ruby 实现查找操作.</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def tree_search(tree, <span class="keyword">key</span>)</span><br><span class="line">	<span class="keyword">if</span> tree == nil <span class="keyword">or</span> <span class="keyword">key</span> == tree.<span class="keyword">key</span></span><br><span class="line">		<span class="keyword">return</span> tree</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">key</span> &lt; tree.<span class="keyword">key</span></span><br><span class="line">		<span class="keyword">return</span> tree_search(tree.left, <span class="keyword">key</span>)</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> tree_search(tree.right, <span class="keyword">key</span>)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这个过程从 root 开始查找, 并沿着树中的一条简单的路径向下进行. 不断与 tree.key 比较, 选择最合适的路径.</p>
<p>我们也可以使用循环来解决我们的问题, 不过在这里我们不在演示了.</p>
<h3 id="Minimum_Maximum">Minimum Maximum</h3><p>二叉搜索树的最大关键字和最小关键字的查找十分的简单, 我们这里直接给出 Ruby 的实现代码.</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def tree_minimum(<span class="built_in">tree</span>)</span><br><span class="line">	<span class="flow">if</span> <span class="built_in">tree</span>.left != nil</span><br><span class="line">		tree_minimum(<span class="built_in">tree</span>.left)</span><br><span class="line">	<span class="flow">else</span></span><br><span class="line">		<span class="built_in">tree</span></span><br><span class="line">	end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">def tree_maximum(<span class="built_in">tree</span>)</span><br><span class="line">	<span class="flow">if</span> <span class="built_in">tree</span>.left != nil</span><br><span class="line">		tree_maximum(<span class="built_in">tree</span>.left)</span><br><span class="line">	<span class="flow">else</span></span><br><span class="line">		<span class="built_in">tree</span></span><br><span class="line">	end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>这两个过程在一棵高度为 $h$ 的树上均能在 $O(h)$ 时间内执行玩, 所遇到的结点均形成了一条从 root 向下的简单路径.</p>
<h3 id="Successor_Predecessor">Successor Predecessor</h3><p>给定一棵二叉搜索树中的一个结点, 有时候需要按照中序遍历的次序查找它的后继:</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def tree_successor(tree)</span><br><span class="line">	<span class="keyword">return</span> tree_successor <span class="keyword">if</span> tree<span class="built_in">.</span>right <span class="subst">!=</span> nil</span><br><span class="line">	<span class="keyword">parent</span> <span class="subst">=</span> tree<span class="built_in">.</span><span class="keyword">parent</span></span><br><span class="line">	whlie <span class="keyword">parent</span> <span class="subst">!=</span> nil <span class="literal">and</span> tree <span class="subst">==</span> <span class="keyword">parent</span><span class="built_in">.</span>right</span><br><span class="line">		tree <span class="subst">=</span> <span class="keyword">parent</span></span><br><span class="line">		<span class="keyword">parent</span> <span class="subst">=</span> <span class="keyword">parent</span><span class="built_in">.</span><span class="keyword">parent</span></span><br><span class="line">	end</span><br><span class="line">	<span class="keyword">parent</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>我们把 <code>tree_successor</code> 的伪代码分成两个部分</p>
<ul>
<li>如果结点的 right child 非空, 那么结点的 successor 就是结点 right child 中的最左结点.</li>
<li>如果结点的 right child 为空, 那么它的后继就是该结点最底层的 parent.</li>
</ul>
<p>同理, 查找树的 predecessor 的代码如下:</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def tree_predecessor(tree)</span><br><span class="line">	<span class="keyword">return</span> tree_predecessor <span class="keyword">if</span> tree<span class="built_in">.</span>left <span class="subst">!=</span> nil</span><br><span class="line">	<span class="keyword">parent</span> <span class="subst">=</span> tree<span class="built_in">.</span><span class="keyword">parent</span></span><br><span class="line">	whlie <span class="keyword">parent</span> <span class="subst">!=</span> nil <span class="literal">and</span> tree <span class="subst">==</span> <span class="keyword">parent</span><span class="built_in">.</span>left</span><br><span class="line">		tree <span class="subst">=</span> <span class="keyword">parent</span></span><br><span class="line">		<span class="keyword">parent</span> <span class="subst">=</span> <span class="keyword">parent</span><span class="built_in">.</span><span class="keyword">parent</span></span><br><span class="line">	end</span><br><span class="line">	<span class="keyword">parent</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h2 id="Insert_and_Delete">Insert and Delete</h2><p>插入和删除的操作会导致二叉搜索树表示的动态集合的变化, 一定要修改数据结构来反映这个变化, 但修改要保持二叉搜索树性质的成立.</p>
<h3 id="Insert">Insert</h3><p>要将一个新的值 $v$ 插入到一棵二叉搜索树 $T$ 中, 需要调用一下过程 <code>tree-insert</code>. </p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def tree_insert(tree,z)</span><br><span class="line">	y = nil</span><br><span class="line">	x = tree</span><br><span class="line">	<span class="keyword">while</span> tree != nil</span><br><span class="line">		y = tree</span><br><span class="line">		<span class="keyword">if</span> tree.key &lt; x.key</span><br><span class="line">			tree = tree.left</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			tree = tree.<span class="constant">right</span></span><br><span class="line">		<span class="function"><span class="keyword">end</span></span></span><br><span class="line">	<span class="function"><span class="keyword">end</span></span></span><br><span class="line">	z.parent = y</span><br><span class="line">	<span class="keyword">if</span> y == nil</span><br><span class="line">		tree = z</span><br><span class="line">	elsif z.key &lt; y.key</span><br><span class="line">		y.left = z</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		y.<span class="constant">right</span> = z</span><br><span class="line">	<span class="function"><span class="keyword">end</span></span></span><br><span class="line"><span class="function"><span class="keyword">end</span></span></span><br></pre></td></tr></table></figure>
<p>该过程在高度为 $h$ 的二叉搜索树上的运行时间为 $O(h)$.</p>
<h3 id="Delete">Delete</h3><p>从一个二叉搜索树 $T$ 中删除一个结点 $z$ 的整个策略分为三中基本情况</p>
<ul>
<li>如果 $z$ 没有子节点, 那么只是简单地将它删除, 并将它的父结点置为 <code>nil</code>.</li>
<li>如果 $z$ 只有一个子节点, 那么直接将子节点提升到 $z$ 的位置, 并修改 $z$ 的父结点, 用子节点来代替.</li>
<li>如果 $z$ 有两个子节点, 那么找 $z$ 的后继 $y$, 并让 $y$ 占据树中 $z$ 的位置. $z$. $z$ 的原右子树部分成为 $y$ 的新的右子树, $z$ 的原左子树部分成为 $y$ 的新的左子树.<ul>
<li>如果 $y$ 是 $z$ 的 right child, 那么直接用 $y$ 替换 $z$, 并留下 $y$ 的 right child.</li>
<li>否则, $y$ 位于右子树中, 但并不是 $z$ 的 right child, 先用 $y$ 的 right child 替换 $y$, 然后再用 $y$ 替换 $z$.</li>
</ul>
</li>
</ul>
<p><img src="http://deltax.qiniudn.com/delete-binary-tree.png?attname=&e=1428419679&token=YJb_IPQrTSw1ox9LenQDH1HRcgHii9w_bp9ddmcz:uJFRzAVs3zXywADKNRUrZmfItl4" style="display:block;margin:auto"></p>
<p>为了在二叉搜索树内移动子树, 定义了一个子过程 <code>tranplant</code>, 它用另一棵子树替换一棵子树并成为其双亲的子节点.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> </span>transplant(tree, u, v)</span><br><span class="line">	<span class="keyword">if</span> u.parent == <span class="keyword">nil</span></span><br><span class="line">		tree.root = v</span><br><span class="line">	<span class="keyword">elsif</span> u == u.parent.left</span><br><span class="line">		u.parent.left = v</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		u.parent.right = v</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">if</span> v != <span class="keyword">nil</span></span><br><span class="line">		v.parent = u.parent</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>利用线程的 <code>transplant</code> 过程, 下面是从二叉树中删除结点 $z$ 的删除过程.</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def tree_delete(tree,z)</span><br><span class="line">	<span class="keyword">if</span> z.<span class="built_in">left</span> = nil</span><br><span class="line">		transplant(tree, z, z.<span class="built_in">right</span>)</span><br><span class="line">	elsif z.<span class="built_in">right</span> = nil</span><br><span class="line">		transplant(tree, z, z.<span class="built_in">left</span>)</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		y = tree_minimum(z.<span class="built_in">right</span>)</span><br><span class="line">		<span class="keyword">if</span> y.parent != z</span><br><span class="line">			transplant(tree, y, y.<span class="built_in">right</span>)</span><br><span class="line">			y.<span class="built_in">right</span> = z.<span class="built_in">right</span></span><br><span class="line">			y.<span class="built_in">right</span>.parent = y</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		transplant(tree, z, y)</span><br><span class="line">		y.<span class="built_in">left</span> = z.<span class="built_in">left</span></span><br><span class="line">		y.<span class="built_in">left</span>.parent = y</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在一棵高度为 $h$ 的树上, 事项动态集合操作 <code>INSERT</code> 和 <code>DELETE</code> 的运行时间均为 $O(h)$.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>二叉搜索树是以一棵二叉树来组织的, 其中每一个结点都是一个对象, 每个结点都包含属性 <code>left</code> <code>right</code> 和 <code>p</code>, 它们分别指向结点的 left child, right child 和 par]]>
    </summary>
    
      <category term="Algorithm" scheme="http://deltax.me/tags/Algorithm/"/>
    
      <category term="Ruby" scheme="http://deltax.me/tags/Ruby/"/>
    
      <category term="clrs" scheme="http://deltax.me/categories/clrs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Prolog 基础 <1>]]></title>
    <link href="http://deltax.me/2015/04/05/Prolog-%E5%9F%BA%E7%A1%80-1/"/>
    <id>http://deltax.me/2015/04/05/Prolog-基础-1/</id>
    <published>2015-04-05T03:45:30.000Z</published>
    <updated>2015-04-05T06:45:42.000Z</updated>
    <content type="html"><![CDATA[<h2 id="为什么学习_Prolog?">为什么学习 Prolog?</h2><p><a href="http://zh.wikipedia.org/zh/Prolog" target="_blank" rel="external">Prolog</a> 是种逻辑式的编程语言. 我第一次见到这个名字的时候大约实在我学习 SICP 的过程中, 实现了一个简单的逻辑式语言的解释器. 之后我又在 CTMCP 一书中的 Relational Programming 和 Logical Programming 中多次见到 Prolog 的身影, 加上我本身对于各种编程语言非常地感兴趣, 所以我选择学习这门语言, 在这里记录一下我的学习的进度和经历, 也希望能为别人学习 Prolog 提供一下微不足道的帮助吧.</p>
<h2 id="书籍的选择">书籍的选择</h2><p>在选择学习一门新的编程语言之后, 第一件事情是上网查询一些资料因为 Prolog 的使用者极少, 所以资料也非常的难以查找, 我一开始想要使用的是 Prolog by Example, 但是因为很难找到所以就选择了 Learn Prolog Now.</p>
<h2 id="开发环境的搭建">开发环境的搭建</h2><p>怎样才能快速的搭建 Prolog 的开发环境呢, 如果你是用的 Mac. 在命令行中输入</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew cask <span class="keyword">install</span> swi-prolog</span><br></pre></td></tr></table></figure>
<p>如果没有装 brew 或者 cask, 可以在 google 上轻松找到这两个命令行工具的安装方法. 在这里我也就不在多说了.</p>
<p>我是用的编辑器是 Emacs, 使用的插件可以点<a href="http://bruda.ca/emacs/prolog_mode_for_emacs" target="_blank" rel="external">这里</a>. 安装好之后, 我们就可以开始 Prolog 之旅了.</p>
<h2 id="Prolog_基础">Prolog 基础</h2><p>Prolog 有三种非常基本结构:</p>
<ul>
<li>事实(facts)</li>
<li>规则(rules)</li>
<li>查询(queries)</li>
</ul>
<p>事实和规则被叫做 knowledge base 或者叫 database, Prolog 的编程其实就是写 knowledge base, 这些 knowledge base 就定义和保存了我们感兴趣的全部知识. 我们如何使用一个 Prolog 程序呢? 就是发起查询, 就是通过向 knowledge base 中存储的数据提出问题, 然后获取回答. 这与我们平时的使用 Objective-C Java 等命令式编程有着极大的不同.</p>
<h3 id="Facts">Facts</h3><p>首先我们先写下几个 Prolog 中的 facts, 需要打开一个文件, 后缀是 <code>.pl</code>.</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">programmer</span><span class="params">(linux)</span></span>.</span><br><span class="line"><span class="function"><span class="title">programmer</span><span class="params">(bill)</span></span>.</span><br><span class="line"><span class="function"><span class="title">designer</span><span class="params">(jonathan)</span></span>.</span><br></pre></td></tr></table></figure>
<p>这个文件 <code>facts.pl</code> 就是一些 facts 的集合, 注意, 在这里的每一个 fact 都是以 <code>.</code> 结尾的. 我们怎么使用呢, 在命令行中切换到 <code>facts.pl</code> 的目录下, 然后输入 <code>swipl</code>.</p>
<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Welcome <span class="keyword">to</span> SWI-Prolog (Multi-threaded, <span class="number">64</span> bits, Version <span class="number">6.6</span><span class="number">.6</span>)</span><br><span class="line">Copyright (c) <span class="number">1990</span>-<span class="number">2013</span> University <span class="keyword">of</span> Amsterdam, VU Amsterdam</span><br><span class="line">SWI-Prolog comes <span class="keyword">with</span> ABSOLUTELY NO WARRANTY. This <span class="keyword">is</span> free software,</span><br><span class="line"><span class="keyword">and</span> you are welcome <span class="keyword">to</span> redistribute it under certain conditions.</span><br><span class="line">Please visit http://www.swi-prolog.org <span class="keyword">for</span> details.</span><br><span class="line"></span><br><span class="line"><span class="keyword">For</span> help, <span class="keyword">use</span> ?- help(Topic). <span class="keyword">or</span> ?- apropos(Word).</span><br><span class="line"></span><br><span class="line">?-</span><br></pre></td></tr></table></figure>
<p>然后会出现这些信息, 使用 <code>consult(&#39;fact.pl&#39;).</code> 加载你的 Prolog 代码. 输入: programmer(linux).</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?- programmer(linux).</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>Prolog 会返回 <code>true</code>. 如果你输入: programmer(jonathan).</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?- programmer(jonathan).</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>它就会返回 <code>false</code>. 很简单吧.</p>
<p>当然 facts 也可以是向下面这样有多个参数</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">loves</span><span class="params">(i,u)</span></span>.</span><br><span class="line"><span class="function"><span class="title">loves</span><span class="params">(he,u)</span></span>.</span><br></pre></td></tr></table></figure>
<p>如果你输入一个不存在过程, 它就会告诉你 <code>Undefined procedure</code>.</p>
<h3 id="Rules">Rules</h3><p>接下来我们介绍一下什么是规则 rules, 规则我们理解起来非常的容易, 在 Prolog 中如何实现一些规则呢, 我们使用 <code>:-</code>.</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">sunny</span><span class="params">(today)</span></span>.</span><br><span class="line"><span class="function"><span class="title">happy</span><span class="params">(tom)</span></span>.</span><br><span class="line"><span class="function"><span class="title">football</span><span class="params">(tom)</span></span> :- <span class="function"><span class="title">sunny</span><span class="params">(today)</span></span>,<span class="function"><span class="title">happy</span><span class="params">(tom)</span></span>.</span><br></pre></td></tr></table></figure>
<p>接下来我们加载我们的代码, 询问 <code>football(tom)</code>. Prolog 会返回 <code>true</code>, 规则是什么呢, 规则的前半部分也就是 <code>football(tom)</code> 是规则的头部(head), 规则的后半部分 <code>sunny(today),happy(tom)</code> 是规则的目标(goals). 当规则的 goals 成立时, head 就会成立也就是:</p>
<p><strong>如果今天的天气很好, tom 也很开心, 那么他就会去踢足球.</strong></p>
<p>Prolog 使用 <code>,</code> 来表示 <strong>和</strong>, 使用 <code>;</code> 来表示 <strong>或</strong>. 所以在这里, 后面的两个条件都需要成立. 这样 Prolog 就能推出 <code>football(tom)</code>.</p>
<p>我们可以在 Rules 中添加变量增强我们的表达能力, 比如这样:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">father</span><span class="params">(tom,john)</span></span>.</span><br><span class="line"><span class="function"><span class="title">father</span><span class="params">(john,ive)</span></span>.</span><br><span class="line"><span class="function"><span class="title">grandfather</span><span class="params">(X,Z)</span></span>:-<span class="function"><span class="title">father</span><span class="params">(X,Y)</span></span>,<span class="function"><span class="title">father</span><span class="params">(Y,Z)</span></span>.</span><br></pre></td></tr></table></figure>
<p>我相信这对于我们是非常容易理解的, 在这里也不过多说明了.</p>
<h3 id="Queries">Queries</h3><p>什么是 queries, 其实我们在上边输入的 <code>football(tom).</code>, <code>programmer(jonathan).</code> 都是一种查询. 只是查询是否成立, 接下来我们就需要在查询中引入变量(variable)了.</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">programmer</span><span class="params">(linux)</span></span>.</span><br><span class="line"><span class="function"><span class="title">programmer</span><span class="params">(bill)</span></span>.</span><br><span class="line"><span class="function"><span class="title">designer</span><span class="params">(jonathan)</span></span>.</span><br></pre></td></tr></table></figure>
<p>还是这一段代码, 我们可以通过询问 Prolog:</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?- programmer(<span class="variable">X</span>).</span><br></pre></td></tr></table></figure>
<p>然后就会出现</p>
<figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">X </span>=<span class="string"> linux</span></span><br></pre></td></tr></table></figure>
<p>Prolog 每次只会出现最先符合条件的结果, 若果你想看其他的结果, 可以输入 <code>;</code> 也就是或, 来查看是否有其他的输入, 我们输入 <code>;</code> 之后, 会出现:</p>
<figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">X </span>=<span class="string"> bill</span></span><br></pre></td></tr></table></figure>
<p>再次输入之后, 就会返回 <code>false</code> 了, 因为没有符合条件的结果了.</p>
<h2 id="Prolog_语法">Prolog 语法</h2><p>介绍了 Prolog 中的基本元素之后, 我们想要知道, Prolog 中的基本元素到底是由什么来构建的呢, 现在来看一下 Prolog 中的基本语法.</p>
<p>Prolog 中的基本元素都是 term(<em>不知道该怎么翻译</em>)构建而来的. 而在 Prolog 中有 4 种不同的 term</p>
<ul>
<li>atom</li>
<li>number</li>
<li>variable</li>
<li>complex term</li>
</ul>
<h3 id="Atom">Atom</h3><p>符合下列条件之一的就是 Prolog 中的 atom:</p>
<ol>
<li>由大写字母, 小写字符, 数字和下划线组成的并且<strong>以小写字母开头</strong>的字符串, 例如: <code>john</code> <code>tom</code> <code>big_big</code> <code>a_bc</code>.</li>
<li>任意的包装在单引号 <code>&#39;</code> 中的字符床. 例如: <code>&#39;dsada&#39;</code> <code>*((&amp;@!MBAS))</code> <code>Fjdh_da</code>.</li>
<li>特殊的字符串, 比如 <code>:-</code> <code>;</code> <code>@=</code>.</li>
</ol>
<h3 id="Numbers">Numbers</h3><p>数字在 Prolog 中并不是非常的重要, 不过 Prolog 支持大多数的数字的表示和特殊的值.</p>
<h3 id="Variables">Variables</h3><p>变量是由由大写字母, 小写字符, 数字和下划线组成的并且<strong>以大写字母或者下划线开头</strong>的字符串, 比如 <code>X</code> <code>Variable</code> <code>_dsal</code>. </p>
<p>变量 <code>_</code> 在 Prolog 中非常的特殊被称为匿名变量.</p>
<h3 id="Complex_Terms">Complex Terms</h3><p>Complex terms 实际上就是一种结构, 而我们之前见到的</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">programmer</span><span class="params">(linux)</span></span>.</span><br><span class="line"><span class="function"><span class="title">programmer</span><span class="params">(bill)</span></span>.</span><br><span class="line"><span class="function"><span class="title">designer</span><span class="params">(jonathan)</span></span>.</span><br></pre></td></tr></table></figure>
<p>这些都是 complex terms, 而且我们也可以定义出更加复杂的结构</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">father</span>(<span class="function">father</span>(<span class="function">fahter</span>(john))).</span><br></pre></td></tr></table></figure>
<p>complex term 拥有的参数的数量叫做 arity, arity 在 complex term 中及其的重要, <code>progammer(linux)</code> 中的 <code>arity = 1</code>, <code>love(i,u)</code> 中的 <code>arity = 2</code>.</p>
<p>在 Prolog 中可以定义两个名字相同, 而 arity 不同的 predicate.</p>
<p>当我们讨论到 predicate 时, 我们经常使用 <code>/</code> 后面跟着 <code>arity</code> 的数量来表示 predicate.</p>
<p>例如:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">happy/1</span><br><span class="line">love/2</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2><p>到目前为止, 我们已经对 Prolog 有着一个大体的了解, 也能感觉到它与其他编程语言的与众不同, 而这种不同就是驱使我学习它的最大因素.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="为什么学习_Prolog?">为什么学习 Prolog?</h2><p><a href="http://zh.wikipedia.org/zh/Prolog" target="_blank" rel="external">Prolog</a> 是种逻辑式的编程语言]]>
    </summary>
    
      <category term="Logical Programming" scheme="http://deltax.me/tags/Logical-Programming/"/>
    
      <category term="Prolog" scheme="http://deltax.me/tags/Prolog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[散列表]]></title>
    <link href="http://deltax.me/2015/04/04/%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    <id>http://deltax.me/2015/04/04/散列表/</id>
    <published>2015-04-04T08:33:49.000Z</published>
    <updated>2015-04-04T15:02:46.000Z</updated>
    <content type="html"><![CDATA[<p>散列表(hash table)是实现字典操作的一种有效的数据结构. 尽管在最坏情况下, 散列表中查找一个元素的时间与链表中查找的时间相同, 达到了 $\Theta(n)$. 然而在实际的应用中, 散列表的性能是极好的, 查找元素的平均时间是 $O(1)$.</p>
<h2 id="直接寻址表">直接寻址表</h2><p>当关键字的全域 $U$ 比较小的时候, 直接寻址是一种简单有效的技术. 为表示动态集合, 我们用一个数组, 或称为<strong>直接寻址表</strong>, 记为 $T[0..m-1]$ 其中每个位置称为<strong>槽</strong>(slot).</p>
<p><img src="http://deltax.qiniudn.com/direct-address.png?attname=&e=1428235532&token=YJb_IPQrTSw1ox9LenQDH1HRcgHii9w_bp9ddmcz:a-JMUZtykWnrKYcgnea7KzRKDlo" style="display:block;margin:auto"></p>
<p>如果该集合中没有关键字为 $k$ 的元素, 那么 $T[k]=nil$.</p>
<p>我们使用 Ruby 来实现我们直接寻址表的操作.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DirectAddressTable</span></span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> </span>initialize</span><br><span class="line">		<span class="variable">@table</span> = []</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> </span>search(k)</span><br><span class="line">		<span class="variable">@table</span>[k]</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> </span>insert(x)</span><br><span class="line">		<span class="variable">@table</span>[x.key] = x</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> </span>delete(x)</span><br><span class="line">		<span class="variable">@table</span>[x.key] = <span class="keyword">nil</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>直接寻址表本身就存放动态集合中的元素. 我们直接把对象存放在表的槽中, 节省了空间. 使用对象内的一个特殊关键字 <code>nil</code> 来表明槽为空. 因此我们如果知道一个对象在表中的下标就可以得到它的关键字. 因此如果不使用关键字, 我们就需要有一种方法来确定某个槽是否为空.</p>
<h2 id="散列表">散列表</h2><p>直接寻址技术的缺点是及其明显的, 如果全域 $U$ 很大, 那么存储大小为 $\left|U \right|$ 的一张表 $T$ 也许不太实际. 实际存储的关键字集合 $K$ 相对 $U$ 来说可能很小, 使得分配地空间会被浪费掉.</p>
<p>在直接寻址方式下, 具有关键字 $k$ 的元素被存放在槽 $k$ 中. 在散列方式下, 该元素存放在槽 $h(k)$ 中. 使用散列函数 $h$, 通过关键字 $k$ 计算出槽的位置. </p>
<p>函数 $h$ 将关键字的全域 $U$ 映射到<strong>散列表</strong> $T[0..m-1]$ 中的槽上:</p>
<p>$$h:U\rightarrow \big\{0,1,…,m-1 \big\}$$</p>
<p>一个具有关键字 $k$ 的元素被散列到槽 $h(k)$ 上, 也可以说 $h(k)$ 是关键字 $k$ 的<strong>散列值</strong>.</p>
<p><img src="http://deltax.qiniudn.com/hash.png?attname=&e=1428235532&token=YJb_IPQrTSw1ox9LenQDH1HRcgHii9w_bp9ddmcz:TAG52iH7Yp7YJhMG0aEyMH3_M1A" style="display:block;margin:auto"></p>
<p>这里可能存在一个问题: 两个关键字可能映射到同一个槽中, 我们称这种情形为<strong>冲突</strong>(collision). 我们接下来介绍两种方法解决这种冲突, 一种称为<strong>链接法</strong>, 一种称为<strong>开放寻址法</strong>.</p>
<h3 id="链接法">链接法</h3><p>链接法非常地简单, 只需要把 hash 到同一槽中的元素放到同一个链表中, 槽中有一个指针会指向链表的开头, 如果不存在则为 <code>nil</code>.</p>
<p><img src="http://deltax.qiniudn.com/chaining-hash.png?attname=&e=1428237885&token=YJb_IPQrTSw1ox9LenQDH1HRcgHii9w_bp9ddmcz:Mi4Zu4awW1VX2A2y7DIoNYLYPQo" style="display:block;margin:auto"></p>
<p>使用链接法后, 散列表中的操作就很容易实现了:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class ChainedHashTable</span><br><span class="line">	</span><br><span class="line">	def initialize</span><br><span class="line">		@table = []</span><br><span class="line">	<span class="operator"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	def <span class="keyword">insert</span>(x)</span><br><span class="line">		<span class="keyword">if</span> @<span class="keyword">table</span>[x.<span class="keyword">key</span>.hash]</span><br><span class="line">			@<span class="keyword">table</span>[x.<span class="keyword">key</span>.hash] &lt;&lt; x</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			@<span class="keyword">table</span>[x.<span class="keyword">key</span>.hash] = [x]</span><br><span class="line">		<span class="keyword">end</span>	</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	def search(k)</span><br><span class="line">		@<span class="keyword">table</span>[k.hash].<span class="keyword">each</span> <span class="keyword">do</span> |<span class="keyword">key</span>|</span><br><span class="line">			<span class="keyword">if</span> <span class="keyword">key</span> == k</span><br><span class="line">				<span class="keyword">return</span> k</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	def <span class="keyword">delete</span>(x)</span><br><span class="line">		@<span class="keyword">table</span>[x.<span class="keyword">key</span>.hash].<span class="keyword">delete</span>(x)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span></span><br></pre></td></tr></table></figure>
<p>插入操作的最坏情况的运行时间为 $O(1)$. 查找操作的最坏情况运行时间与表的长度成正比. 如果散列表中的链表是双向链接的, 则删除一个元素 $x$ 的操作可以在 $O(1)$ 时间内完成.</p>
<p>给定一个能存放 $n$ 个元素的, 具有 $m$ 个槽位的散列表 $T$, 定义 $T$ 的<strong>装载因子</strong> $\alpha$ 为 $n/m$, 即一个链的平均存储元素数, $\alpha$ 可以小于等于或大于 $1$. 散列方法的平均性能依赖于使用的散列函数 $h$, 将所有的关键字集合分不在 $m$ 个槽位上的均匀程度.</p>
<p>在简单均匀散列的假设下, 对于用链接法解决冲突的散列表, 一次不成功查找的平均时间为 $\Theta(1+\alpha)$.</p>
<h3 id="开放寻址法">开放寻址法</h3><p>在开放寻址法中, 所有的元素都存放在散列表里, 也就是说, 每一个表项或包含动态集合的宇哥元素, 或包含 <code>NIL</code>. 查找某个元素时, 要系统地检查所有的表项, 知道找到所需的元素, 或者最终查明该元素不在表中.</p>
<p>开放寻址法中的散列表可能会被填满, 以至于不能插入任何的新元素. 所以装在因子 $\alpha \leq 1$.</p>
<p>为了使用开发寻址法插入一个元素, 需要连续地检查散列表, 或称为<strong>探查</strong>(probe). 知道找到一个空的槽来插入关键字为止, 探查的顺序不一定是 $0,1,…,m-1$, 而是要依赖于待插入的关键字. 使之包含探查号作为第二个输入参数, 我们的散列函数就变为:</p>
<p>$$h: U \times \big\{ 0,1,…,,-1 \big\}  \rightarrow  \big\{ 0,1,…,,-1 \big\}$$</p>
<p>对没一个关键字 $k$, 使用开放寻址法的探查序列</p>
<p>$$ \big \langle h(k,0),h(k,1),…,h(k,m-1) \big \rangle$$</p>
<p>这样的散列序列的排列, 使得当散列表逐渐填满时, 每一个表位最终都可以被考虑为用来插入新关键字的槽.</p>
<p>当向散列表中插入数据时, 我们使用如下的过程:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenAddressHashTable</span></span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> </span>initialize(max)</span><br><span class="line">		<span class="variable">@max</span> = max</span><br><span class="line">		<span class="variable">@table</span> = []</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> </span>insert(k)</span><br><span class="line">		i = <span class="number">0</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">until</span> i == m</span><br><span class="line">			j = k.hash(i)</span><br><span class="line">			<span class="keyword">if</span> <span class="variable">@table</span>[j] == <span class="keyword">nil</span></span><br><span class="line">				<span class="variable">@table</span>[j] = k</span><br><span class="line">				<span class="keyword">return</span> j</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				i = i + <span class="number">1</span></span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		</span><br><span class="line">		raise <span class="string">"Hash table overflow!"</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> </span>search(k)</span><br><span class="line">		i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">until</span> <span class="variable">@table</span>[j] == <span class="keyword">nil</span> || i == m</span><br><span class="line">			j = k.hash(i)</span><br><span class="line">			<span class="keyword">if</span> <span class="variable">@table</span>[j] == <span class="keyword">nil</span></span><br><span class="line">				<span class="keyword">return</span> j</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			i = i + <span class="number">1</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">nil</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>查找关键字 $k$ 的算法探查序列与将 $k$ 插入时的算法相同.</p>
<p>从开放寻址法的散列表中删除操作元素比较困难, 因为不能直接将其设置为 <code>nil</code> 标识它为空. 如果这样做就会有问题, 就是在槽中置一个特定的值 <code>DELETED</code> 替代为 <code>NIL</code> 来标记该槽. 但是在必须删除关键字的应用中, 最常见的做法是使用链接法来解决冲突.</p>
<p>目前, 我们又三种技术来计算开放寻址法中的探查序列: 线性探查, 二次探查和双重探查. 在这里我们不会介绍.</p>
<h2 id="散列函数">散列函数</h2><p>在散列函数在使用中经常使用启发式方法来构造性能好的散列函数, 在这里我们只介绍两种启发式的方法, 除法散列表和乘法散列表.</p>
<h3 id="除法散列法">除法散列法</h3><p>在用来设计散列函数的除法散列表中, 通过取 $k$ 除以 $m$ 的余数, 讲关键字 $k$ 映射到 $m$ 个槽中的某一个, 即散列函数为:</p>
<p>$$h(k)=k \mod m$$</p>
<p>当应用除法散列法时, 要避免选择 $m$ 的某些值, 不应为 $2$ 的幂, 或者 $10$ 的幂. 一个不太接近 $2$ 的整数幂的素数是一个比较好的选择.</p>
<h3 id="乘法散列法">乘法散列法</h3><p>构造散列函数的乘法的散列法包含两个步骤. 第一步, 用关键字 $k$ 乘上常熟 $A(0 \le A \le 1)$, 并提取 $kA$ 的小数部分. 第二步, 用 $m$ 乘以这个值, 再向下取整. 散列函数为:</p>
<p>$$h(k) = \left \lceil{m(kA \mod 1)}\right \rceil $$</p>
<p>乘法散列法的一个优点就是对 $m$ 的选择不是特别的关键, 一般选择它为 $2$ 的某个幂次.</p>
<p>Knuth 认为</p>
<p>$$A \approx (\sqrt{5}-1)/2 = 0.618 033 988 7…$$</p>
<p>是个比较理想的数值.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>散列表(hash table)是实现字典操作的一种有效的数据结构. 尽管在最坏情况下, 散列表中查找一个元素的时间与链表中查找的时间相同, 达到了 $\Theta(n)$. 然而在实际的应用中, 散列表的性能是极好的, 查找元素的平均时间是 $O(1)$.</p>
<h2 ]]>
    </summary>
    
      <category term="Algorithm" scheme="http://deltax.me/tags/Algorithm/"/>
    
      <category term="Ruby" scheme="http://deltax.me/tags/Ruby/"/>
    
      <category term="clrs" scheme="http://deltax.me/categories/clrs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[基本数据结构]]></title>
    <link href="http://deltax.me/2015/04/03/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://deltax.me/2015/04/03/基本数据结构/</id>
    <published>2015-04-03T07:20:07.000Z</published>
    <updated>2015-04-04T08:58:04.000Z</updated>
    <content type="html"><![CDATA[<p>在这一次的 post 中, 我们将要介绍一些简单的数据结构: 栈, 队列, 链表和树.</p>
<h1 id="栈和队列">栈和队列</h1><p>栈和队列都是动态集合, 在这两种数据结构上进行 <code>DELETE</code> 操作所移除的元素都是预先设定的. 它们是两种最常用的数据结构.</p>
<h2 id="栈">栈</h2><p>在栈中, 被删除的元素是<strong>最近插入</strong>的元素. 它实现的是一种<strong>后进先出</strong>(last-in, first-out, LIFO)的策略. </p>
<p>栈上的 <code>INSERT</code> 操作叫做 <code>PUSH</code>, 而无参数的 <code>DELETE</code> 操作叫做 <code>POP</code>. 我们可以使用 Ruby 中的数组来实现一个栈不需要考虑栈中所容纳的最多元素.</p>
<p>当栈中不包含任何元素时, 即栈是<strong>空</strong>的. 如果对一个空栈执行 <code>POP</code> 操作, 那么称为 <code>underflow</code>. 如果栈中的元素数量超出了所容纳的上限, 那么成为 <code>overflow</code>. 在这里我们不考虑栈的 <code>overflow</code> 问题.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span></span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> </span>initialize</span><br><span class="line">		<span class="variable">@elements</span> = []</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> </span>empty</span><br><span class="line">		<span class="variable">@elements</span>.size == <span class="number">0</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> </span>push(x)</span><br><span class="line">		<span class="variable">@elements</span>[<span class="variable">@elements</span>.size] = x</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> </span>pop</span><br><span class="line">		raise <span class="string">"Cannot pop empty stack!"</span> <span class="keyword">if</span> <span class="variable">@elements</span>.size &lt; <span class="number">0</span></span><br><span class="line">		result = <span class="variable">@elements</span>[<span class="variable">@elements</span>.size - <span class="number">1</span>]</span><br><span class="line">		<span class="variable">@elements</span>[<span class="variable">@elements</span>.size - <span class="number">1</span>] = <span class="keyword">nil</span></span><br><span class="line">		result</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这三种操作的执行时间都为 $O(1)$.</p>
<h2 id="队列">队列</h2><p>在队列中, 被删去的元素都是在集合中存在时间最长, 最先加入队列的元素. 队列实现的是一种<strong>先进先出</strong>(first-in, first-out, FIFO)策略.</p>
<p>队列中的 <code>INSERT</code> 操作成为 <code>ENQUEUE</code>, 无参数的 <code>DELETE</code> 操作被称为 <code>DEQUEUE</code>. 队列有 <code>head</code> 和 <code>tail</code>. 当一个元素入队时会放到队尾的位置, 就像排在队伍末尾买票的人, 而出队的元素总是队伍最前面等待最久的人.</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class <span class="type">Queue</span></span><br><span class="line"></span><br><span class="line">	def initialize</span><br><span class="line">		@elements = []</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	def enqueue(x)</span><br><span class="line">		@elements[@elements.size] = x</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	def dequeue</span><br><span class="line">		<span class="keyword">raise</span> <span class="string">"Queue is empty!"</span> <span class="keyword">if</span> @elements.size == <span class="number">0</span></span><br><span class="line">		<span class="literal">result</span> = @elements.shift</span><br><span class="line">		<span class="literal">result</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在这段实现代码中, 我们并没有使用 <code>@head</code> 和 <code>@tail</code> 来保存队列的头部和尾部属性. 而是使用其他的操作来代替.</p>
<h1 id="链表">链表</h1><p>链表是一种这样的数据结构, 其中的各对象按线性顺序排序. 数组的线性顺序是由数组下标决定的, 然而与数组不同的是, 链表的顺序是由各个对象里的指针决定的. 链表为动态集合提供了一种简单而灵活的表示方法.</p>
<p><strong>双向链表</strong>中的每一个元素都是一个对象, 每一个对象都有一个关键字 <code>key</code> 和两个指针: <code>next</code> 和 <code>prev</code>.</p>
<p>链表可以有多种形式. 它可以是单链接的或双链接的, 可以使已排序的或未排序的, 可以是排序的或未排序的. </p>
<ul>
<li>如果一个链表是<strong>单链接的</strong>, 则省略每个元素中的 <code>prev</code> 指针. </li>
<li>如果链表是<strong>已排序</strong>的, 则链表的线性顺序与链表元素中关键字的线性顺序一直. </li>
<li>如果链表是<strong>未排序</strong>的, 则表中的元素可以以任何顺序出现.</li>
<li>如果链表是<strong>循环链表</strong>, 表头元素的 <code>prev</code> 指针指向表尾元素, 而表尾元素的 <code>next</code> 指针指向表头元素.</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkList</span></span></span><br><span class="line">	<span class="keyword">attr_accessor</span> <span class="symbol">:head</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> </span>initialize</span><br><span class="line">		<span class="variable">@head</span> = <span class="keyword">nil</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> </span>search(key)</span><br><span class="line">		x = <span class="variable">@head</span></span><br><span class="line">		<span class="keyword">while</span> x != <span class="keyword">nil</span> &amp;&amp; x.value != key</span><br><span class="line">			x = x.<span class="keyword">next</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		x</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> </span>insert(node)</span><br><span class="line">		node.<span class="keyword">next</span> = <span class="variable">@head</span></span><br><span class="line">		<span class="variable">@head</span>.prev = node <span class="keyword">if</span> <span class="variable">@head</span> != <span class="keyword">nil</span></span><br><span class="line">		<span class="variable">@head</span> = node</span><br><span class="line">		node.prev = <span class="keyword">nil</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> </span>delete(node)</span><br><span class="line">		<span class="keyword">if</span> node.prev != <span class="keyword">nil</span></span><br><span class="line">			node.prev.<span class="keyword">next</span> = node.<span class="keyword">next</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="variable">@head</span> = node.<span class="keyword">next</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		node.<span class="keyword">next</span>.prev = node.prev <span class="keyword">if</span> node.<span class="keyword">next</span> != <span class="keyword">nil</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span></span><br><span class="line">	<span class="keyword">attr_accessor</span> <span class="symbol">:prev</span>, <span class="symbol">:value</span>, <span class="symbol">:next</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> </span>initialize(value)</span><br><span class="line">		<span class="variable">@prev</span> = <span class="keyword">nil</span></span><br><span class="line">		<span class="variable">@value</span> = value</span><br><span class="line">		<span class="variable">@next</span> = <span class="keyword">nil</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>要搜索一个有 <code>n</code> 个对象的链表, 过程 <code>search</code> 的最坏情况下的运行时间为 $\Theta(n)$, 因为可能搜索整个链表.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> </span>search(key)</span><br><span class="line">	x = <span class="variable">@head</span></span><br><span class="line">	<span class="keyword">while</span> x != <span class="keyword">nil</span> &amp;&amp; x.value != key</span><br><span class="line">		x = x.<span class="keyword">next</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	x</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>链表的插入的执行时间为 $O(1)$.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> </span>insert(node)</span><br><span class="line">	node.<span class="keyword">next</span> = <span class="variable">@head</span></span><br><span class="line">	<span class="variable">@head</span>.prev = node <span class="keyword">if</span> <span class="variable">@head</span> != <span class="keyword">nil</span></span><br><span class="line">	<span class="variable">@head</span> = node</span><br><span class="line">	node.prev = <span class="keyword">nil</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>我们先使用 <code>search</code> 寻找到目标之后, 再将目标元素 <code>delete</code>. 它的运行时间为 $O(1)$. 但是要先寻找到指定元素时, 因为要调用 <code>search</code> 所以运行时间为 $\Theta(n)$.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> </span>delete(node)</span><br><span class="line">	<span class="keyword">if</span> node.prev != <span class="keyword">nil</span></span><br><span class="line">		node.prev.<span class="keyword">next</span> = node.<span class="keyword">next</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="variable">@head</span> = node.<span class="keyword">next</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	node.<span class="keyword">next</span>.prev = node.prev <span class="keyword">if</span> node.<span class="keyword">next</span> != <span class="keyword">nil</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h1 id="树">树</h1><p>树的结点用对象表示, 我们首先将讨论二叉树.</p>
<h2 id="二叉树">二叉树</h2><p>首先我们来介绍一下二叉树的表示.</p>
<p><img src="http://deltax.qiniudn.com/bonary-tree.png?attname=&e=1428144652&token=YJb_IPQrTSw1ox9LenQDH1HRcgHii9w_bp9ddmcz:ijsBu-QD13JsmP3BXx1jRAU2t5U" style="display:block;margin:auto"> </p>
<p>上图中表示了在二叉树中, 数据是如何存储和表示的.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在这一次的 post 中, 我们将要介绍一些简单的数据结构: 栈, 队列, 链表和树.</p>
<h1 id="栈和队列">栈和队列</h1><p>栈和队列都是动态集合, 在这两种数据结构上进行 <code>DELETE</code> 操作所移除的元素都是预先设定的. 它们]]>
    </summary>
    
      <category term="Algorithm" scheme="http://deltax.me/tags/Algorithm/"/>
    
      <category term="Ruby" scheme="http://deltax.me/tags/Ruby/"/>
    
      <category term="clrs" scheme="http://deltax.me/categories/clrs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2015年3月总结]]></title>
    <link href="http://deltax.me/2015/04/02/2015%E5%B9%B43%E6%9C%88%E6%80%BB%E7%BB%93/"/>
    <id>http://deltax.me/2015/04/02/2015年3月总结/</id>
    <published>2015-04-02T14:49:23.000Z</published>
    <updated>2015-04-03T09:20:04.000Z</updated>
    <content type="html"><![CDATA[<h2 id="CTMCP">CTMCP</h2><p>这一个月的前半部分时间利用率并不是特别的高, 后半个月基本上每两天看一章算法导论, 和一部分的 CTCMP, 到今天为止 CTMCP 终于看完了.</p>
<p>看这本书的过程中虽然有些收获, 不过并没有阅读 SICP 收获来得大, 而且这本书也并没有 SICP 有趣, 能颠覆我对编程的理解和认识, 不过我还是了解了一些非常非常好玩的语言, 也对一些编程范式, 编程语言有了更深层次地理解. 以后也可以从另一个角度来看待各种各样的编程语言了. </p>
<p>不过书籍的最后一部分实在是无法阅读下去, 也只得放弃, 不过估计以后也不会再回头来看了. 书的网站对于这本书的支持也并不够, 我找到了这本书的官方社区, 发现社区 3 年只有 20 个左右的帖子. 书中的好多代码也是无法运行的, 尤其是逻辑式编程地部分, 严重地影响了读书的体验.</p>
<h2 id="Prolog_Smalltalk_Scheme">Prolog Smalltalk Scheme</h2><p>阅读这本书之后, 我对 Scheme Smalltalk 和 Prolog 有着非常浓厚地兴趣, 我会在下一个阶段的学习中学习它们, 我预计先学习 Prolog, 因为 Prolog 相对于 Smalltalk 的资源还是比较充足一些的. 而 Scheme 由于之前看过 SICP 所以只打算复习一下, 而 Smalltalk 近期还没有学习的打算.</p>
<h2 id="Sinatra">Sinatra</h2><p>在这个月我还接触到了 Ruby 的 Sinatra 框架感觉也是一个非常简介的框架, 再加上 Ruby 是一门非常优雅的语言. 我写起来还是非常爽的. 我会在下个月深入学习一下 Sinatra 的使用和部署, 争取完成一个使用 sinatra 的小项目.</p>
<h2 id="算法导论">算法导论</h2><p>算法导论这本书还是很有意思的, 不过一些数学方面的证明对于我来说还是很吃力的. 不过对于我以后不会去做算法工程师的定位, 我准备还是略微读一下这本算法界的经典, 提升一下自己的算法能力, 也能为面试做下准备. 不过对于一些习题我还是打算跳过的. 只完成一些基础方面的东西, 对算法有一些基本的理解.</p>
<h2 id="设计师">设计师</h2><p>关于设计方面, 我目前还是很头疼的, 因为我身边比较缺少这样的人, 我也一直在找, 另外我也在尝试做一些简单的设计, 虽然不能达到优秀的水平, 不过也能勉强作为一个应用的界面.</p>
<h2 id="进度">进度</h2><ol>
<li>完成 CTMCP</li>
<li>算法导论前 10 章.</li>
<li>了解 Sinatra</li>
</ol>
<h2 id="目标">目标</h2><ol>
<li>学习 Prolog</li>
<li>阅读 4 章操作系统</li>
<li>阅读 10 章算法导论</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="CTMCP">CTMCP</h2><p>这一个月的前半部分时间利用率并不是特别的高, 后半个月基本上每两天看一章算法导论, 和一部分的 CTCMP, 到今天为止 CTMCP 终于看完了.</p>
<p>看这本书的过程中虽然有些收获, 不过并没有阅读 SICP 收获]]>
    </summary>
    
      <category term="Conclusion" scheme="http://deltax.me/categories/Conclusion/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Graphical User Interface Programming]]></title>
    <link href="http://deltax.me/2015/04/02/Graphical-User-Interface-Programming/"/>
    <id>http://deltax.me/2015/04/02/Graphical-User-Interface-Programming/</id>
    <published>2015-04-02T05:03:18.000Z</published>
    <updated>2015-04-02T07:44:52.000Z</updated>
    <content type="html"><![CDATA[<p>This post will show a particularly simple and powerful way to do graphical user inteerface programming. We combine the declarative model together with the shared-state concurrent model. First, we will summarize the existing approaches.</p>
<ul>
<li>Purely procedurel<ul>
<li>The user interface is constructed by a sequence of graphics commands. These commands can be purely imperative or even functional. The object-oriented or functional style is preferable to an imperative style.</li>
</ul>
</li>
<li>Purely declarative<ul>
<li>The user interface is constructed by choosing from a set of predefined possibilities. This is an example of descriptive declarativeness.</li>
</ul>
</li>
<li>Using an interface builder<ul>
<li>The user interface is constructed manully by the developer, using a direct manipulation interface.</li>
</ul>
</li>
</ul>
<p>The procedural approach is expressive but is complex to use.<br>The declarative approach is easy to use but lacks expressiveness.<br>The interface builder is easy to use and gives immediate feedback on the interface but it lacks expressiveness and the interface is haard to change at run time.</p>
<h2 id="The_Declarative/Procedural_Approach">The Declarative/Procedural Approach</h2><p>What are the relative merits of the declarative and procedural approaches to specifying user interfaces? The trade-off is between expressiveness and manipulability:</p>
<ul>
<li>The declrative approach defines a set of possibilities for different attributes. The developer chooses among this set and defines a data structure that describes the interface. <ul>
<li>The pure declarative approach makes it easy to formally manipulate the user definitions. But the expressiveness is limited bacause it is only possible to express what the designers initially thought of.</li>
</ul>
</li>
<li>The procedural approach gives a set of primitive operations and the ability to write programs to them. These programs construct the interface. <ul>
<li>A purely procedural approach has no limits on its expressiveness. However, this makes harder to do formal manipulations on the user interface definitions.</li>
</ul>
</li>
</ul>
<p>The trade-off is not a temporary state of affairs. It is a deep property of computational models. As a language becomes more expressive, its programs become less amenable to formal manipulation.</p>
<p>It is still possible to define a model that is both manipulate and expressive. We can do it by combing the declarative and procedural approaches.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>This post will show a particularly simple and powerful way to do graphical user inteerface programming. We combine the declarative model ]]>
    </summary>
    
      <category term="CTMCP" scheme="http://deltax.me/tags/CTMCP/"/>
    
      <category term="GUI Programming" scheme="http://deltax.me/tags/GUI-Programming/"/>
    
      <category term="Programming Paradigm" scheme="http://deltax.me/categories/Programming-Paradigm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Relational Programming]]></title>
    <link href="http://deltax.me/2015/04/01/Relational-Programming/"/>
    <id>http://deltax.me/2015/04/01/Relational-Programming/</id>
    <published>2015-04-01T07:15:09.000Z</published>
    <updated>2015-04-01T13:47:27.000Z</updated>
    <content type="html"><![CDATA[<p>A relational procedure is more flexible than a functional procedure in two ways. </p>
<ul>
<li>First, there can be any number of results to a call. </li>
<li>Second, which arguments are inputs and which are outputs can be different for each call.</li>
</ul>
<p>These features make relational programming well-suited for databases and parsers. And it extends declarative programming with a new kind of statement called a “choice”. And <code>Prolog</code> language uses a choice operation as the heart of its execution model.</p>
<p>The flexibility of relational programming has a reverse side. It can easily lead to inefficient programs. Relational programming is practical in these areas:</p>
<ul>
<li>When the search space is small.</li>
<li>As an exploratory tool.</li>
</ul>
<h1 id="The_Relational_Computational_Model">The Relational Computational Model</h1><p>The relational computational model extends the declrative model with two new statements, <code>choice</code> and <code>fail</code>.</p>
<ul>
<li>The <code>choice</code> statement group together a set of alternative statements.</li>
<li>The <code>fail</code> statement indicates that the current alternative is wrong.</li>
</ul>
<h2 id="Search_Tree">Search Tree</h2><p>A relational program is executed sequentially. The <code>choice</code> statements are executed in the order that they are encountered during execution.</p>
<p>When a <code>choice</code> is first executed, its first alternativeis picked. When  <code>fail</code> is executed, execution “backs up” to the most recent <code>choice</code> statement.</p>
<p>This execution stategy can be illustrated with a tree called the search tree.</p>
<p><img src="http://deltax.qiniudn.com/Search-Tree.png?attname=&e=1427974813&token=YJb_IPQrTSw1ox9LenQDH1HRcgHii9w_bp9ddmcz:O2ESA3L4RlojzLV7kuJE2QxJrVk" style="display:block;margin:auto"></p>
<h2 id="The_Solve_Function">The <code>Solve</code> Function</h2><p>We provide encapsulated search by adding one function, <code>Solve</code> to the computation model. The call <code>{Solve F}</code> is given a zero-argument function <code>F</code> that returns a solution to a relational program. This returns a lazy list of all solutions with <code>DFS</code>.</p>
<p>We just look the first element with this function:</p>
<figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fun</span> &#123;<span class="type">SolveOne</span> <span class="type">F</span>&#125;</span><br><span class="line">   <span class="type">L</span>=&#123;<span class="type">Solve</span> <span class="type">F</span>&#125;</span><br><span class="line"><span class="keyword">in</span></span><br><span class="line">   <span class="keyword">if</span> <span class="type">L</span>==<span class="literal">nil</span> <span class="keyword">then</span> <span class="literal">nil</span> <span class="keyword">else</span> [<span class="type">L</span>.<span class="number">1</span>] <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>To get all-solution search, we look at the whole list:</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun &#123;<span class="type">SolveAll</span> F&#125;</span><br><span class="line">   L=&#123;<span class="type">Solve</span> F&#125;</span><br><span class="line">   <span class="keyword">proc</span> &#123;<span class="type">TouchAll</span> L&#125;</span><br><span class="line">      <span class="keyword">if</span> L==<span class="keyword">nil</span> then skip <span class="keyword">else</span> &#123;<span class="type">TouchAll</span> L.<span class="number">2</span>&#125; <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">in</span></span><br><span class="line">   &#123;<span class="type">TouchAll</span> L&#125;</span><br><span class="line">   L</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>A relational procedure is more flexible than a functional procedure in two ways. </p>
<ul>
<li>First, there can be any number of results ]]>
    </summary>
    
      <category term="CTMCP" scheme="http://deltax.me/tags/CTMCP/"/>
    
      <category term="Oz" scheme="http://deltax.me/tags/Oz/"/>
    
      <category term="Relational Programming" scheme="http://deltax.me/tags/Relational-Programming/"/>
    
      <category term="Programming Paradigm" scheme="http://deltax.me/categories/Programming-Paradigm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Transactions]]></title>
    <link href="http://deltax.me/2015/04/01/Transactions/"/>
    <id>http://deltax.me/2015/04/01/Transactions/</id>
    <published>2015-04-01T03:50:46.000Z</published>
    <updated>2015-04-07T15:50:58.000Z</updated>
    <content type="html"><![CDATA[<p>Transactions were introduced as a basic concept for the management of larget shared database.</p>
<p>The term “transaction” has acquired a fairly meaning, it is any operation satisfies the four <code>ACID</code> properties which is an acronym.</p>
<ul>
<li>A stands for <strong>atmoic</strong><ul>
<li>No intermediate states of a transaction’s execution are observable.</li>
</ul>
</li>
<li>C stands for <strong>consistent</strong><ul>
<li>Observable state changes respect the system invariants. Consistentcy is closely related to atomicity. The difference is the consistency is responsibility for programmer, whereas atmoicity is the responsibility of the implemenation of the trasaction system.</li>
</ul>
</li>
<li>I stands for <strong>isolation</strong><ul>
<li>Several transactions can execute concurrently without interfering with each other. They execute as if they were sequential.</li>
</ul>
</li>
<li>D stands for <strong>durabulity</strong><ul>
<li>Observable state changes survive across system shutdowns. This is often called persistence.</li>
</ul>
</li>
</ul>
<h2 id="Motivations">Motivations</h2><ul>
<li>One motivation for transactions was to increase the throughtput of concurrent accesses to a database.</li>
<li>A second motivation is concurrent programming with exceptions. Most routines has two way to exit, either they exit normally or they raise an exception. And there are two solutions when an exception raised.<ul>
<li>The caller can clean up the called routine’s mess.</li>
<li>The routine can be inside a transaction. Raising an exception corresponds to aborting the transaction.</li>
</ul>
</li>
<li>A third motivation is fault tolerance. A fault tolerance application has to take three steps:<ol>
<li>Detect the fault.</li>
<li>Contain the fault in a limited part of the application</li>
<li>Repair any problems caused by the fault.</li>
</ol>
</li>
<li>A fourth motivation is resource management.</li>
</ul>
<h2 id="Concurrency_Control">Concurrency Control</h2><p>Consider a large database by many clients at the same time. They are concurrent yet still satisfy serializability. The implementation should allow concurrent transaction and yet it has to make sure that they are still serializable.</p>
<p>Concurrency control is the set of techniques used to build and program concurrent sysmtems with transactional properties. Our algorithm is interesting because it is both practical and simple.</p>
<h3 id="Locks_and_Timestamps">Locks and Timestamps</h3><p>The two most widely used approaches to concurrency control are locks and timestamps:</p>
<ul>
<li>Lock-based concurrency control<ul>
<li>Each stateful entity has a lock that controls access to the entity Locks always restricting the system’s behavior so that it is safe.</li>
</ul>
</li>
<li>Timestamp-based concurrency control<ul>
<li>Each transaction is given a timestamp that gives it a priority. Timestamps are important to ensure that execution makes progress.</li>
</ul>
</li>
</ul>
<p>Safety and liveness propeties describe how a system hahaves as a function of time.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Transactions were introduced as a basic concept for the management of larget shared database.</p>
<p>The term “transaction” has acquired ]]>
    </summary>
    
      <category term="CTMCP" scheme="http://deltax.me/tags/CTMCP/"/>
    
      <category term="Oz" scheme="http://deltax.me/tags/Oz/"/>
    
      <category term="Programming Paradigm" scheme="http://deltax.me/categories/Programming-Paradigm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Stateful Concurrent Data Abstraction]]></title>
    <link href="http://deltax.me/2015/03/31/Stateful-Concurrent-Data-Abstraction/"/>
    <id>http://deltax.me/2015/03/31/Stateful-Concurrent-Data-Abstraction/</id>
    <published>2015-03-31T08:56:39.000Z</published>
    <updated>2015-04-01T03:11:18.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Lock">Lock</h1><p>It often happens when threads wish to access a shared resource, but the resource can only be accessed by one thread at a time. This always called race condition and may causes unexcepted error during execution.</p>
<p>To manage this situation, we introduce a language concept called lock, to help control access to resource.</p>
<p>A lock dynamicically controls access to part of the program, called a critical region. If the shared resource is only accessed from within the critical region, then the lock can be used to control access to the resource.</p>
<p>We are ready to program stateful concurrent data abstractions and give a systematic way to transform a declrative data abstraction to become stateful concurrent data abstraction.</p>
<p>We illustrate the different techniques by means of simple example, a queue.</p>
<h2 id="Declarative_Version">Declarative Version</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fun <span class="string">&#123;NewQueue&#125;</span></span><br><span class="line">X in</span><br><span class="line">	<span class="string">q(0 X X)</span></span><br><span class="line">end</span><br><span class="line">fun &#123;Insert <span class="string">q(N S E)</span> X&#125;</span><br><span class="line">E1 in</span><br><span class="line">	E=X|E1 <span class="string">q(N+1 S E1)</span></span><br><span class="line">end</span><br><span class="line">fun &#123;Delete <span class="string">q(N S E)</span> X&#125;</span><br><span class="line">S1 in</span><br><span class="line">	S=X|S1 <span class="string">q(N-1 S1 E)</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>This is essentially the declarative queue. The order of the queue operations is explicitly determined by the program.</p>
<h2 id="Sequential_Stateful_Version">Sequential Stateful Version</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fun <span class="string">&#123;NewQueue&#125;</span></span><br><span class="line">	X C=&#123;NewCell <span class="string">q(0 X X)</span>&#125;</span><br><span class="line">	proc &#123;Insert X&#125;</span><br><span class="line">	N E E1 in</span><br><span class="line">		<span class="string">q(N S X|E1)</span>=<span class="variable">@C</span></span><br><span class="line">		C:=<span class="string">q(N+1 S E1)</span></span><br><span class="line">	end</span><br><span class="line">	fun <span class="string">&#123;Delete&#125;</span></span><br><span class="line">	N S1 E X in</span><br><span class="line">		<span class="string">q(N X|S1 E)</span>=<span class="variable">@C</span></span><br><span class="line">		C:=<span class="string">q(N-1 S1 E)</span></span><br><span class="line">		X</span><br><span class="line">	end</span><br><span class="line">in</span><br><span class="line">	queue(insert:Insert <span class="keyword">delete</span>:Delete)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>This show the same queue in a stateful version encapsulated the queue’s data. But this version cannot be used in concurrency. Because the <code>@</code> operation and <code>:=</code> operation. If two threads each do an insert operation, this may causes interleaving, which may gets incorrect answer.</p>
<h2 id="Concurrent_Stateful_Version_with_Lock">Concurrent Stateful Version with Lock</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fun <span class="string">&#123;NewQueue&#125;</span></span><br><span class="line">	X C=&#123;NewCell <span class="string">q(0 X X)</span>&#125;</span><br><span class="line">	L=<span class="string">&#123;NewLock&#125;</span></span><br><span class="line">	proc &#123;Insert X&#125;</span><br><span class="line">	N E E1 in</span><br><span class="line">		lock L then</span><br><span class="line">			<span class="string">q(N S X|E1)</span>=<span class="variable">@C</span></span><br><span class="line">			C:=<span class="string">q(N+1 S E1)</span></span><br><span class="line">	end</span><br><span class="line">	end</span><br><span class="line">	fun <span class="string">&#123;Delete&#125;</span></span><br><span class="line">	N S1 E X in</span><br><span class="line">		lock L then</span><br><span class="line">			<span class="string">q(N X|S1 E)</span>=<span class="variable">@C</span></span><br><span class="line">			C:=<span class="string">q(N-1 S1 E)</span></span><br><span class="line">		end</span><br><span class="line">		X</span><br><span class="line">	end</span><br><span class="line">in</span><br><span class="line">	queue(insert:Insert <span class="keyword">delete</span>:Delete)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>This version shows a concurrent version of stateful queue, using a lock to ensure atomicity of the read-operation-write sequence. Doing this version in different threads will not impose any synchronization between the threads. This property is a consequence of using state.</p>
<h2 id="Concurrent_Object-Oriented_Version_with_Lock">Concurrent Object-Oriented Version with Lock</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Queue</span><br><span class="line">	attr queue</span><br><span class="line">	prop locking</span><br><span class="line">	</span><br><span class="line">	meth init</span><br><span class="line">		queue:=<span class="string">q(0 X X)</span></span><br><span class="line">	end</span><br><span class="line">	</span><br><span class="line">	meth insert(X)</span><br><span class="line">		lock N S E1 in</span><br><span class="line">			<span class="string">q(N S X|E1)</span>=<span class="variable">@queue</span></span><br><span class="line">			queue:=<span class="string">q(N+1 S E1)</span></span><br><span class="line">		end</span><br><span class="line">	end</span><br><span class="line">	</span><br><span class="line">	meth <span class="keyword">delete</span>(X)</span><br><span class="line">		lock N S1 E in</span><br><span class="line">			<span class="string">q(N X|S1 E)</span>=<span class="variable">@queue</span></span><br><span class="line">			queue:=<span class="string">q(N-1 S1 E)</span></span><br><span class="line">		end</span><br><span class="line">	end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>This version is rewrittern with object-oriented syntax. The cell is replaced by the attribute <code>queue</code> and the lock is implicitly defined by the <code>locking</code> property.</p>
<h2 id="Concurrent_Stateful_Version_with_Exchange">Concurrent Stateful Version with Exchange</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fun <span class="string">&#123;NewQueue&#125;</span></span><br><span class="line">	X C=&#123;NewCell <span class="string">q(0 X X)</span>&#125;</span><br><span class="line">	proc &#123;Insert X&#125;</span><br><span class="line">	N S E1 N1 in</span><br><span class="line">		&#123;Exchange C <span class="string">q(N S X|E1)</span>	 <span class="string">q(N1 S E1)</span>&#125;</span><br><span class="line">		N1=N+<span class="number">1</span></span><br><span class="line">	end</span><br><span class="line">	fun <span class="string">&#123;Delete&#125;</span></span><br><span class="line">	N S1 E N1 X in</span><br><span class="line">		&#123;Exchange C <span class="string">q(N X|S1 S)</span>	 <span class="string">q(N1 S1 E)</span>&#125;</span><br><span class="line">		N1=N-<span class="number">1</span></span><br><span class="line">		X</span><br><span class="line">	end</span><br><span class="line">in</span><br><span class="line">	queue(insert:Insert <span class="keyword">delete</span>:Delete)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>This version is made by <code>Exchange</code> operation, because this is single state operation, so no locks are needed.</p>
<h1 id="Monitors">Monitors</h1><p>Locks are an important tool for building abstraction in a stateful model, but they are not sufficient. </p>
<p>The standard way of coordinating threads in a stateful model is by monitor. A monitor is a lock extended with program control over how waiting threads enter and exit the lock.</p>
<p>The monitors adds a <code>wait</code> and <code>notify</code> operation to the lock entry and exit operations. </p>
<ul>
<li>When inside a monitor, a thread can explicitly do a <code>wait</code>; suspend the thread, and entered into the monitor wait set, and release the monitor lock.</li>
<li>When a thread does a <code>notify</code>, it lets one thread in the wait set continue. This thread attempts to get the monitor lock again.</li>
</ul>
<h2 id="Definition">Definition</h2><p>A monitor is always part of an object. It is an object with an internal lock and wait set. Object methoded can be protected by the lock by annotating them as <code>synchronized</code>. There are three  operations to manage the lock: <code>wait</code>, <code>notify</code>, and <code>notifyAll</code>.</p>
<ul>
<li>The <code>wait</code> operation<ul>
<li>The current thread is suspended.</li>
<li>The thread is placed in the object’s internal wait set.</li>
<li>The lock for the object is released.</li>
</ul>
</li>
<li>The <code>notify</code> operation<ul>
<li>If one exists, an arbitrary thread <code>T</code> is removed from the object’s internal wait set.</li>
<li><code>T</code> proceeds to get the lock, just as any other thread. This means that <code>T</code> will always suspend for a short time, until the notifying releases the lock.</li>
<li><code>T</code> resumes execution at the point it was suspended.</li>
</ul>
</li>
<li>The <code>notify</code> operation<ul>
<li>Similar to <code>notify</code> except does above steps for all threads. The wait set is emptied.</li>
</ul>
</li>
</ul>
<p>Monitors are disigned for building concurrent data abstractions based on shared state.</p>
<h2 id="Bounded_Buffer">Bounded Buffer</h2><p>The bounded buffer is an object with three operations.</p>
<ul>
<li><code>B={New Buffer init(N)}</code>: create a new bouned buffer <code>B</code> of size <code>N</code>.</li>
<li><code>B={Put (X)}</code>: put the element <code>X</code> in buffer. If the buffer is fill, this will block until the buffer has room for the element.</li>
<li><code>B={Get (X)}</code>: remove the element <code>X</code> from the buffer. If the buffer is empty this will block until there is at least one element.</li>
</ul>
<h3 id="Partial_Definition_of_Monitor_Version">Partial Definition of Monitor Version</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Buffer</span><br><span class="line">   attr</span><br><span class="line">      buf <span class="keyword">first</span> <span class="keyword">last</span> n i</span><br><span class="line"></span><br><span class="line">   meth init(N)</span><br><span class="line">      buf:=&#123;NewArray <span class="number">0</span> N-<span class="number">1</span> <span class="constant">null</span>&#125;</span><br><span class="line">      <span class="keyword">first</span>:=<span class="number">0</span></span><br><span class="line">      <span class="keyword">last</span>:=<span class="number">0</span></span><br><span class="line">      n:=N</span><br><span class="line">      i:=<span class="number">0</span></span><br><span class="line">   <span class="function"><span class="keyword">end</span></span></span><br><span class="line"></span><br><span class="line">   meth <span class="built_in">put</span>(X)</span><br><span class="line">      @buf.@<span class="keyword">last</span>:=X</span><br><span class="line">      <span class="keyword">last</span>:=(@<span class="keyword">last</span>+<span class="number">1</span>) <span class="operator">mod</span> @n</span><br><span class="line">      i:=@i+<span class="number">1</span></span><br><span class="line">   <span class="function"><span class="keyword">end</span></span></span><br><span class="line"></span><br><span class="line">   meth <span class="built_in">get</span>(X)</span><br><span class="line">      X=@buf.@<span class="keyword">first</span></span><br><span class="line">      <span class="keyword">first</span>:=(@<span class="keyword">first</span>+<span class="number">1</span>) <span class="operator">mod</span> @n</span><br><span class="line">      i:=@i-<span class="number">1</span></span><br><span class="line">   <span class="function"><span class="keyword">end</span></span></span><br><span class="line"><span class="function"><span class="keyword">end</span></span></span><br></pre></td></tr></table></figure>
<p>The partial definition of the monitor does not check the bounded of the monitor. And then we will use monitor to implement this.</p>
<h3 id="Monitor_Version">Monitor Version</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Buffer</span><br><span class="line">   attr m buf <span class="keyword">first</span> <span class="keyword">last</span> n i</span><br><span class="line"></span><br><span class="line">   meth init(N)</span><br><span class="line">      m:=&#123;NewMonitor&#125;</span><br><span class="line">      buf:=&#123;NewArray <span class="number">0</span> N-<span class="number">1</span> <span class="constant">null</span>&#125;</span><br><span class="line">      n:=N i:= <span class="number">0</span> <span class="keyword">first</span>:=<span class="number">0</span> <span class="keyword">last</span>:=<span class="number">0</span></span><br><span class="line">   <span class="function"><span class="keyword">end</span></span></span><br><span class="line">   </span><br><span class="line">   meth <span class="built_in">put</span>(X)</span><br><span class="line">      &#123;@m.<span class="string">'lock'</span> proc &#123;$&#125;</span><br><span class="line">		    <span class="keyword">if</span> @i&gt;@n <span class="keyword">then</span> &#123;@m.<span class="built_in">wait</span>&#125; &#123;self <span class="built_in">put</span>(X)&#125;</span><br><span class="line">		    <span class="keyword">else</span></span><br><span class="line">		       @buf.@<span class="keyword">last</span>:=X</span><br><span class="line">		       <span class="keyword">last</span>:=(@<span class="keyword">last</span>+<span class="number">1</span>) <span class="operator">mod</span> @n</span><br><span class="line">		       i:=@i+<span class="number">1</span></span><br><span class="line">		       &#123;@m.notifyAll&#125;</span><br><span class="line">		    <span class="function"><span class="keyword">end</span></span></span><br><span class="line">		 <span class="function"><span class="keyword">end</span>&#125;</span></span><br><span class="line">   <span class="function"><span class="keyword">end</span></span></span><br><span class="line"></span><br><span class="line">   meth <span class="built_in">get</span>(X)</span><br><span class="line">      &#123;M.<span class="string">'lock'</span> proc &#123;$&#125;</span><br><span class="line">		   <span class="keyword">if</span> @i==<span class="number">0</span> <span class="keyword">then</span> &#123;@m.<span class="built_in">wait</span>&#125; &#123;self <span class="built_in">get</span>(X)&#125;</span><br><span class="line">		   <span class="keyword">else</span></span><br><span class="line">		      X=@buf.@<span class="keyword">first</span></span><br><span class="line">		      <span class="keyword">first</span>:=(@<span class="keyword">first</span>+<span class="number">1</span>) <span class="operator">mod</span> n</span><br><span class="line">		      i:=i-<span class="number">1</span></span><br><span class="line">		      &#123;@m.notifyAll&#125;</span><br><span class="line">		   <span class="function"><span class="keyword">end</span></span></span><br><span class="line">		<span class="function"><span class="keyword">end</span>&#125;</span></span><br><span class="line">   <span class="function"><span class="keyword">end</span></span></span><br><span class="line"><span class="function"><span class="keyword">end</span></span></span><br></pre></td></tr></table></figure>
<p>If the buffer is full, then <code>{M.wait}</code> simply waits until it is no longer full. When <code>get(X)</code> removes an element, it calls <code>{M.notifyAll}</code>, which wakes up the waiting thread.</p>
<h2 id="Programming_with_Monitors">Programming with Monitors</h2><p>The idea of monitors is guarded. Guarded methods are implemented using the <code>wait</code> and <code>notifyAll</code> operations.</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">meth methHead</span><br><span class="line">	lock</span><br><span class="line">		<span class="keyword">while</span> <span class="keyword">not</span> &lt;expr&gt; <span class="keyword">do</span> wait;</span><br><span class="line">		&lt;stmt&gt;</span><br><span class="line">		notifyAll;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>In this example, <code>&lt;expr&gt;</code> is the guard and <code>&lt;stmt&gt;</code> is the guarded body. When the method is called, the thread enters the lock and waits for conition in a <code>while</code> loop. If the <code>&lt;expr&gt;</code> is true, this executes the body and notify all the other threads. If not, threads wait until other notify them.</p>
<h2 id="Implementing_Monitors">Implementing Monitors</h2><p>Now let us impelement monitors in the shared-state concurrent model. This is thread-reentrant and correctly handles exceptions.</p>
<h3 id="Extended_Concurrent_Stateful_Version_Queue">Extended Concurrent Stateful Version Queue</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fun &#123;NewQueue&#125;</span><br><span class="line">	......</span><br><span class="line">   fun &#123;Size&#125;</span><br><span class="line">      <span class="operator"><span class="keyword">lock</span> L <span class="keyword">then</span> @C<span class="number">.1</span> <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   fun &#123;DeleteAll&#125;</span><br><span class="line">      <span class="keyword">lock</span> L <span class="keyword">then</span> </span><br><span class="line">     	X q(_ S E)=@C <span class="keyword">in</span></span><br><span class="line">			C:=q(<span class="number">0</span> X X)</span><br><span class="line">			E=nil S</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   fun &#123;DeleteNonBlock&#125;</span><br><span class="line">      <span class="keyword">lock</span> L <span class="keyword">then</span></span><br><span class="line"> 			<span class="keyword">if</span> &#123;<span class="keyword">Size</span>&#125;&gt;<span class="number">0</span> <span class="keyword">then</span> [&#123;<span class="keyword">Delete</span>&#125;] <span class="keyword">else</span> nil <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">in</span></span><br><span class="line">   queue(<span class="keyword">insert</span>:<span class="keyword">Insert</span> <span class="keyword">delete</span>:<span class="keyword">Delete</span> <span class="keyword">size</span>:<span class="keyword">Size</span> deleteAll:DeleteAll deleteNonBlock:DeleteNonBlock)</span><br><span class="line"><span class="keyword">end</span></span></span><br></pre></td></tr></table></figure>
<h3 id="Reentrant_Get-release_Version_Lock">Reentrant Get-release Version Lock</h3><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fun &#123;<span class="type">NewGRLock</span>&#125;</span><br><span class="line">	<span class="type">Token1</span>=&#123;<span class="type">NewCell</span> unit&#125;</span><br><span class="line">	<span class="type">Token2</span>=&#123;<span class="type">NewCell</span> unit&#125;</span><br><span class="line">	<span class="type">CurThr</span>=&#123;<span class="type">NewCell</span> unit&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">proc</span> &#123;<span class="type">GetLock</span>&#125;</span><br><span class="line">		<span class="keyword">if</span> &#123;<span class="type">Thread</span>.this&#125;\=@<span class="type">CurThr</span> then <span class="type">Old</span> <span class="type">New</span> <span class="keyword">in</span></span><br><span class="line">			&#123;<span class="type">Exchange</span> <span class="type">Token1</span> <span class="type">Old</span> <span class="type">New</span>&#125;</span><br><span class="line">			&#123;<span class="type">Wait</span> <span class="type">Old</span>&#125;</span><br><span class="line">			<span class="type">Token2</span>:=<span class="type">New</span></span><br><span class="line">			<span class="type">CurThr</span>:=&#123;<span class="type">Thread</span>.this&#125;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">proc</span> &#123;<span class="type">ReleaseLock</span>&#125;</span><br><span class="line">		<span class="type">CurThr</span>:=unit</span><br><span class="line">		unit=@<span class="type">Token2</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">in</span></span><br><span class="line">	'lock'(get:<span class="type">GetLock</span> release:<span class="type">ReleaseLock</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="Monitor_Implementation">Monitor Implementation</h3><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fun &#123;<span class="type">NewMonitor</span>&#125;</span><br><span class="line">   Q=&#123;<span class="type">NewQueue</span>&#125;</span><br><span class="line">   L=&#123;<span class="type">NewGRLock</span>&#125;</span><br><span class="line">   <span class="keyword">proc</span> &#123;<span class="type">LockM</span> P&#125;</span><br><span class="line">      &#123;L.get&#125; <span class="keyword">try</span> &#123;P&#125; <span class="keyword">finally</span> &#123;L.release&#125; <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">proc</span> &#123;<span class="type">WaitM</span>&#125; X <span class="keyword">in</span></span><br><span class="line">      &#123;Q.insert X&#125; &#123;L.release&#125; &#123;<span class="type">Wait</span> X&#125; &#123;L.get&#125;</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">proc</span> &#123;<span class="type">NotifyM</span>&#125; U=&#123;Q.deleteNonBlock&#125; <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">case</span> U <span class="keyword">of</span> [X] then X=unit <span class="keyword">else</span> skip <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">proc</span> &#123;<span class="type">NotifyAllM</span>&#125; L=&#123;Q.deleteAll&#125; <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">for</span> X <span class="keyword">in</span> L <span class="keyword">do</span> X=unit <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">in</span></span><br><span class="line">   monitor('lock':<span class="type">LockM</span> wait:<span class="type">WaitM</span> notify:<span class="type">NotifyM</span></span><br><span class="line">	   notifyAll:<span class="type">NotifyAllM</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Lock">Lock</h1><p>It often happens when threads wish to access a shared resource, but the resource can only be accessed by one threa]]>
    </summary>
    
      <category term="CTMCP" scheme="http://deltax.me/tags/CTMCP/"/>
    
      <category term="Concurrency" scheme="http://deltax.me/tags/Concurrency/"/>
    
      <category term="Oz" scheme="http://deltax.me/tags/Oz/"/>
    
      <category term="Programming Paradigm" scheme="http://deltax.me/categories/Programming-Paradigm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Shared-State Concurrency]]></title>
    <link href="http://deltax.me/2015/03/30/Shared-State-Concurrency/"/>
    <id>http://deltax.me/2015/03/30/Shared-State-Concurrency/</id>
    <published>2015-03-30T06:54:21.000Z</published>
    <updated>2015-03-31T11:48:26.000Z</updated>
    <content type="html"><![CDATA[<p>After reading the chapter 8 in CTMCP, I wirte this post gives an alternative way to implement concurrency model by adding cells.</p>
<h1 id="Programming_With_Concurrency">Programming With Concurrency</h1><p>By now, we have seen many different apporoach to write concurrent programs. And before introduce to <code>Shared-State Concurrency</code>. Let’s list all the approaches to implement concurrency.</p>
<ul>
<li>Sequential Programming</li>
<li>Declarative Programming</li>
<li>Message-Passing Concurrency</li>
<li>Shared-State Concurrency</li>
</ul>
<h2 id="Sequential_Programming">Sequential Programming</h2><p>In a sequential model, there is a total order among all opertions. This is the strongest order invariant a program can have. And this variant model is deterministic.</p>
<h2 id="Declarative_Concurrency">Declarative Concurrency</h2><p>This does not change the result of a calculation, but only changes the order in which the result is obtained.</p>
<p>These models have nondeterminism in the implementation, since the system choose how to advance the threads.</p>
<p>The demand-driven concurrent model, also known as lazy execution, is a form of declarative concurrency. It does not change the result of a calculation but only affects how much calculation is done to obtain the result.</p>
<h2 id="Message-Passing_Concurrency">Message-Passing Concurrency</h2><p>Message passing is a basic programming style of stateful concurrent model. It extends the declarative model with a simple kind of communication channel, a port.</p>
<h2 id="Shared-State_Concurrency">Shared-State Concurrency</h2><p>Shared state is another basic programming style of the stateful concurrent model. It consists of a set of threads accessing a set of shared passive object.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>After reading the chapter 8 in CTMCP, I wirte this post gives an alternative way to implement concurrency model by adding cells.</p>
<h1 ]]>
    </summary>
    
      <category term="CTMCP" scheme="http://deltax.me/tags/CTMCP/"/>
    
      <category term="Concurrency" scheme="http://deltax.me/tags/Concurrency/"/>
    
      <category term="Oz" scheme="http://deltax.me/tags/Oz/"/>
    
      <category term="Programming Paradigm" scheme="http://deltax.me/categories/Programming-Paradigm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Active Object]]></title>
    <link href="http://deltax.me/2015/03/30/Active-Object/"/>
    <id>http://deltax.me/2015/03/30/Active-Object/</id>
    <published>2015-03-30T06:05:38.000Z</published>
    <updated>2015-03-30T06:28:07.000Z</updated>
    <content type="html"><![CDATA[<p>An active object is a port object whose behavior is defined by a class. It consists of a port, a thread that reads messages from the port’s stream, and an object that is a class inheritance.</p>
<p>Active objects combine the abilities of OOP and the abilities of message-passing concurrency.</p>
<p>With respect to active obejects, the other obejcts of this object are called <em>passive objects</em>, since they have an internal thread.</p>
<h1 id="NewActive_Abstraction">NewActive Abstraction</h1><p>The behavior of avtive objects is defined with a class. Sending a message to an active object is the same as sending message to an object. And the invocation of the method is asynchronous. It returns immediately without waiting until the message has been handled.</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun &#123;<span class="type">NewActive</span> <span class="type">Class</span> <span class="type">Init</span>&#125;</span><br><span class="line">   <span class="type">Obj</span>=&#123;<span class="type">New</span> <span class="type">Class</span> <span class="type">Init</span>&#125;</span><br><span class="line">   P</span><br><span class="line"><span class="keyword">in</span></span><br><span class="line">   thread S <span class="keyword">in</span></span><br><span class="line">      &#123;<span class="type">NewPort</span> S P&#125;</span><br><span class="line">      <span class="keyword">for</span> M <span class="keyword">in</span> S <span class="keyword">do</span> &#123;<span class="type">Obj</span> M&#125; <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">proc</span> &#123;$ M&#125; &#123;<span class="type">Send</span> P M&#125; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>This makes defining active objects very intuitive.</p>
<h1 id="Synchronous_Abstraction">Synchronous Abstraction</h1><p>A synchronous invocation <code>{Obj M}</code> does not return until the method corresponding to <code>M</code> is completely executed. Here is the definition of <code>NewSync</code>, which creates a synchronous active object.</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun &#123;<span class="type">NewSync</span> <span class="type">Class</span> <span class="type">Init</span>&#125;</span><br><span class="line">P <span class="type">Obj</span>=&#123;<span class="type">New</span> <span class="type">Class</span> <span class="type">Init</span>&#125; <span class="keyword">in</span></span><br><span class="line">	thread S <span class="keyword">in</span></span><br><span class="line">		&#123;<span class="type">NewPort</span> S P&#125;</span><br><span class="line">		<span class="keyword">for</span> M<span class="comment">#X in S do &#123;Obj M&#125; X=unit end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">proc</span> &#123;$ M&#125; X <span class="keyword">in</span> &#123;<span class="type">Send</span> P M<span class="comment">#X&#125; &#123;Wait X&#125; end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>Each message sent to the object contains a synchronization token <code>X</code>, which is bound only when the message is completely handled.</p>
<h1 id="Active_Objects_with_Exception_Handling">Active Objects with Exception Handling</h1><p>Use exception handling means add <code>try catch</code> in the statement. The abstraction needs another argument whether or not an exception occurred.</p>
<p>The extra argument is bound to <code>normal</code> if the invocation completes normally, and to <code>exception(E)</code> if the object raises the exception <code>E</code>.</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fun &#123;NewActiveExc Class Init&#125;</span><br><span class="line">P Obj=&#123;New Class Init&#125; <span class="operator">in</span></span><br><span class="line">	thread S <span class="operator">in</span></span><br><span class="line">		&#123;NewPort S P&#125;</span><br><span class="line">		<span class="keyword">for</span> M<span class="comment">#X in S do</span></span><br><span class="line">			<span class="keyword">try</span> &#123;Obj M&#125; X=<span class="keyword">normal</span></span><br><span class="line">			<span class="keyword">catch</span> E <span class="keyword">then</span> X=exception(E) <span class="function"><span class="keyword">end</span></span></span><br><span class="line">		<span class="function"><span class="keyword">end</span></span></span><br><span class="line">	<span class="function"><span class="keyword">end</span></span></span><br><span class="line">	proc &#123;$ M X&#125; &#123;Send P M<span class="comment">#X&#125; end</span></span><br><span class="line"><span class="function"><span class="keyword">end</span></span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>An active object is a port object whose behavior is defined by a class. It consists of a port, a thread that reads messages from the port]]>
    </summary>
    
      <category term="CTMCP" scheme="http://deltax.me/tags/CTMCP/"/>
    
      <category term="OOP" scheme="http://deltax.me/tags/OOP/"/>
    
      <category term="Oz" scheme="http://deltax.me/tags/Oz/"/>
    
      <category term="Programming Paradigm" scheme="http://deltax.me/categories/Programming-Paradigm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[中位数和顺序统计量]]></title>
    <link href="http://deltax.me/2015/03/27/%E4%B8%AD%E4%BD%8D%E6%95%B0%E5%92%8C%E9%A1%BA%E5%BA%8F%E7%BB%9F%E8%AE%A1%E9%87%8F/"/>
    <id>http://deltax.me/2015/03/27/中位数和顺序统计量/</id>
    <published>2015-03-27T10:34:48.000Z</published>
    <updated>2015-03-27T14:10:29.000Z</updated>
    <content type="html"><![CDATA[<h1 id="顺序统计量">顺序统计量</h1><p>在一个由 $n$ 个元素组成的集合中, 第 $i$ 个顺序统计量 (order statistic) 是该集合中第 $i$ 小的元素.</p>
<ul>
<li><strong>最小值</strong>是第 $1$ 个顺序统计量 $i=1$.</li>
<li><strong>最大值</strong>是第 $n$ 个顺序统计量 $i=n$.</li>
<li><strong>中位数</strong>是所属集合的中点元素.<ul>
<li>当 $n$ 为偶数时, 存在两个中位数, 分别位于 $i=n/2$ 和 $i=n/2+1$.</li>
<li>当 $n$ 为奇数时, 中位数是唯一的, 位于 $i=(n+1)/2$.</li>
</ul>
</li>
</ul>
<h1 id="选择问题">选择问题</h1><p>我们将讨论从一个由 $n$ 个元素互异的集合中选择第 $i$ 个顺序统计量的问题, 把这一类问题形式化定义为如下的<strong>选择问题</strong>.</p>
<blockquote>
<p>输入: 一个包含 $n$ 个(互异的)数的集合 $A$ 和一个整数 $i$, 其中 $1 \leq i \leq n$<br>输出: 元素 $x \in A$, 且 $A$ 中恰好有 $i-1$个其它元素小于它.</p>
</blockquote>
<h1 id="期望为线性时间的选择算法">期望为线性时间的选择算法</h1><p>我们将介绍一种解决选择问题的算法, 渐进时间为 $\Theta (n)$. 与快速排序一样, 我们将输入数组进行递归划分. 但与快速排序不同的是, 我们只会处理划分的一边. 所以快速排序的期望运行复杂度为 $\Theta (n \lg n)$, 而在这里选择算法的期望运行时间为 $\Theta (n)$</p>
<p><code>RANDOMIZED_SELECT</code> 利用了 <code>randomized_partition</code> 过程, 它也是一个随机算法.</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#define EXCHANGE(a, b) tmp = a; a = b; b = tmp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">randomized_select</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> p, <span class="keyword">int</span> r, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q, k;</span><br><span class="line">    <span class="keyword">if</span> (p == r) &#123;</span><br><span class="line">        <span class="keyword">return</span> A[p];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    q = randomized_partition(A, p, r);</span><br><span class="line">    k = q - p + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == k) &#123;</span><br><span class="line">        <span class="keyword">return</span> A[q];</span><br><span class="line">    &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(i &lt; k)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">randomized_select</span><span class="params">(A, p, q - <span class="number">1</span>, i)</span></span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">randomized_select</span><span class="params">(A, q + <span class="number">1</span>, r, i - k)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">randomized_partition</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = rand() % (r - p) + p,</span><br><span class="line">        tmp;</span><br><span class="line"></span><br><span class="line">    EXCHANGE(A[i], A[r - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">partition</span><span class="params">(A, p, r)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = A[r - <span class="number">1</span>],</span><br><span class="line">        i = p - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = p; j &lt; r; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[j] &lt;= x) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            EXCHANGE(A[j], A[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    EXCHANGE(A[r], A[i + <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RANDOMIZED_SELECT</code> 的运行过程如下:</p>
<ul>
<li><code>if (p == r)</code> 检查递归的基本情况, 即数组 $A[p..r]$ 中只包含一个元素.</li>
<li><code>randomized_partition(A, p, r)</code> 将数组 $A[p..r]$ 划分为两个可能为空的子数组 $A[p..q - 1]$ 和  $A[q + 1..r]$, 使得前者中每个元素都小于 $A[p]$, 后者大于 $A[p]$, 其中  $A[q]$ 为主元.</li>
<li><code>k = q - p + 1</code> 计算子数组 $A[p..q]$ 中的元素个数, 及处于划分的低区的元素的个数加 $1$, $1$ 为主元素..</li>
<li><code>if (i == k)</code> 检查 $A[q]$ 是否是第 $i$ 小的元素, 如果是就返回 <code>RANDOMIZED_SELECT(A, p, q - 1, i)</code>, 如果是直接返回 $A[q]$, 否则返回 <code>RANDOMIZED_SELECT(A, q + 1, r, i - k)</code>, 其中 $i-k$ 为元素在高区的相对位置.</li>
</ul>
<p><code>RANDOMIZED_SELECT</code> 的最坏情况的运行时间为 $\Theta (n^2)$. 这样的运行时间并不是我们需要的, 下面我们将介绍一种效率更高的选择算法.</p>
<h1 id="最坏情况为线性时间的选择算法">最坏情况为线性时间的选择算法</h1><p>我们现在来介绍一个最坏情况的运行时间 $O(n)$ 的选择算法. 像 <code>RANDOMIZED_SELECT</code> 算法一样, <code>SELECT</code> 算法通过对输入数组的递归划分来找出所需的元素. 它使用的也是来自快速排序的确定性划分算法, <code>PARTITION</code>.</p>
<p>通过执行一下步骤, 算法可以确定一个有 $n&gt;1$ 个不同元素的输入数组中第 $i$ 小的元素:</p>
<ol>
<li>将输入数组的 $n$ 个元素划分成 $\left \lceil{x/5}\right \rceil$ , 每组 $5$ 个元素, 且至多由剩下的 $n mod 5$ 个元素组成.</li>
<li>寻找这 $\left \lfloor{x/5}\right \rfloor$ 组中每一组饿中位数: 首先对每组元素进行插入排序, 然后确定中位数.</li>
<li>对第 $2$ 步中找出的 $\left \lceil{x/5}\right \rceil$ 个中位数, 递归调用 <code>SELECT</code> 以找出其中位数 $x$.</li>
<li>利用修改过的 <code>partition</code> 版本, 按中位数的中位数 $x$ 对输入数组进行划分. 让 $k$ 比划分的低区中的元素数目多 $1$. 因此 $x$ 是第 $k$ 小的元素, 并且有 $n-k$ 个元素在划分的高区.</li>
<li>如果 $i=k$, 则返回 $x$. 如果 $i<k$, 则在低区递归调用="" `select`="" 已找出第="" $i$="" 小的元素.="" 如果="" $i="">k$ 小的元素.</k$,></li>
</ol>
<p>如果划分的主元素为 $x$, 至少有一半大于或等于中位数的中位数 $x$. 只要有一半的组中有 $3$ 个元素大于 $x$, 不算中间这个组, 大于 $x$ 的元素个数只要为:</p>
<p>$$3(\left \lceil \frac{1}{2}\left \lceil{\frac{n}{5}}\right \rceil \right \rceil) \geq \frac{3n}{10}$$</p>
<p>所以我们现在有一个递归式来推导 <code>SELECT</code> 算法的最坏情况的运行时间 $T(n)$了.</p>
<p>$$T(n) \leq \begin{cases}<br> &amp; O(1) &amp; \text{ if } n &lt; 140 \\<br> &amp; T(\left \lceil{x/5}\right \rceil) + T(7n/10+6) + O(n) &amp; \text { if } n \geq 140<br>\end{cases}$$</p>
<p>所以, 可以得到 $T(n) = O(n)$.</p>
<p>与比较排序一样, <code>SELECT</code> 和 <code>RANDOMIZED_SELECT</code> 也是通过元素之间的比较来确定它们之间的相对次序的.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="顺序统计量">顺序统计量</h1><p>在一个由 $n$ 个元素组成的集合中, 第 $i$ 个顺序统计量 (order statistic) 是该集合中第 $i$ 小的元素.</p>
<ul>
<li><strong>最小值</strong>是第 $1$ 个顺序统]]>
    </summary>
    
      <category term="Algorithm" scheme="http://deltax.me/tags/Algorithm/"/>
    
      <category term="clrs" scheme="http://deltax.me/categories/clrs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Object-Oriented-Programming and Other Programming Paradigms]]></title>
    <link href="http://deltax.me/2015/03/26/Object-Oriented-Programming-and-Other-Programming-Paradigms/"/>
    <id>http://deltax.me/2015/03/26/Object-Oriented-Programming-and-Other-Programming-Paradigms/</id>
    <published>2015-03-26T11:09:33.000Z</published>
    <updated>2015-03-26T13:29:00.000Z</updated>
    <content type="html"><![CDATA[<p>Object-Oriented Programming is one way to structure programs which is most often used together with explicit state. The main difference between this computational model to other is <strong>polymorphism</strong> and <strong>inheritance</strong>.</p>
<p>In my opinion, this computational model is important but not magic. There are many opponents and different ideas.</p>
<p><a href="https://www.quora.com/Was-object-oriented-programming-a-failure" target="_blank" rel="external">Was object-oriented programming a failure?</a></p>
<p><a href="https://www.quora.com/What-are-some-programming-paradigms-other-than-Object-Oriented" target="_blank" rel="external">What are some programming paradigms other than Object Oriented?</a></p>
<h1 id="Higher-order_Programming">Higher-order Programming</h1><p>Object-oriented programming and high-order programming are closely related. A new sorting routine can be created by giving a particular order function.</p>
<p>We can write this in high-order programming:</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">proc</span> &#123;<span class="type">NewSortRoutine</span> <span class="type">Order</span> ?<span class="type">SortRoutine</span>&#125;</span><br><span class="line">	<span class="keyword">proc</span> &#123;<span class="type">SortRoutine</span> <span class="type">InL</span> <span class="type">OutL</span>&#125;</span><br><span class="line">		% ... &#123;<span class="type">Order</span> X Y&#125; calculates order</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">proc</span> &#123;<span class="type">Order</span> X Y ?B&#125;</span><br><span class="line">	B=(X&lt;Y)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="type">SortRoutine</span>=&#123;<span class="type">NewSortRoutine</span> <span class="type">Order</span>&#125;</span><br></pre></td></tr></table></figure>
<p>In <code>OOP</code>, this can be written as follows:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">SortRoutineClass</span></span><br><span class="line">	attr ord</span><br><span class="line">	meth init<span class="container">(<span class="type">Order</span>)</span></span><br><span class="line">		ord:=<span class="type">Order</span></span><br><span class="line">	end</span><br><span class="line">	meth sort<span class="container">(<span class="type">InL</span> <span class="type">OutL</span>)</span></span><br><span class="line">		% ... &#123;@ord order<span class="container">(<span class="type">X</span> <span class="type">Y</span> $)</span>&#125; calculates order</span><br><span class="line">	end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="type">OrderClass</span></span><br><span class="line">	meth init skip end</span><br><span class="line">	meth order<span class="container">(<span class="type">X</span> <span class="type">Y</span> <span class="type">B</span>)</span></span><br><span class="line">		<span class="type">B</span>=<span class="container">(<span class="type">X</span>&lt;<span class="type">Y</span>)</span></span><br><span class="line">	end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="type">SortRoutine</span>=&#123;<span class="type">New</span> <span class="type">SortRoutineClass</span> init<span class="container">(&#123;<span class="type">New</span> <span class="type">OrderClass</span> <span class="title">init</span>&#125;)</span>&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="Embellishments">Embellishments</h2><p>Procedure values and objects are closed related. Let us now compare higher-order and object-oriented programming more carefully.</p>
<p>The main difference is that <code>OOP</code> embellishes high-order programming. With embellishments, object-oriented provides a collection of additional idioms beyond procedural abstraction:</p>
<ul>
<li>Explicit state can be defined and used easily.</li>
<li>Multiple methods that share the same explicit state can be defined easily.</li>
<li>Classes are provided, which define a set of methods and can be instantiated. If objects are like procedures, then classes are like procedures that return procedures.</li>
<li>Inheritance is provided, to define new sets of methods from existing sets.</li>
<li>Different degrees of encapsulation can be defined between classes and obejcts.</li>
</ul>
<p>These mechanisms do not provide any fundamentally new ability. All these things can be implemented with high-order programming, explicit state and name values.</p>
<p><code>OOP</code> is an abstraction that provides a rich notation to use any or all of these mechanisms together. But this is a double-edged sword.</p>
<ul>
<li>It makes the abstraction particularly useful for many programming tasks.</li>
<li>The abstraction has a complex semantics and is hard to reason about.</li>
</ul>
<h2 id="Common_Limitations">Common Limitations</h2><p>The object system defined here is particularly close to high-order programming. But not all the object system is so close. In common use, the following characteristics are aften absent or cumbersome to use:</p>
<ul>
<li>Classes are values<ul>
<li>Classes can be created at run time, passed as arguments, and stored in data structures.</li>
</ul>
</li>
<li>Full lexical scoping<ul>
<li>Language supports procedure values with external references.</li>
</ul>
</li>
<li>First-class messages<ul>
<li>Allow messages to be values in the languages.</li>
</ul>
</li>
</ul>
<p>There are also some object-oriented languages do not support high-order programming because they define procedure values with lexical scoping at run time. Many of the mechanisms can be obtained through inheritanceand encapsulation.</p>
<ul>
<li>A procedure value can be encoded as object.<ul>
<li>The object’s attributes represent the procedure value’s external references and the method arguments are the procedure value’s arguments.</li>
</ul>
</li>
<li>A generic procedure can be encoded as an abstract class.<ul>
<li>A generic procedure is one that tkes procedure arguments and return a specific procedure. An abstract class is a class with undefined methods. And the methods are implemented in subclasses.</li>
</ul>
</li>
</ul>
<h2 id="Should_everything_be_an_object?">Should everything be an object?</h2><p>Now, let us discover the practical of everything is object.</p>
<h3 id="String_Objects">String Objects</h3><p>A sensible way to define the principle is as “all language entities should be instances of data abstractions with as many generic properties as possible.” There are six properties this principle implies.</p>
<ul>
<li>All language entities should be defined with the object style.</li>
<li>All language entities should be defined in the terms of classes can be instantiated.</li>
<li>All language entities should be extensible with inheritance.</li>
<li>All language entities should have a unique identity.</li>
<li>All language entities should excapsulate a state.</li>
<li>All language entities should be accessed with a uniform syntax.</li>
</ul>
<p>In most languages, not all entities are strong objects. An integer in Objective-C is a pure value in the <code>ADT</code> style. It is not defined by a class or encapsulate a state. </p>
<p>And there is not any language only have strong objects.</p>
<ol>
<li>The ADT style is sometimes essential.</li>
<li>Stateless entities can play an important role.</li>
<li>Not all entities need a unique identity.</li>
<li>The simplicity of a uniform syntax is illusory.</li>
</ol>
<p>With them, the powerful reasoning techniques of declarative programming become possible.</p>
<h3 id="Objects_and_program_complexity">Objects and program complexity</h3><p>How can one predict a particular object’s behavior. It depends on two factor:</p>
<ol>
<li>Its internal state, which potentially depends on all past calls. These calls can be done from many parts of the program.</li>
<li>Its textual definiation, which depends on all classes it inherits from. These classes can be defined in many places in the program text.</li>
</ol>
<h3 id="Uniform_object_syntax">Uniform object syntax</h3><p>A language’s syntax should help and not hinder programmers in designing, writing and reasoning about programs. An important principle  in syntax design is form mirrors content.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Object-Oriented Programming is one way to structure programs which is most often used together with explicit state. The main difference b]]>
    </summary>
    
      <category term="CTMCP" scheme="http://deltax.me/tags/CTMCP/"/>
    
      <category term="OOP" scheme="http://deltax.me/tags/OOP/"/>
    
      <category term="Oz" scheme="http://deltax.me/tags/Oz/"/>
    
      <category term="Programming Paradigm" scheme="http://deltax.me/categories/Programming-Paradigm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Programming with Inheritance]]></title>
    <link href="http://deltax.me/2015/03/26/Programming-with-Inheritance/"/>
    <id>http://deltax.me/2015/03/26/Programming-with-Inheritance/</id>
    <published>2015-03-26T04:03:48.000Z</published>
    <updated>2015-03-26T07:22:46.000Z</updated>
    <content type="html"><![CDATA[<h1 id="How_to_use_Inheritance">How to use Inheritance</h1><p>There are two ways to view inheritance. </p>
<ul>
<li>The <strong>type</strong> view<blockquote>
<p>Classes are types and subclasses are subtypes. The type view is consistent with the principle that classes should model real-world entities or some abstract versions of them. In type view, classes satisfy the substitution property: every operation works on class <code>C</code> also works on subclass of <code>C</code>.</p>
</blockquote>
</li>
<li>The <strong>structure</strong> view<blockquote>
<p>Inheritance is just another programming tool that is used to structure programs. This view is strongly discouraged bacause classes no longer satisfy the substituion property.</p>
</blockquote>
</li>
</ul>
<p>In the type view, each class stands on its own two feet. And in the structure view, classes are sometimes just scaffolding, which exists only for its role in structuring he program.</p>
<p>In the vast majority of cases, inheritance shuld respect the type view. And the rest of this blog is mainly consider the type view.</p>
<h2 id="Desin_by_Contract">Desin by Contract</h2><p>Based on the teniques such as using aximatic semantics of the formal semantics, Bertrand Mayer has developed a method for designing correct programs called <strong>design by contract</strong> and implement it.</p>
<p>The principle idea of design by contract is that a data abstraction implies a contract between the abstraciton’s designer and its users.</p>
<ul>
<li>The user must guarantee that an abstraction is called in the right way.</li>
<li>The designer must guarantee that the right value is returned after the procedure executed.</li>
</ul>
<p>The user is responsible for the preconditions and the disigner is responsible for the postconditions.</p>
<p>In the data abstraction, we should check if the precondition is valid and the user followed the contract. This is checked at boundary when the data abstraction is called which can be in either runtime or compile time.</p>
<h2 id="Things_should_Prevented">Things should Prevented</h2><p>There are such things that we should not use when dealing with inheritance.</p>
<ul>
<li>The subsitution property was regularly violated.</li>
<li>Classes were subclassed to fix small problems.</li>
</ul>
<p>The most important principle using inheritance is to use it add new functionality and not to patch a broken class.</p>
<h2 id="Reengineering">Reengineering</h2><p>The general goal of reengnnering is to take an exisinting system and attempt to improve some of its property by changing the source code. However reengineering cannot resurrect a failed project.</p>
<h1 id="Generic_Classes">Generic Classes</h1><p>A generic class is one that only defines part of the functionality of a data abstraction. It has to be completely before it can be used to create objects. How can we define generic class, there are two ways for us to make it.</p>
<h2 id="Using_Inheritance">Using Inheritance</h2><p>A common way to use generic class is to use abstract classes. </p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericSort</span></span></span><br><span class="line">   meth init skip <span class="keyword">end</span></span><br><span class="line">   meth qsort(<span class="constant">Xs</span> <span class="constant">Ys</span>)</span><br><span class="line">      <span class="keyword">case</span> <span class="constant">Xs</span></span><br><span class="line">      of <span class="keyword">nil</span> <span class="keyword">then</span> <span class="constant">Ys</span>=<span class="keyword">nil</span></span><br><span class="line">      [] <span class="constant">P</span>|<span class="constant">Xr</span> <span class="keyword">then</span> <span class="constant">S</span> <span class="constant">L</span> <span class="keyword">in</span></span><br><span class="line">	 &#123;<span class="keyword">self</span> partition(<span class="constant">Xr</span> <span class="constant">P</span> <span class="constant">S</span> <span class="constant">L</span>)&#125;</span><br><span class="line">	 &#123;<span class="constant">Append</span> &#123;<span class="keyword">self</span> qsort(<span class="constant">S</span> <span class="variable">$)</span>&#125;</span><br><span class="line">	  <span class="constant">P</span>|&#123;<span class="keyword">self</span> qsort(<span class="constant">L</span> <span class="variable">$)</span>&#125; <span class="constant">Ys</span>&#125;</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   meth partition(<span class="constant">Xs</span> <span class="constant">P</span> <span class="constant">Ss</span> <span class="constant">Ls</span>)</span><br><span class="line">      <span class="keyword">case</span> <span class="constant">Xs</span></span><br><span class="line">      of <span class="keyword">nil</span> <span class="keyword">then</span> <span class="constant">Ss</span>=<span class="keyword">nil</span> <span class="constant">Ls</span>=<span class="keyword">nil</span></span><br><span class="line">      [] <span class="constant">X</span>|<span class="constant">Xr</span> <span class="keyword">then</span> <span class="constant">Sr</span> <span class="constant">Lr</span> <span class="keyword">in</span></span><br><span class="line">	 <span class="keyword">if</span> &#123;<span class="keyword">self</span> less(<span class="constant">X</span> <span class="constant">P</span> <span class="variable">$)</span>&#125; <span class="keyword">then</span></span><br><span class="line">	    <span class="constant">Ss</span>=<span class="constant">X</span>|<span class="constant">Xr</span> <span class="constant">Ls</span>=<span class="constant">Lr</span></span><br><span class="line">	 <span class="keyword">else</span></span><br><span class="line">	    <span class="constant">Ss</span>=<span class="constant">Sr</span> <span class="constant">Ls</span>=<span class="constant">X</span>|<span class="constant">Lr</span></span><br><span class="line">	 <span class="keyword">end</span></span><br><span class="line">	 &#123;<span class="keyword">self</span> partition(<span class="constant">Xr</span> <span class="constant">P</span> <span class="constant">Sr</span> <span class="constant">Lr</span>)&#125;</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>This block of codes define an abstract class <code>GenericSort</code> which remains the method <code>less</code> undefined for subclasses.</p>
<p>So we define this method is subclass <code>IntegerSort</code> and <code>RationalSort</code>.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">IntegerSort</span> from <span class="type">GenericSort</span></span><br><span class="line">   meth less<span class="container">(<span class="type">X</span> <span class="type">Y</span> <span class="type">B</span>)</span></span><br><span class="line">      <span class="type">B</span>=<span class="container">(<span class="type">X</span>&lt;<span class="type">Y</span>)</span></span><br><span class="line">   end</span><br><span class="line">end</span><br><span class="line"><span class="keyword">class</span> <span class="type">RationalSort</span> from <span class="type">GenericSort</span></span><br><span class="line">   meth less<span class="container">(<span class="type">X</span> <span class="type">Y</span> <span class="type">B</span>)</span></span><br><span class="line">      '/'<span class="container">(<span class="type">P</span> <span class="type">Q</span>)</span>=<span class="type">X</span></span><br><span class="line">      '/'<span class="container">(<span class="type">R</span> <span class="type">S</span>)</span>=<span class="type">Y</span></span><br><span class="line">   in <span class="type">B</span>=<span class="container">(<span class="type">P</span>*<span class="type">S</span>&lt;<span class="type">Q</span>*<span class="type">R</span>)</span> end</span><br><span class="line">end</span></span><br></pre></td></tr></table></figure>
<p>The abstraction is really powerful, we can subclass <code>GenericSort</code> and implement <code>less</code> method to sort any kinds of data we want.</p>
<p>But this is just a syntactic sugar for high-order programming.</p>
<h2 id="Using_Higher-order_Programming">Using Higher-order Programming</h2><p>There is a second natual way to create generic classes, namely by using higher-order programming directly. Now we can define a function which takes some arguments and returns a class that is specialized with these arguments.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">fun &#123;<span class="constant">MakeSort</span> <span class="constant">Less</span>&#125;</span><br><span class="line">   <span class="class"><span class="keyword">class</span> $</span></span><br><span class="line">      meth init skip <span class="keyword">end</span></span><br><span class="line">      meth qsort(<span class="constant">Xs</span> <span class="constant">Ys</span>)</span><br><span class="line">	 <span class="keyword">case</span> <span class="constant">Xs</span></span><br><span class="line">	 of <span class="keyword">nil</span> <span class="keyword">then</span> <span class="constant">Ys</span>=<span class="keyword">nil</span></span><br><span class="line">	 [] <span class="constant">P</span>|<span class="constant">Xr</span> <span class="keyword">then</span> <span class="constant">S</span> <span class="constant">L</span> <span class="keyword">in</span></span><br><span class="line">	    &#123;<span class="keyword">self</span> partition(<span class="constant">Xr</span> <span class="constant">P</span> <span class="constant">S</span> <span class="constant">L</span>)&#125;</span><br><span class="line">	    &#123;<span class="constant">Append</span> &#123;<span class="keyword">self</span> qsort(<span class="constant">S</span> <span class="variable">$)</span>&#125;</span><br><span class="line">	     <span class="constant">P</span>|&#123;<span class="keyword">self</span> qsort(<span class="constant">L</span> <span class="variable">$)</span>&#125; <span class="constant">Ys</span>&#125;</span><br><span class="line">	 <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      meth partition(<span class="constant">Xs</span> <span class="constant">P</span> <span class="constant">Ss</span> <span class="constant">Ls</span>)</span><br><span class="line">	 <span class="keyword">case</span> <span class="constant">Xs</span></span><br><span class="line">	 of <span class="keyword">nil</span> <span class="keyword">then</span> <span class="constant">Ss</span>=<span class="keyword">nil</span> <span class="constant">Ls</span>=<span class="keyword">nil</span></span><br><span class="line">	 [] <span class="constant">X</span>|<span class="constant">Xr</span> <span class="keyword">then</span> <span class="constant">Sr</span> <span class="constant">Lr</span> <span class="keyword">in</span></span><br><span class="line">	    <span class="keyword">if</span> &#123;<span class="constant">Less</span> <span class="constant">X</span> <span class="constant">P</span>&#125; <span class="keyword">then</span></span><br><span class="line">	       <span class="constant">Ss</span>=<span class="constant">X</span>|<span class="constant">Sr</span> <span class="constant">Ls</span>=<span class="constant">Lr</span></span><br><span class="line">	    <span class="keyword">else</span></span><br><span class="line">	       <span class="constant">Ss</span>=<span class="constant">Sr</span> <span class="constant">Ls</span>=<span class="constant">X</span>|<span class="constant">Lr</span></span><br><span class="line">	    <span class="keyword">end</span></span><br><span class="line">	    &#123;<span class="keyword">self</span> partition(<span class="constant">Xr</span> <span class="constant">P</span> <span class="constant">Sr</span> <span class="constant">Lr</span>)&#125;</span><br><span class="line">	 <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>The function <code>MakeSort</code> take an argument <code>Less</code> which compares two elements and returns a bool value. And the function returns a class, that can sort different kinds of element.</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">IntegerSort</span>=<span class="tuple">&#123;<span class="variable">MakeSort</span> <span class="keyword">fun</span> <span class="tuple">&#123;$ <span class="variable">X</span> <span class="variable">Y</span>&#125;</span> <span class="variable">X</span>&lt;<span class="variable">Y</span> <span class="keyword">end</span>&#125;</span></span><br><span class="line"><span class="variable">RationalSort</span>=<span class="tuple">&#123;<span class="variable">MakeSort</span> <span class="keyword">fun</span> <span class="tuple">&#123;$ <span class="variable">X</span> <span class="variable">Y</span>&#125;</span></span><br><span class="line">						'/'(<span class="variable">P</span> <span class="variable">Q</span>)=<span class="variable">X</span></span><br><span class="line">						'/'(<span class="variable">R</span> <span class="variable">S</span>)=<span class="variable">Y</span></span><br><span class="line">					   in <span class="variable">P</span>*<span class="variable">S</span>&lt;<span class="variable">Q</span>*<span class="variable">R</span> <span class="keyword">end</span>&#125;</span></span><br></pre></td></tr></table></figure>
<p>And then we can use these as this:</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ISort=<span class="list">&#123;New IntegerSort init&#125;</span></span><br><span class="line"><span class="list">&#123;Browse &#123;ISort qsort([1 2 4 5 6 3] $)&#125;</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Discussion">Discussion</h2><p>What is the different between the two techniques? </p>
<ul>
<li>In most programming languags, the inheritance must be defined at compile time. This gives static genericity. So the compiler can generate better code or do more checking.</li>
<li>High-order programming, when it is possible lets us define dynamic genericity which is much more flexible.</li>
</ul>
<h1 id="Mutiple_Inheritance">Mutiple Inheritance</h1><p>Mutiple inheritance is useful when an object has to be two different things in the same program.</p>
<h2 id="Rules_about_Mutiple_Inheritance">Rules about Mutiple Inheritance</h2><p>Mutiple inheritance is powerful technique that has to be used care.</p>
<ul>
<li>Mutiple inheritance works well when combing two <strong>completely independant abstraction</strong>.</li>
<li>Mutiple inheritance is much harder to use correctly when the abstraction has much in common, this always causes name label conflicts.</li>
</ul>
<p>See more in this post: <a href="http://deltax.me/2014/11/22/Multiple%20Inheritence/" target="_blank" rel="external">Mutiple Inheritance</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="How_to_use_Inheritance">How to use Inheritance</h1><p>There are two ways to view inheritance. </p>
<ul>
<li>The <strong>type</strong]]>
    </summary>
    
      <category term="CTMCP" scheme="http://deltax.me/tags/CTMCP/"/>
    
      <category term="OOP" scheme="http://deltax.me/tags/OOP/"/>
    
      <category term="Oz" scheme="http://deltax.me/tags/Oz/"/>
    
      <category term="Programming Paradigm" scheme="http://deltax.me/categories/Programming-Paradigm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo中LateX的使用]]></title>
    <link href="http://deltax.me/2015/03/25/Hexo%E4%B8%ADLateX%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://deltax.me/2015/03/25/Hexo中LateX的使用/</id>
    <published>2015-03-25T12:22:48.000Z</published>
    <updated>2015-03-25T12:45:14.000Z</updated>
    <content type="html"><![CDATA[<p>我使用 <code>Hexo</code> 已经有很长时间了, 最近升级到 3.0 问题实在是太多. 不过实在是不想在折腾回去了.</p>
<p>最近在学习算法导论, 需要解决很多的公式问题, 所以, 我求助于 <code>LaTeX</code>. <code>LaTeX</code> 是一种基于 <code>TEX</code> 的排版. 我们可以使用它来生成许多的数学公式. 我在这里就简单介绍一下如何使用好了.</p>
<h1 id="准备工作">准备工作</h1><p>如果你是用的 <code>Hexo</code> 主题是 <code>Jacman</code>, 那么非常简单, 你只需要在 <code>front-matter</code> 中添加:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mathjax:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>这样就可以在 markdown 中随意使用 <code>LaTeX</code> 了, 对于我来说, 我直接找到主题资源文件中与 MathJax 有关的代码</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">themes<span class="regexp">/jacman/</span>layout<span class="regexp">/_partial/m</span>athjax.ejs</span><br></pre></td></tr></table></figure>
<p>也就是这个文件, 删除掉第一行和最后一行, 也就是下面这两行.</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="preprocessor">%</span> <span class="keyword">if</span> <span class="comment">(theme.mathjax || page.mathjax)</span>&#123; <span class="preprocessor">%</span>&gt;</span><br><span class="line">&lt;<span class="preprocessor">%</span> &#125; <span class="preprocessor">%</span>&gt;</span><br></pre></td></tr></table></figure>
<p>然后, 你就不要在每次添加 <code>mathjax: true</code> 了, 你也可以去更改你的模板 <code>scaffolds/post.md</code> 在其中加入以下代码, 也可以省去每次添加的麻烦.</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mathjax:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h1 id="LaTeX使用">LaTeX使用</h1><p>做好了准备工作之后, 我们就可以尝试在 post 中添加 <code>LaTeX</code> 公式了, 你可以上网找一些在线的 editor 帮助你写 <code>LaTeX</code> 公式.</p>
<p>我们做几个简单的演示:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$T</span>(n) = \<span class="function"><span class="title">Theta</span><span class="params">(n)</span></span>$</span><br></pre></td></tr></table></figure>
<p>$T(n) = \Theta(n)$</p>
<p><code>LaTeX</code> 需要使用 <code>$</code> 符号进行包围, 当我最开始使用的时候不知道在公式的两边都要加入 <code>$</code> 符号, 所以出现了这样的错误</p>
<p>$T(n) = \Theta(n)</p>
<p><code>LaTeX</code> 公式不会被渲染, 使用单个的 <code>$</code> 符号时时候, 我们可以在行内中添加, 但是如果想在整行内使用, 我们使用双 <code>$</code> 符号, 也就是:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$<span class="variable">$T</span>(n) = \<span class="function"><span class="title">Theta</span><span class="params">(n)</span></span>$$</span><br></pre></td></tr></table></figure>
<p>$$T(n) = \Theta(n)$$</p>
<p>更多的使用方法以及文档可以访问 <a href="https://www.mathjax.org/" target="_blank" rel="external">MathJax</a>.</p>
<h1 id="LaTeX使用的问题">LaTeX使用的问题</h1><p>我在是用LaTeX的过程中遇到了这样一种问题, 当我使用下面这个公式的时候, <code>LaTeX</code> 公式不会被渲染.</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$<span class="label">$T</span>(<span class="keyword">n</span>) = \Theta(<span class="keyword">n</span>) + \sum_&#123;i=0&#125;^&#123;<span class="keyword">n</span>-1&#125;&#123;O(&#123;<span class="keyword">n</span>&#125;_&#123;i&#125;^2)&#125;$$</span><br></pre></td></tr></table></figure>
<p>$$T(n) = \Theta(n) + \sum<em>{i=0}^{n-1}{O({n}</em>{i}^2)}$$</p>
<p>我在官网上尝试了一下, 发现这个公式是完全正确的, 当时百思不得其解, 后来突然发现这个公式的中间部分 <code>{i=0}^{n-1}{O({n}</code> 竟然是倾斜的.</p>
<p>在 Markdown 中, <code>_ _</code> 表示的是中间部分的倾斜, 所以我就将这个公式改成了:</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$<span class="label">$T</span>(<span class="keyword">n</span>) = \Theta(<span class="keyword">n</span>) + \<span class="keyword">sum</span>\_&#123;i=0&#125;^&#123;<span class="keyword">n</span>-1&#125;&#123;O(&#123;<span class="keyword">n</span>&#125;\_&#123;i&#125;^2)&#125;$$</span><br></pre></td></tr></table></figure>
<p>加了两个用于转义的 <code>\</code> 符号, 这样, 公式就可以正确的显示了.</p>
<p>$$T(n) = \Theta(n) + \sum_{i=0}^{n-1}{O({n}_{i}^2)}$$</p>
<h1 id="结束">结束</h1><p>初次体验感觉 <code>LaTeX</code> 还是很强大的, 可以非常轻易的表示各种各样的数学公式, 不过遇到比较复杂的公式, 还是很难一次性完成的, 而且对于已经写好的 <code>LaTeX</code>, 有的实在太过于庞大并且复杂了, 完全无法理解到底是什么意思.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>我使用 <code>Hexo</code> 已经有很长时间了, 最近升级到 3.0 问题实在是太多. 不过实在是不想在折腾回去了.</p>
<p>最近在学习算法导论, 需要解决很多的公式问题, 所以, 我求助于 <code>LaTeX</code>. <code>LaTeX]]>
    </summary>
    
      <category term="Hexo" scheme="http://deltax.me/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[线性时间排序]]></title>
    <link href="http://deltax.me/2015/03/25/%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E6%8E%92%E5%BA%8F/"/>
    <id>http://deltax.me/2015/03/25/线性时间排序/</id>
    <published>2015-03-25T08:20:40.000Z</published>
    <updated>2015-03-25T12:22:06.000Z</updated>
    <content type="html"><![CDATA[<p>我们把在排序的最终结果中, 各元素的次序依赖于它们的比较的排序算法称为<strong>比较排序</strong>. 而我们在这里介绍的排序将不依赖于元素之间的比较.</p>
<p>第一次听到这种说法感觉非常的神奇和震惊, 而在以前的认识中, 排序都是基于比较的. 不经过比较怎么排序, 而这一章线性时间排序就改变了我过去对排序的浅显的认识.</p>
<h1 id="比较排序算法的下届">比较排序算法的下届</h1><p>我们如何才能使排序的时间复杂度达到线性呢, 能否通过元素之间的比较产生一种排序时间复杂度为线性的算法呢.</p>
<p>结论是: 不可能, 比较排序算法最坏情况下的时间复杂度的下届为 $\Theta\left(n\lg n\right)$. 这是为什么呢, 我们可以用<a href="http://zh.wikipedia.org/wiki/%E5%86%B3%E7%AD%96%E6%A0%91" target="_blank" rel="external">决策树</a>模型来证明下届的正确性.</p>
<p>考虑一棵高度为 $h$, 具有 $l$ 个可达的叶结点的决策树, 它对应一个对 $n$ 个元素所做的比较排序, 因为输入数据的 $n!$ 种可能的排列都是叶结点, 并且叶的数目不多于 ${2}^{n}$, 所以, 我们得到:</p>
<p>$$n! \leq l \leq {2}^{n}$$</p>
<p>对该式两边取对数:</p>
<p>$$\begin{align}<br>    h \geq \lg(n!) = \Omega(n\lg n)<br>   \end{align}$$</p>
<p>所以我们可以观察到堆排序和快速排序都是渐近最优的排序算法, 上届为 $O(n \lg n)$.</p>
<h1 id="计数排序(Counting-Sort)">计数排序(Counting-Sort)</h1><p><strong>计数排序</strong>假设 $n$ 个输入元素中的每一个都是在 $0$ 到 $k$ 区间的一个整数. 当 $k=O(n)$ 时, 排序的运行时间为 $\Theta(n)$.</p>
<p>计数排序的基本思想是, 对于每一个输入元素 $x$, 确定小于 $x$ 的元素个数 $n$, 然后把元素 $x$ 直接放到第 $n+1$ 的位置.</p>
<p>我们使用如下代码实现计数排序.</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> counting_sort(<span class="keyword">int</span> A[], <span class="keyword">int</span> B[], <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">int</span> C[k+<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        C[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">length</span>(A); j++) &#123; C[A[j]]++; &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123; C[i] += C[i-<span class="number">1</span>]; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="built_in">length</span>(A) - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">        B[C[A[j]]] = A[j];</span><br><span class="line">        C[A[j]]--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码中, <code>A[]</code> 为输入数组, <code>B[]</code> 为输出数组, <code>C[]</code>提供临时存储空间, 下面我们来分析这段代码.</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for <span class="comment">(int i = 0; i &lt;= k; i++)</span> &#123;</span><br><span class="line">    C[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码运行过后, 数组 <code>C[]</code> 中的所有元素都被初始化为 <code>0</code>, $T(n)=\Theta(k)$</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (int <span class="built_in">j</span> = <span class="number">0</span>; <span class="built_in">j</span> &lt; <span class="built_in">length</span>(A); <span class="built_in">j</span>++) <span class="cell">&#123; C[A[j]]++; &#125;</span></span><br></pre></td></tr></table></figure>
<p>循环的过程中, <code>A[]</code> 数组中的每一个元素都会使 <code>C[]</code> 数组中的对应元素 <code>+1</code>. 循环结束后, <code>C[]</code> 数组中的元素为, 对应索引出现在 <code>A[]</code> 数组中的次数, $T(n)=\Theta(n)$</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for <span class="comment">(int i = 1; i &lt;= k; i++)</span> &#123; C[i] += C[i<span class="number">-1</span>]; &#125;</span><br></pre></td></tr></table></figure>
<p>通过累加, 计算确定对每一个 $i=0, 1, …, k$, 有多少元素是小于或等于 $i$ 的, $T(n)=\Theta(k)$</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (int <span class="built_in">j</span> = <span class="built_in">length</span>(A) - <span class="number">1</span>; <span class="built_in">j</span> &gt;= <span class="number">0</span>; <span class="built_in">j</span>--) <span class="cell">&#123;</span><br><span class="line">    B[C[A[j]]] = A[j];</span><br><span class="line">    C[A[j]]--;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>最后这段代码把 <code>A[]</code> 中的元素, 通过 <code>C[]</code> 中的索引放到恰当的位置,, $T(n)=\Theta(n)$</p>
<p>所以总的时间代价就是 $T(n)=\Theta(n+k)$, 当 $k=O(n)$ 时, 我们一般会使用计数排序, 这样的运行时间为 $\Theta(n)$.</p>
<p>计数排序的另一个重要性质就是它是稳定的, 具有相同值的元素在输出数组中的相对顺序不变, 而这点的主要原因就是</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (int <span class="built_in">j</span> = <span class="built_in">length</span>(A) - <span class="number">1</span>; <span class="built_in">j</span> &gt;= <span class="number">0</span>; <span class="built_in">j</span>--)</span><br></pre></td></tr></table></figure>
<p>如果把这段代码换成</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (int <span class="built_in">j</span> = <span class="number">0</span>; <span class="built_in">j</span> &lt; <span class="built_in">length</span>(A); <span class="built_in">j</span>++)</span><br></pre></td></tr></table></figure>
<p>那么计数排序就是不稳定的.</p>
<h1 id="基数排序(Radix-Sort)">基数排序(Radix-Sort)</h1><p>我们了解了计数排序之后, 接下来介绍另一种排序方法, <strong>基数排序</strong>.</p>
<p>基数排序是将整数按位数切割成不同的数字, 然后按照每个位数进行比较.</p>
<p><img src="http://deltax.qiniudn.com/radix-sort.png?attname=&e=1427369778&token=YJb_IPQrTSw1ox9LenQDH1HRcgHii9w_bp9ddmcz:d-0v6wSh1j09MH_agrIH_Q0DrN0" style="display:block;margin:auto"></p>
<p>为了保证基数排序的准确性, <strong>一位数排序算法必须是稳定的</strong>.</p>
<p>基数排序的实现如下</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void<span class="function"> radix_sort(</span>int A<span class="keyword">[</span>],<span class="instruction"> int </span>d<span class="function">)</span> &#123;</span><br><span class="line">	for<span class="function"> (</span>int i = 0; i &lt; d; i++<span class="function">)</span> &#123;</span><br><span class="line">		Use a stable sort to sort<span class="instruction"> array </span>A on digit i</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用计数排序与基数排序结合, 那么就可以在 $\Theta(d(n+k))$ 时间内排好序.</p>
<h1 id="桶排序(Bucket-Sort)">桶排序(Bucket-Sort)</h1><p><strong>桶排序</strong>假设输入数据服从均匀分布, 平均情况下它的时间代价为 $O(n)$.</p>
<p><img src="http://deltax.qiniudn.com/bucket-sort.png?attname=&e=1427371034&token=YJb_IPQrTSw1ox9LenQDH1HRcgHii9w_bp9ddmcz:D0HE4QlDxJZ455IPQX7uhNNJ_aA" style="display:block;margin:auto"></p>
<p>假设输入数据分布在 $[0..1)$ 区间中, 我们需要一个临时数组 <code>B[0..n-1]</code> 来存放链表. 我们接下来将实现桶排序.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bucket_sort</span><span class="params">(<span class="keyword">int</span> A[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = length(A);</span><br><span class="line">    <span class="keyword">int</span> B[n];</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        B[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        append(B[<span class="keyword">int</span>(n * A[i])], A[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        insertion_sort(B[i]);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (B[i].head) &#123;</span><br><span class="line">            A[j] = B[i].head;</span><br><span class="line">            <span class="keyword">delete</span>(B[i]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为插入排序的时间代价是 $\Theta(n^2)$, 所以桶排序的时间代价为:</p>
<p>$$T(n) = \Theta(n) + \sum_{i=0}^{n-1}{O({n}_{i}^2)}$$</p>
<p>其中 ${n}_{i}$ 表示桶 <code>B[i]</code> 中元素个数的随机变量.</p>
<p>桶排序可以在线性时间内完成, 只要所有桶的大小平方和与总元素数呈线性关系.</p>
]]></content>
    <summary type="html">
    <![CDATA[我们把在排序的最终结果中, 各元素的次序依赖于它们的比较的排序算法称为比较排序. 而我们在这里介绍的排序将不依赖于元素之间的比较, 即线性时间排序.]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://deltax.me/tags/Algorithm/"/>
    
      <category term="clrs" scheme="http://deltax.me/categories/clrs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Inheritence in Object-Oriented-Programming]]></title>
    <link href="http://deltax.me/2015/03/24/Inheritence-in-Object-Oriented-Programming/"/>
    <id>http://deltax.me/2015/03/24/Inheritence-in-Object-Oriented-Programming/</id>
    <published>2015-03-24T01:07:46.000Z</published>
    <updated>2015-03-26T04:05:04.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Introduction">Introduction</h2><p>The main addition that <strong>OOP</strong> adds to component-based programming is inheritence. OOP allows defining a class incrementally by extending existing classes.</p>
<p>While using inheritence, it must be taken good care of. It may lost control if your application doesn’t use good design patterns.</p>
<h2 id="Inheritence_Graph">Inheritence Graph</h2><p>Inheritence is a way to construct new classes from existing classes. </p>
<ul>
<li>A method in <code>class C</code> overrrdes any method with the same label in all of <code>C</code>‘s superclass.</li>
<li>A class that inherits from exactly one class is said to use <strong>single inheritence</strong>. Inheritence from more than one class is called <strong>multiple inheritence</strong>.</li>
<li>A class hierarchy with the superclass relation can be seen as a directed graph with the current class being the root.</li>
<li>The inheritence is directed and acyclic, there cannot be any inherit cicle in the inheritence hierachy.</li>
<li>After striking out all overridden methods, each remaing method should have a unique label.</li>
</ul>
<p><img src="http://deltax.qiniudn.com/Class-Hierarchy.png?attname=&e=1427254344&token=YJb_IPQrTSw1ox9LenQDH1HRcgHii9w_bp9ddmcz:YuVSCsLdlEzG3RyHdiJQmj7fE2Y" style="display:block;margin:auto"></p>
<h2 id="Method_Access_Control">Method Access Control</h2><p>When executing inside an object, we often want to call another method in the same object, do a kind of recursive invocation. </p>
<p>We need two ways to do a recursive call. They are called static binding and dynamic binding.</p>
<p>Both of them are needed when using inheritence to override methods.</p>
<h3 id="Dynamic_Binding">Dynamic Binding</h3><p>Dynamic binding allows the new class to correctly extend the old class by letting old methods can new methods. Even the new method did not exist whtn the old method is defined. </p>
<p>This is written as <code>{self M}</code>. This chooses the method matching <code>M</code> that is visible in the current object.</p>
<h3 id="Static_Binding">Static Binding</h3><p>Static binding allows the new methods call the old methods when they have to.</p>
<p>This is written <code>C, M</code> (with a comma), where <code>C</code> is a class that defines a method matching <code>M</code>. This chooses the method matching <code>M</code> tgat us visible in class <code>C</code>.</p>
<h2 id="Encapsulation_Control">Encapsulation Control</h2><p>The principle of controlling encapsulation in an object-oriented language is to limit access to class members (attributes and methods) according to the requirements of the application architecure.</p>
<h3 id="Private_and_Public_Scopes">Private and Public Scopes</h3><p>The two most basic scopes are private and public.</p>
<ul>
<li>A private member is one which is only visible in the object instance. The object instance can see all members defined in its class and its superclasses.</li>
<li>A public member is one which is visible everywhere in the program.</li>
</ul>
<p>These definitions of private and public are natural if classes are used to construct data abstractions.</p>
<ol>
<li>A class is not the same thing as the data abstractions it defines. The class is increment.</li>
<li>Attributes are internal to the data abstraction and should be invisible from the outside. This is exactly the definition of private scope.</li>
<li>Methods are make up the external interface of the data abstraction, so they should be visible to all entities that reference the abstraction. This is exactly the definition of public scope.</li>
</ol>
<h3 id="Private_Methods">Private Methods</h3><p>When a method head is a name value, then its scope limited to all instances of the class, but not to the subclasses or their instances. These method is only visible inside the class definition. </p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> C</span><br><span class="line">	meth A(X)</span><br><span class="line">		% <span class="function"><span class="keyword">Method</span> <span class="title">body</span></span><br><span class="line">	<span class="title">end</span></span><br><span class="line"><span class="title">end</span></span></span><br></pre></td></tr></table></figure>
<p>And with <code>!</code> we can capture the method outside the scope.</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">local</span><br><span class="line">	A=<span class="comment">&#123;NewName&#125;</span></span><br><span class="line"><span class="keyword">in</span></span><br><span class="line">	<span class="keyword">class</span> C</span><br><span class="line">		meth !A(X)</span><br><span class="line">			% <span class="function"><span class="keyword">Method</span> <span class="title">body</span></span><br><span class="line">		<span class="title">end</span></span><br><span class="line">	<span class="title">end</span></span><br><span class="line"><span class="title">end</span></span></span><br></pre></td></tr></table></figure>
<p>This creates a name at class definition time.</p>
<h3 id="Protected_Methods">Protected Methods</h3><p>In <code>C++</code>,  method is protected if it is accessible only in the class it is defined or in descendant classes (and all instances of this classes).</p>
<h2 id="Forwarding_and_Delegation">Forwarding and Delegation</h2><p>Inheritence is one way to reuse functionality when defining new functionality. But it can be tricky to use, because it implies a tight binding between classes. </p>
<p>When developing a application, we want to decomposition different components, always inheritence is not a greate choice for this reason.</p>
<p>Sometimes we use looser approaches. Two such approaches are forwarding and delegation.</p>
<p><img src="http://deltax.qiniudn.com/Delegation-Forwarding.png?attname=&e=1427254344&token=YJb_IPQrTSw1ox9LenQDH1HRcgHii9w_bp9ddmcz:56KTT0g8JxSKHlqaNzvLtqiiXOs" style="display:block;margin:auto"></p>
<h3 id="Forwarding">Forwarding</h3><p>An object can forward any message to another object. In this system, we implement this strategy in <code>otherwise</code> method.</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">local</span></span><br><span class="line">	class ForwardMixin</span><br><span class="line">		attr Forward:<span class="constant">none</span></span><br><span class="line">		meth setForward(F) Forward:= F <span class="function"><span class="keyword">end</span></span></span><br><span class="line">		meth otherwise(M)</span><br><span class="line">			<span class="keyword">if</span> @Forward==<span class="constant">none</span> <span class="keyword">then</span> raise undefinedMethod <span class="function"><span class="keyword">end</span></span></span><br><span class="line">			<span class="keyword">else</span> &#123;@Forward M&#125; <span class="function"><span class="keyword">end</span></span></span><br><span class="line">		<span class="function"><span class="keyword">end</span></span></span><br><span class="line">	<span class="function"><span class="keyword">end</span></span></span><br><span class="line"><span class="operator">in</span></span><br><span class="line">	fun &#123;NewF Class Init&#125;</span><br><span class="line">		&#123;New class $ <span class="built_in">from</span> Class ForwardMixin <span class="function"><span class="keyword">end</span> <span class="title">Init</span>&#125;</span></span><br><span class="line">	<span class="function"><span class="keyword">end</span></span></span><br><span class="line"><span class="function"><span class="keyword">end</span></span></span><br></pre></td></tr></table></figure>
<p>Objects created with <code>NewF</code> have a method <code>setForward(F)</code> that lets them set dynamically the object to which the object will forward messages if they do not understand.</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class C1</span><br><span class="line">	meth init skip <span class="function"><span class="keyword">end</span></span></span><br><span class="line">	meth cube(A B) B=A*A*A <span class="function"><span class="keyword">end</span></span></span><br><span class="line"><span class="function"><span class="keyword">end</span></span></span><br><span class="line"></span><br><span class="line">class C2</span><br><span class="line">	meth init skip <span class="function"><span class="keyword">end</span></span></span><br><span class="line">	meth square(A B) B=A*A <span class="function"><span class="keyword">end</span></span></span><br><span class="line"><span class="function"><span class="keyword">end</span></span></span><br><span class="line">Obj1=&#123;NewF C1 init&#125;</span><br><span class="line">Obj2=&#123;NewF C2 init&#125;</span><br><span class="line">&#123;Obj2 setForward(Obj1)&#125;</span><br></pre></td></tr></table></figure>
<p>When <code>{Obj2 cube(10 X)}</code> is called, <code>Obj2</code> forward this message to <code>Obj1</code> and bind the result to <code>X</code>.</p>
<h3 id="Delegation">Delegation</h3><p>Delegation is powerful way to struture a system dynamically. <strong>It lets us build a hierachy among objects instead of among classes</strong>.</p>
<p>Delegation can achieve the same effects as inheritence, with two main differences, but with objects instead of classes, and can be changed at any time.</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">local</span></span><br><span class="line">	SetSelf=&#123;NewName&#125;</span><br><span class="line">	class DelegateMixin</span><br><span class="line">		attr this Delegate:<span class="constant">none</span></span><br><span class="line">		meth !SetSelf(S) this:=S <span class="function"><span class="keyword">end</span></span></span><br><span class="line">		meth <span class="built_in">set</span>(A X) A:=X <span class="function"><span class="keyword">end</span></span></span><br><span class="line">		meth <span class="built_in">get</span>(X ?X) X=@A <span class="function"><span class="keyword">end</span></span></span><br><span class="line">		meth setDelegate(D) Delegate:=D End</span><br><span class="line">		meth Del(M S) SS <span class="operator">in</span></span><br><span class="line">			SS:=this this:=S</span><br><span class="line">			<span class="keyword">try</span> &#123;self M&#125; <span class="keyword">finally</span> this:=SS <span class="function"><span class="keyword">end</span></span></span><br><span class="line">		<span class="function"><span class="keyword">end</span></span></span><br><span class="line">		meth call(M) SS <span class="operator">in</span></span><br><span class="line">			SS:=this this:=self</span><br><span class="line">			<span class="keyword">try</span> &#123;self M&#125; <span class="keyword">finally</span> this:=SS <span class="function"><span class="keyword">end</span></span></span><br><span class="line">		<span class="function"><span class="keyword">end</span></span></span><br><span class="line">		meth otherwise(M)</span><br><span class="line">			<span class="keyword">if</span> @Delegate==<span class="constant">none</span> <span class="keyword">then</span></span><br><span class="line">				raise undefinedMethod <span class="function"><span class="keyword">end</span></span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				&#123;@Delegate Del(M @this)&#125;</span><br><span class="line">			<span class="function"><span class="keyword">end</span></span></span><br><span class="line">		<span class="function"><span class="keyword">end</span></span></span><br><span class="line">	<span class="function"><span class="keyword">end</span></span></span><br><span class="line"><span class="operator">in</span></span><br><span class="line">	fun &#123;NewD Class Init&#125;</span><br><span class="line">		Obj=&#123;New class $ <span class="built_in">from</span> Class DelegateMixin <span class="function"><span class="keyword">end</span> <span class="title">Init</span>&#125;</span></span><br><span class="line">	<span class="operator">in</span></span><br><span class="line">		&#123;Obj SetSelf(Obj)&#125;</span><br><span class="line">		Obj</span><br><span class="line">	<span class="function"><span class="keyword">end</span></span></span><br><span class="line"><span class="function"><span class="keyword">end</span></span></span><br></pre></td></tr></table></figure>
<p>If there are two objects <code>Obj1</code> and <code>Obj2</code>, suppose there exists a method <code>setDelegate</code> such that <code>{Obj2 setDelegate(Obj1)}</code> sets <code>Obj2</code> to delegate to <code>Obj1</code>. And <code>Obj1</code> behaves like <code>Obj2</code>‘s superclass.</p>
<p>When we enter the <code>Del</code> method, we should preserve our <code>this</code> value in a temp variable. Because the <code>{Self M}</code> should executes in the <code>Obj1</code> context and change <code>Obj1</code> attributes.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span></span></span><br><span class="line">   attr <span class="symbol">i:</span><span class="number">0</span></span><br><span class="line">   meth init skip <span class="keyword">end</span></span><br><span class="line">   meth inc(<span class="constant">I</span>)</span><br><span class="line">      &#123;<span class="variable">@this</span> set(i &#123;<span class="variable">@this</span> get(i <span class="variable">$)</span>&#125;+<span class="constant">I</span>)&#125;</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   meth browse</span><br><span class="line">      &#123;<span class="variable">@this</span> inc(<span class="number">10</span>)&#125;</span><br><span class="line">      &#123;<span class="constant">Browse</span> c1<span class="comment">#&#123;<span class="yardoctag">@this</span> get(i $)&#125;&#125;</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   meth c &#123;<span class="variable">@this</span> browse&#125; <span class="keyword">end</span> <span class="keyword">end</span></span><br><span class="line"><span class="constant">Obj1</span>=&#123;<span class="constant">NewD</span> <span class="constant">C1</span> init&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C2</span></span></span><br><span class="line">   attr <span class="symbol">i:</span><span class="number">0</span></span><br><span class="line">   meth init skip <span class="keyword">end</span></span><br><span class="line">   meth browse</span><br><span class="line">      &#123;<span class="variable">@this</span> inc(<span class="number">100</span>)&#125;</span><br><span class="line">      &#123;<span class="constant">Browse</span> c2<span class="comment">#&#123;<span class="yardoctag">@this</span> get(i $)&#125;&#125;</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="constant">Obj2</span>=&#123;<span class="constant">NewD</span> <span class="constant">C2</span> init&#125;</span><br><span class="line">&#123;<span class="constant">Obj2</span> setDelegate(<span class="constant">Obj1</span>)&#125;</span><br></pre></td></tr></table></figure>
<p>If we execute</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;Obj<span class="number">1</span> <span class="keyword">call</span><span class="comment">(browse)</span>&#125;</span><br><span class="line">&#123;Obj<span class="number">2</span> <span class="keyword">call</span><span class="comment">(browse)</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">%</span> c<span class="number">1</span><span class="title">#10</span> c<span class="number">2</span><span class="title">#100</span></span><br></pre></td></tr></table></figure>
<p>But if we change the <code>Del</code> procedure like this:</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">meth <span class="constant">Del(M S)</span> <span class="keyword">in</span></span><br><span class="line">	&#123;<span class="keyword">self</span> <span class="constant">M&#125;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>The previous execution will browse</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c1<span class="hexcolor">#100</span> c2#<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>Because the <code>Obj1</code> does not preserve its attributes, <code>this</code> in <code>{self M}</code> means <code>Obj1</code> instead of <code>Obj2</code>. This make no sense, delegation indeed is design pattern that let other handle the message and deal with own attributes. If we do not save the context in <code>Del</code>, it just like send message to <code>Obj2</code>.</p>
<h2 id="Reflection">Reflection</h2><p>A system is reflection if it can inspect part of its execution while running.</p>
<p>Reflection can be purely introspective or intrusive.</p>
<ul>
<li>Purely Introspective<ul>
<li>Only reading the internal state without modifying it.</li>
</ul>
</li>
<li>Instrutive<ul>
<li>Both reading and modifying the internal state.</li>
</ul>
</li>
</ul>
<h3 id="Meta-Object_Protocols">Meta-Object Protocols</h3><p>The description of how an object system works at a basic level is called meta-object protocol. The ability to change the meta-object protocol is a powerful way to modify an obejct system. It is used for many purposes: debugging, customzing, and separation of concerns.</p>
<h3 id="Methig_Wrapping">Methig Wrapping</h3><p>A common use of meta-object protocol is to do method wrapping. We can write a tracer to track the behavior of an object-oriented program.</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun &#123;<span class="type">TraceNew</span> <span class="type">Class</span> <span class="type">Init</span>&#125;</span><br><span class="line">	<span class="type">Obj</span>=&#123;<span class="type">New</span> <span class="type">Class</span> <span class="type">Init</span>&#125;</span><br><span class="line">	<span class="keyword">proc</span> &#123;<span class="type">TraceObj</span> M&#125;</span><br><span class="line">		&#123;<span class="type">Browse</span> entering(&#123;<span class="type">Label</span> M)&#125;</span><br><span class="line">		&#123;<span class="type">Obj</span> M&#125;</span><br><span class="line">		&#123;<span class="type">Browse</span> exiting(&#123;<span class="type">Label</span> M)&#125;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">in</span> <span class="type">TraceObj</span> <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>If an object is created with this procedure, every method will be traced.</p>
<p>A second way is to implement this with a class instead of a procedure.</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fun &#123;TraceNew2 <span class="class"><span class="keyword">Class</span> <span class="title">Init</span>&#125;</span></span><br><span class="line">   Obj=&#123;<span class="keyword">New</span> <span class="class"><span class="keyword">Class</span> <span class="title">Init</span>&#125;</span></span><br><span class="line">   TInit=&#123;NewName&#125;</span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Tracer</span></span></span><br><span class="line">      meth !TInit skip <span class="keyword">end</span></span><br><span class="line">      meth otherwise(M)</span><br><span class="line">	 &#123;Browse entering(&#123;Label M&#125;)&#125; &#123;Obj M&#125;</span><br><span class="line">	 &#123;Browse exiting(&#123;Label M&#125;)&#125;</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">in &#123;<span class="keyword">New</span> Tracer TInit&#125; <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>This strategy is used dynamic class creation, the <code>otherwise</code> method and a freshname <code>TInit</code>.</p>
<h3 id="Reflection_of_object_state">Reflection of object state</h3><p>We would like to ba able to read and write the whole state of an object, independant of the object’s class.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Introduction">Introduction</h2><p>The main addition that <strong>OOP</strong> adds to component-based programming is inheritence. OO]]>
    </summary>
    
      <category term="CTMCP" scheme="http://deltax.me/tags/CTMCP/"/>
    
      <category term="OOP" scheme="http://deltax.me/tags/OOP/"/>
    
      <category term="Oz" scheme="http://deltax.me/tags/Oz/"/>
    
      <category term="Programming Paradigm" scheme="http://deltax.me/categories/Programming-Paradigm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Class as Data Abstraction in OOP]]></title>
    <link href="http://deltax.me/2015/03/23/Class-as-Data-Abstraction-in-OOP/"/>
    <id>http://deltax.me/2015/03/23/Class-as-Data-Abstraction-in-OOP/</id>
    <published>2015-03-23T02:28:07.000Z</published>
    <updated>2015-03-24T17:17:32.000Z</updated>
    <content type="html"><![CDATA[<p>The heart of the object concept is controlled access to encapsulated data. The behaviour of an object is specified by a <strong>class</strong> which is an incremental definition of a data abstraction.</p>
<ul>
<li>Complete data abstraction<ul>
<li>Defining the various elements that make up a class.</li>
<li>Taking advantage of dynamic typing.</li>
</ul>
</li>
<li>Incremental data abstraction<ul>
<li>Related to inheritance.</li>
</ul>
</li>
</ul>
<h2 id="Defining_Classes_and_Objects">Defining Classes and Objects</h2><p>A class is data structure that defines an object’s internal state (attributes), its behavior (methods), the classes it inherits several properties and operations.</p>
<p>A class is a data abstraction that give its partial and total implementation.</p>
<p>Objects of a given class is called <strong>instances</strong>. These object have differenty identities but can have differnet values for their interval state. And instance is initialized with the operation <code>New</code>.<br><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Obj=&#123;<span class="keyword">New</span> <span class="class"><span class="keyword">Class</span> <span class="title">Init</span>&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>This code creates an new object <code>Obj</code> of class <code>Class</code> and invokes with the message <code>Init</code>. And after the initialize, we can use the syntax <code>{Obj Message}</code> to call a message on instance <code>Obj</code>.</p>
<h2 id="Class_members">Class members</h2><p>A class defines the constituent parts part each of its object will have. There are three kinds of members in class:</p>
<ul>
<li><strong>Attributes</strong><blockquote>
<p>An attribute is a cell that contains part of the instance’s state which is always called <strong>instance variable</strong> in an instance. And this just visible in the class definition. Every instance have seperate set of attributes.</p>
</blockquote>
</li>
<li><p><strong>Methods</strong></p>
<blockquote>
<p>A method is a kind of procedure that is called in the context of a particular object and that access the object’s attribute. </p>
</blockquote>
<ul>
<li>The method consists of a head and body. </li>
<li>The head consists of a label, which must be an atom or a name, and a set of arguments.</li>
<li>The arguments must be distinct variables.</li>
</ul>
</li>
<li><strong>Properties</strong><blockquote>
<p>A property modifies how an object behaves.</p>
</blockquote>
</li>
</ul>
<h2 id="Initializing_Attributes">Initializing Attributes</h2><p>Attributes can be initialized in two ways: per instance or per class.</p>
<ul>
<li><p>Per instance</p>
<ul>
<li><p>An attribute can be given a different initial value per instance.</p>
  <figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OneApt</span></span></span><br><span class="line">	attr streetName</span><br><span class="line">	meth init(X) @streetName=X <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">Apt1=&#123;<span class="keyword">New</span> OneApt init(drottninggatan)&#125;</span><br><span class="line">Apt2=&#123;<span class="keyword">New</span> OneApt init(runNeuve)&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>Per class</p>
<ul>
<li><p>An attribute can be given a value that is the same for all instances of a class. This is done by initilizing it with “:” in the class definition.</p>
  <figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YorkApt</span></span></span><br><span class="line">	attr</span><br><span class="line">		streetName:york</span><br><span class="line">		streetNumber:<span class="number">100</span></span><br><span class="line">		wallColor:_</span><br><span class="line">		floorSurface:wood</span><br><span class="line">	meth init skip <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">Apt3=&#123;<span class="keyword">New</span> OneApt init&#125;</span><br><span class="line">Apt4=&#123;<span class="keyword">New</span> OneApt init&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Per brand</p>
<ul>
<li><p>This is another way to use the per-class initialization. A brand is a set of classes that related in some way.</p>
  <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">L</span>=linux</span><br><span class="line"><span class="keyword">class</span> RedHat attr ostype:<span class="keyword">L</span> end</span><br><span class="line"><span class="keyword">class</span> SuSE attr ostype:<span class="keyword">L</span> end</span><br><span class="line"><span class="keyword">class</span> Debian attr ostype:<span class="keyword">L</span> end</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="First-class_Messages">First-class Messages</h2><p>Messages are records and method heads are patterns that match a record. We can use different type of records to pass to a method.</p>
<ol>
<li>Static record as message. In this case, message is known at <strong>compile time</strong>.</li>
<li>Dynamic record as message. In this case, message is a variable that references a record that calculated at <strong>run time</strong>.</li>
</ol>
<p>In the method definition, the following approach is possible:</p>
<ol>
<li><p>Fixed argument list</p>
 <figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">meth <span class="keyword">add</span>(x:X y:Y)</span><br><span class="line">	% <span class="function"><span class="keyword">Method</span> <span class="title">body</span></span><br><span class="line"><span class="title">end</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Flexible argument list</p>
 <figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">meth <span class="keyword">add</span>(x:X y:Y ...)</span><br><span class="line">	% <span class="function"><span class="keyword">Method</span> <span class="title">body</span></span><br><span class="line"><span class="title">end</span></span></span><br></pre></td></tr></table></figure>
<p> The “…” in the method head means that any message is accepted if has least the listed argument.</p>
</li>
<li><p>Variable reference to method head</p>
<p> The whole method head is referenced by a variable.</p>
 <figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">meth <span class="keyword">add</span>(x:X y:Y ...)=M</span><br><span class="line">	% <span class="function"><span class="keyword">Method</span> <span class="title">body</span></span><br><span class="line"><span class="title">end</span></span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>The variable <code>M</code> references the full message as a record.</p>
<ol>
<li><p>Optional argument</p>
 <figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">meth <span class="keyword">add</span>(x:X y:Y z:Z&lt;=V)</span><br><span class="line">	% <span class="function"><span class="keyword">Method</span> <span class="title">body</span></span><br><span class="line"><span class="title">end</span></span></span><br></pre></td></tr></table></figure>
<p> The <code>&lt;=V</code> in the method head means that field <code>z</code> is optional. You can either called the method with <code>add(x:1 y:2)</code> or <code>add(x:1 y:2 z:3)</code>.</p>
</li>
<li><p>Private method label</p>
<p> Method label can be names. This is denoted by using a variable identifier</p>
 <figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">meth A(bar:X)</span><br><span class="line">	% <span class="function"><span class="keyword">Method</span> <span class="title">body</span></span><br><span class="line"><span class="title">end</span></span></span><br></pre></td></tr></table></figure>
<p> The method <code>A</code> is bound to a fresh name whtn the class is defined. If this method must be used elsewhere in the program, we should pass it explicitly.</p>
</li>
<li><p>Dynamic method label</p>
 <figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">meth !A(bar:X)</span><br><span class="line">	% <span class="function"><span class="keyword">Method</span> <span class="title">body</span></span><br><span class="line"><span class="title">end</span></span></span><br></pre></td></tr></table></figure>
<p> The method label has to be known when the class definitions is executed. The variable must be bound to an atom or a name. This technique can make method secure.</p>
</li>
<li><p>The <code>otherwise</code> method</p>
<p> The method head with label <code>otherwise</code> is a catchall that accepts any message for message for which no other method exists.</p>
 <figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">meth otherwise(M)</span><br><span class="line">	% <span class="function"><span class="keyword">Method</span> <span class="title">body</span></span><br><span class="line"><span class="title">end</span></span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>A class has only one method with <code>otherwise</code>, if this method exists, it accepts any message.</p>
<h2 id="First-class_Attributes">First-class Attributes</h2><p>Attribute names can be calculated at tun time. It is possible to write methods to access and assign any attributes.</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Inspector</span><br><span class="line">	meth <span class="built_in">get</span>(A ?X)</span><br><span class="line">		X=@A</span><br><span class="line">	<span class="function"><span class="keyword">end</span></span></span><br><span class="line">	meth <span class="built_in">set</span>(A X)</span><br><span class="line">		A:=X</span><br><span class="line">	<span class="function"><span class="keyword">end</span></span></span><br><span class="line"><span class="function"><span class="keyword">end</span></span></span><br></pre></td></tr></table></figure>
<p>The <code>get</code> method can get any attribute, and the <code>set</code> method can assign any attribute.</p>
<h2 id="Programming_Techniques">Programming Techniques</h2><p>The class concept we have introduced so far gives a convenient syntax for defining data abstractions with excapsulated state and multiple operations.</p>
<ul>
<li>The class statement defines a class value, which can be instantiated to give objects.</li>
<li>Classes can have external references.</li>
<li>Classes are cmpositional, they can be nested within classes.</li>
<li>Classes are compatible with procedure values, they can be nested within procedures and vice versa.</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>The heart of the object concept is controlled access to encapsulated data. The behaviour of an object is specified by a <strong>class</st]]>
    </summary>
    
      <category term="CTMCP" scheme="http://deltax.me/tags/CTMCP/"/>
    
      <category term="OOP" scheme="http://deltax.me/tags/OOP/"/>
    
      <category term="Oz" scheme="http://deltax.me/tags/Oz/"/>
    
      <category term="Programming Paradigm" scheme="http://deltax.me/categories/Programming-Paradigm/"/>
    
  </entry>
  
</feed>